{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getty","text":"<p>Getty is a framework for building robust, optimal, and reusable (de)serializers in Zig.</p> <p></p> <p></p>"},{"location":"#goals","title":"Goals","text":"<ul> <li>Minimize the amount of code required for (de)serializer implementations.</li> <li>Enable granular customization of the (de)serialization process.</li> <li>Avoid as much performance overhead as possible.</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Compile-time (de)serialization.</li> <li>Out-of-the-box support for a wide variety of standard library types.</li> <li>Customization of (de)serialization logic for both existing and remote types.</li> <li>Data model abstractions that serve as simple and generic baselines for   (de)serializers.</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>The following example uses the Getty JSON library to demonstrate how (de)serialization works.</p> Zig code<pre><code>const std = @import(\"std\");\nconst json = @import(\"json\");\nconst allocator = std.heap.page_allocator;\nconst Point = struct {\nx: i32,\ny: i32,\n};\npub fn main() anyerror!void {\nconst value = Point{ .x = 1, .y = 2 };\nconst serialized = try json.toSlice(allocator, value);\ndefer allocator.free(serialized);\nconst deserialized = try json.fromSlice(null, Point, serialized);\nstd.debug.print(\"{s}\\n\", .{serialized});\nstd.debug.print(\"{}\\n\", .{deserialized});\n}\n</code></pre> Shell session<pre><code>$ zig build run\n{\"x\":1,\"y\":2}\nmain.Point{ .x = 1, .y = 2 }\n</code></pre>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/announcing-getty-010/","title":"Announcing Getty 0.1.0","text":"<p>I am happy to announce the initial version of Getty, 0.1.0. </p> <p>Getty is a framework for building robust, optimal, and reusable serializers/deserializers in Zig. To install Getty for your project, follow the instructions listed on the Installation page.</p>"},{"location":"blog/announcing-getty-010/#whats-in-010","title":"What's in 0.1.0","text":""},{"location":"blog/announcing-getty-010/#core-deserialization","title":"Core (de)serialization","text":"<p>Getty wouldn't be much of a (de)serialization framework if you couldn't (de)serialize anything. So, the initial release brings with it some core (de)serialization capabilities. Specifically, support was added for the following types:</p> SerializationDeserialization <ul> <li>Array</li> <li>Bool</li> <li>Enum</li> <li>Error set</li> <li>Float</li> <li>Integer</li> <li>Null</li> <li>Optional</li> <li>Pointer (one, slice)</li> <li>Struct</li> <li>Tuple</li> <li>Union</li> <li>Vector</li> <li>Void</li> <li><code>std.ArrayListAligned</code></li> <li><code>std.ArrayListAlignedUnmanaged</code></li> <li><code>std.HashMap</code></li> <li><code>std.HashMapUnmanaged</code></li> <li><code>std.SinglyLinkedList</code></li> <li><code>std.TailQueue</code></li> </ul> <ul> <li>Array</li> <li>Bool</li> <li>Enum (non-literal)</li> <li>Float</li> <li>Integer</li> <li>Optional</li> <li>Pointer (one, slice)</li> <li>Struct</li> <li>Tuple</li> <li>Union</li> <li>Void</li> <li><code>std.ArrayListAligned</code></li> <li><code>std.ArrayListAlignedUnmanaged</code></li> <li><code>std.HashMap</code></li> <li><code>std.HashMapUnmanaged</code></li> <li><code>std.SinglyLinkedList</code></li> <li><code>std.TailQueue</code></li> </ul>"},{"location":"blog/announcing-getty-010/#customization","title":"Customization","text":"<p>In addition to the core (de)serialization functionality, this release of Getty also introduces customization blocks, which can be used to define or modify the (de)serialization process.</p>"},{"location":"blog/announcing-getty-020/","title":"Announcing Getty 0.2.0","text":"<p>I am happy to announce a new version of Getty, 0.2.0. </p> <p>Getty is a framework for building robust, optimal, and reusable serializers/deserializers in Zig. To install Getty for your project, follow the instructions listed on the Installation page.</p>"},{"location":"blog/announcing-getty-020/#whats-in-020","title":"What's in 0.2.0","text":""},{"location":"blog/announcing-getty-020/#revamped-interfaces","title":"Revamped Interfaces","text":"<p>Thanks to stage2, there were lots of improvements made to the interfaces in Getty. Most notably:</p> <ul> <li>Required method parameters are now optional struct fields, making implementing interfaces much simpler.</li> <li>Most associated types have been made optional, so no more <code>getty.TODO</code>.</li> <li>Empty error sets are now allowed.</li> <li>No more relying on <code>undefined</code> errors to indicate that a unimplemented method was called. Getty can now have <code>@compileError</code>s in its interfaces to let you know about that.</li> </ul> Zig code<pre><code>const Serializer = struct {\npub usingnamespace Serializer(\n@This(),\nvoid,\nerror{},\nnull,\nnull,\nnull,\nnull,\nnull,\n.{ .serializeBool = serializeBool },\n);\n};\n</code></pre>"},{"location":"blog/announcing-getty-020/#simpler-customization","title":"Simpler Customization","text":"<p>On the customization side of things, two main features have been added.</p> <p>First, you can now write type-defined blocks/tuples (TBT), which are (de)serialization blocks/tuples defined within a <code>struct</code> or <code>union</code> type. Getty will automatically process TBTs, meaning that you don't have to pass them in explicitly.</p> <p>Second, preliminary support for attributes have landed. Attributes allow you to easily configure the (de)serialization process for a type without having to manually write everything out. This release introduced support only for the <code>skip</code>, <code>rename</code>, and <code>ignore_unknown_fields</code> attributes.</p> Zig code<pre><code>const std = @import(\"std\");\nconst json = @import(\"json\");\nconst allocator = std.heap.page_allocator;\nconst Point = struct {\nx: i32,\ny: i32,\npub const @\"getty.sbt\" = struct {\npub fn is(comptime T: type) bool {\nreturn T == Point;\n}\npub const attributes = .{\n.x = .{ .rename = \"X\" },\n.y = .{ .skip = true },\n};\n};\n};\npub fn main() anyerror!void {\n_ = try json.toSlice(allocator, Point{ .x = 1, .y = 2 }); // {\"X\":1}\n}\n</code></pre>"},{"location":"blog/announcing-getty-020/#union-serialization","title":"Union Serialization","text":"<p>Before, unions were serialized as their payload value. However, this made deserialization inconsistent as there's no consistent way to go back with that approach.</p> <p>To fix this, unions are now serialized using the externally tagged format by default.</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst json = @import(\"json\");\nconst allocator = std.heap.page_allocator;\npub fn main() !void {\nconst U = union(enum) { foo: i32 };\nvar slice = try json.toSlice(allocator, U{ .foo = 123 });\ndefer allocator.free(slice);\nstd.debug.print(\"{s}\\n\", .{slice}); // {\"Foo\":123}\n}\n</code></pre>"},{"location":"blog/announcing-getty-020/#deserializeignored","title":"<code>deserializeIgnored</code>","text":"<p>A new method has been added to the <code>getty.Deserializer</code> interface: <code>deserializeIgnored</code>. This method is intended to be used whenever the input data of a deserializer should be ignored. For example, when the <code>skip</code> attribute is set for a <code>struct</code>, <code>deserializeIgnored</code> can be called in order to ignore a key and/or value in the deserializer's input data.</p>"},{"location":"blog/announcing-getty-020/#support","title":"Support","text":"<p>Some new types are now supported by Getty!</p> SerializationDeserialization <ul> <li><code>std.BoundedArray</code></li> </ul> <ul> <li>Union (tagged)</li> <li>Union (untagged)</li> <li>Sentinel-terminated slice</li> </ul>"},{"location":"blog/announcing-getty-020/#other-changes","title":"Other Changes","text":"<p>There are other changes in the Getty 0.2.0 release. You can see the full changelog here.</p>"},{"location":"blog/announcing-getty-021/","title":"Announcing Getty 0.2.1","text":"<p>A new point release of Getty has been published, 0.2.1.</p> <p>Getty is a framework for building robust, optimal, and reusable serializers/deserializers in Zig. To install Getty for your project, follow the instructions listed on the Installation page.</p>"},{"location":"blog/announcing-getty-021/#whats-in-021","title":"What's in 0.2.1","text":"<p>Getty 0.2.1 is a minor update that is designed to prepare the project for the Git Flow workflow. The release batches together some improvements and fixes to make the transition easier.</p> <ul> <li> <p>Serialization and deserialization support for <code>std.BufMap</code> has been added.</p> </li> <li> <p><code>examples/build.zig</code> has been fixed, so now the examples successfully compile and run.</p> </li> </ul>"},{"location":"blog/announcing-getty-021/#other-changes","title":"Other Changes","text":"<p>There are other changes in the Getty 0.2.1 release. You can see the full changelog here.</p>"},{"location":"blog/announcing-getty-022/","title":"Announcing Getty 0.2.2","text":"<p>A new point release of Getty has been published, 0.2.2.</p> <p>Getty is a framework for building robust, optimal, and reusable serializers/deserializers in Zig. To install Getty for your project, follow the instructions listed on the Installation page.</p>"},{"location":"blog/announcing-getty-022/#whats-in-022","title":"What's in 0.2.2","text":"<p>Getty 0.2.2 addresses a few issues caused by changes in the standard library and shields.io.</p> <ul> <li>To reference a field's type, the standard library switched to <code>type</code> instead of <code>field_type</code>.</li> <li>The build badge link apparently requires a branch to be specified now.</li> </ul>"},{"location":"blog/announcing-getty-022/#other-changes","title":"Other Changes","text":"<p>There are other changes in the Getty 0.2.2 release. You can see the full changelog here.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions to Getty are very welcome!</p> <p>This page provides some information and a few guidelines to help get you started on your contributing journey. If you have any questions, feel free to reach out on the Getty Discord.</p>"},{"location":"contributing/#zig","title":"Zig","text":"<ul> <li>Getty currently tracks the <code>master</code> release of Zig, so make sure your version is updated.</li> </ul>"},{"location":"contributing/#issues","title":"Issues","text":"<ul> <li> <p>GitHub Issues are used exclusively for tracking bugs and feature requests for Getty.</p> </li> <li> <p>When filing an issue, please provide a brief explanation on how to reproduce your issue.</p> </li> <li> <p>When filing a feature request, please check if the latest version of Getty already implements the feature beforehand and whether there's already an issue filed for your feature.</p> </li> </ul>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<ul> <li> <p>Please follow our Style Guide whenever contributing code.</p> </li> <li> <p>Before submitting a PR, please test your changes and ensure that the test suite passes locally.</p> </li> <li> <p>When submitting a PR, please have it be relative to a recent Git tip.</p> </li> <li> <p>If you push a new version of a PR, please add a comment about the new version. Notifications aren't sent for commits, so it's easy to miss updates without an explicit comment.</p> </li> </ul>"},{"location":"contributing/#workflow","title":"Workflow","text":"<p>Getty uses the Git Flow model for its development. Essentially, what that means is:</p> <ul> <li> <p>The <code>main</code> branch is strictly for releases and hotfixes. Do not work on it.</p> <ul> <li> <p>Releases are developed on <code>release/&lt;name&gt;</code> branches, which branch off of <code>develop</code>.</p> </li> <li> <p>Hotfixes are developed on <code>hotfix/&lt;name&gt;</code> branches, which branch off of <code>main</code>.</p> </li> </ul> </li> <li> <p>The <code>develop</code> branch is an integration branch for features and fixes. Do not work on it.</p> <ul> <li> <p>Features are developed on <code>feature/&lt;name&gt;</code> branches, which branch off of <code>develop</code>.</p> </li> <li> <p>Fixes are developed on <code>fix/&lt;name&gt;</code> branches, which branch off of <code>develop</code>.</p> </li> </ul> </li> </ul>"},{"location":"contributing/style-guide/","title":"Style Guide","text":"<p>This document describes the coding style that all new code for Getty should try to conform to.</p>"},{"location":"contributing/style-guide/#formatting","title":"Formatting","text":"<ul> <li> <p>All code should be formatted by <code>zig fmt</code>. If your code isn't properly formatted, the CI will fail.</p> </li> <li> <p>When writing a comment, use <code>///</code> for public API descriptions and <code>//</code> for everything else.</p> </li> <li> <p>Try to limit lines to 100 characters. It's okay to go over though, so long as things are readable.</p> </li> </ul>"},{"location":"contributing/style-guide/#naming","title":"Naming","text":"<ul> <li>Follow the naming conventions listed here.</li> </ul>"},{"location":"user-guide/","title":"User Guide","text":"<p>This is the official guide for the Getty framework, and is designed to serve as both:</p> <ul> <li>An introduction to writing serializers and deserializers with Getty.</li> <li>A reference for more experienced Getty developers.</li> </ul>"},{"location":"user-guide/installation/","title":"Installation","text":"<p>To install Getty for your project, you can use any of the methods listed on this page.</p>"},{"location":"user-guide/installation/#manual","title":"Manual","text":"<p>Prerequisites</p> <p>These steps assume that you have the <code>master</code> version of Zig installed.</p> <ol> <li> <p>Add Getty to your project.</p> Shell session<pre><code>git clone https://github.com/getty-zig/getty libs/getty\n</code></pre> </li> <li> <p>Make the following change in <code>build.zig</code>:</p> <code>build.zig</code><pre><code>const std = @import(\"std\");\npub fn build(b: *std.build.Builder) void {\n// ...\nconst exe = b.addExecutable(\"getty-learn\", \"src/main.zig\");\nexe.setTarget(target);\nexe.setBuildMode(mode);\nexe.addPackagePath(\"getty\", \"libs/getty/src/getty.zig\");\nexe.install();\n}\n</code></pre> </li> </ol>"},{"location":"user-guide/installation/#gyro","title":"Gyro","text":"<p>Prerequisites</p> <p>These steps assume that you have the <code>master</code> version of Zig and the Gyro package manager installed.</p> <ol> <li> <p>Add Getty to your project.</p> Shell session<pre><code>gyro add -s github getty-zig/getty\ngyro fetch\n</code></pre> </li> <li> <p>Make the following changes in <code>build.zig</code>:</p> <code>build.zig</code><pre><code>const std = @import(\"std\");\nconst pkgs = @import(\"deps.zig\").pkgs;\npub fn build(b: *std.build.Builder) void {\n// ...\nconst exe = b.addExecutable(\"getty-learn\", \"src/main.zig\");\nexe.setTarget(target);\nexe.setBuildMode(mode);\npkgs.addAllTo(exe);\nexe.install();\n}\n</code></pre> </li> </ol>"},{"location":"user-guide/installation/#zigmod","title":"Zigmod","text":"<p>Prerequisites</p> <p>These steps assume that you have the <code>master</code> version of Zig and the Zigmod package manager installed.</p> <ol> <li> <p>Make the following changes in <code>zigmod.yml</code>:</p> <code>zigmod.yml</code><pre><code># ...\nroot_dependencies:\n- src: git https://gitub.com/getty-zig/getty\n</code></pre> </li> <li> <p>Add Getty to your project.</p> Shell session<pre><code>zigmod fetch\n</code></pre> </li> <li> <p>Make the following changes in <code>build.zig</code>:</p> <code>build.zig</code><pre><code>const std = @import(\"std\");\nconst deps = @import(\"deps.zig\");\npub fn build(b: *std.build.Builder) void {\n// ...\nconst exe = b.addExecutable(\"getty-learn\", \"src/main.zig\");\nexe.setTarget(target);\nexe.setBuildMode(mode);\ndeps.addAllTo(exe);\nexe.install();\n}\n</code></pre> </li> </ol>"},{"location":"user-guide/design/","title":"Design","text":"<p>This section contains information regarding the design of and concepts used by Getty.</p>"},{"location":"user-guide/design/architecture/","title":"Architecture","text":"<p>At a high-level, Getty consists of two flows: one for serialization and another for deserialization.</p> SerializationDeserialization <ol> <li>A Zig value is passed to Getty.</li> <li>Based on the value's type, a serialization block is selected and executed by Getty.</li> <li>The block serializes the passed-in value into Getty's data model.</li> <li>The resulting value is passed to a Serializer, which serializes it into an output data format.</li> </ol> <ol> <li>A Zig type is passed to Getty.</li> <li>Based on the type, a deserialization block is selected and executed by Getty.</li> <li>The block prompts a Deserializer to deserialize its input data into Getty's data model.</li> <li>The resulting value is passed to a Visitor, which converts it into a Zig value of the initial type.</li> </ol> <p> </p>"},{"location":"user-guide/design/blocks-and-tuples/","title":"Blocks and Tuples","text":"<p>Blocks are the fundamental building blocks (pun intended) of Getty's (de)serialization process.</p> <p>They define how types should be serialized or deserialized into. For example, all of the ways a <code>bool</code> value can be serialized by Getty are specified in the <code>getty.ser.blocks.Bool</code> block, and all of the ways that you can deserialize into a <code>[5]i32</code> are defined in <code>getty.de.blocks.Array</code>.</p> <p>Internally, Getty uses blocks to form its core (de)serialization behavior. However, they are also the main mechanism for customization in Getty. Users and (de)serializers can take advantage of blocks in order to customize the way Getty (de)serializes values, as we'll see later on.</p>"},{"location":"user-guide/design/blocks-and-tuples/#blocks","title":"Blocks","text":"<p>A block is nothing more than a <code>struct</code> namespace that specifies two things:</p> <ol> <li>The type(s) that should be (de)serialized by the block.</li> <li>How to serialize or deserialize into values of those types.</li> </ol> <p>There are a few different kinds of blocks you can make in Getty, so let's go over them now.</p>"},{"location":"user-guide/design/blocks-and-tuples/#serialization-blocks","title":"Serialization Blocks","text":"<p>To manually define the serialization process for a type, you can use a serialization block.</p> Zig code<pre><code>const sb = struct {\n// (1)!\npub fn is(comptime T: type) bool {\nreturn T == bool;\n}\n// (2)!\npub fn serialize(value: anytype, serializer: anytype) @TypeOf(serializer).Error!@TypeOf(serializer).Ok {\n// Convert bool value to a Getty Integer.\nconst v: i32 = if (value) 1 else 0;\n// Pass the Getty Integer value to the serializer.\nreturn try serializer.serializeInt(v);\n}\n};\n</code></pre> <ol> <li> <p><code>is</code> specifies which types can be serialized by the <code>sb</code> block.           In this case, the <code>sb</code> block applies only to <code>bool</code> values.</p> </li> <li> <p><code>serialize</code> specifies how to serialize values relevant to the <code>sb</code> block into Getty's data model.           In this case, we're telling Getty to serialize <code>bool</code> values as Integers.</p> </li> </ol>"},{"location":"user-guide/design/blocks-and-tuples/#deserialization-blocks","title":"Deserialization Blocks","text":"<p>To manually define the deserialization process for a type, you can use a deserialization block.</p> Zig code<pre><code>const db = struct {\n// (1)!\npub fn is(comptime T: type) bool {\nreturn T == bool;\n}\n// (2)!\npub fn deserialize(\nallocator: ?std.mem.Allocator,\ncomptime _: type, // (3)!\ndeserializer: anytype,\nvisitor: anytype,\n) @TypeOf(deserializer).Error!@TypeOf(visitor).Value {\nreturn try deserializer.deserializeInt(allocator, visitor);\n}\n// (4)!\npub fn Visitor(comptime Value: type) type {\nreturn struct {\npub usingnamespace getty.de.Visitor(\n@This(),\nValue,\n.{ .visitInt = visitInt },\n);\npub fn visitInt(\n_: @This(),\nallocator: ?std.mem.Allocator,\ncomptime Deserializer: type,\ninput: anytype,\n) Deserializer.Error!Value {\nreturn input != 0;\n}\n};\n}\n};\n</code></pre> <ol> <li> <p><code>is</code> specifies which types can be deserialized into by the <code>db</code> block.           In this case, the <code>db</code> block applies only to <code>bool</code> values.</p> </li> <li> <p><code>deserialize</code> specifies the hint that Getty should provide a deserializer     about the type being deserialized into.           In this case, we call <code>deserializeInt</code>, which means that Getty will tell     the deserializer that the Zig type being deserialized into can probably be     made from a Getty Integer.</p> </li> <li> <p>This parameter (often named <code>T</code>) is the current type being deserialized into.           Usually, you don't need it unless you're doing pointer deserialization.</p> </li> <li> <p><code>Visitor</code> is a generic type that implements <code>getty.de.Visitor</code>.           Visitors are responsible for specifying how to deserialize values from     Getty's data model into Zig. In this case, our visitor can deserialize     Integers into <code>bool</code> values, which it does by simply returning     whether or not the integer is 0.</p> </li> </ol>"},{"location":"user-guide/design/blocks-and-tuples/#attribute-blocks","title":"Attribute Blocks","text":"<p>SBs and DBs are typically used for complex modifications to Getty's (de)serialization processes. For simpler customizations, you can usually get away with the more convenient attribute blocks.</p> <p>Compatibility</p> <p>Attribute blocks may only be defined by <code>struct</code> and <code>union</code> types.</p> <p>With ABs, Getty's default (de)serialization processes are used. For example, <code>struct</code> values would be serialized using the default <code>getty.ser.blocks.Struct</code> block and deserialized with the default <code>getty.de.blocks.Struct</code> block. However, based on the attributes that you specify, slight changes to these default processes will take effect.</p> <p>Regardless of whether you're serializing or deserializing, ABs are always defined like so:</p> Zig code<pre><code>const Point = struct {\nx: i32,\ny: i32 = 123,\n};\nconst ab = struct {\npub fn is(comptime T: type) bool {\nreturn T == Point;\n}\n// (1)!\npub const attributes = .{ // (2)!\n.x = .{ .rename = \"X\" }, // (3)!\n.y = .{ .skip = true },\n};\n};\n</code></pre> <ol> <li> <p><code>attributes</code> specifies various (de)serialization properties for values    relevant to the <code>ab</code> block.         If <code>ab</code> is used for serialization, then <code>attributes</code> specifies that the <code>x</code>    field of <code>Point</code> should be serialized as <code>\"X\"</code>, and that the <code>y</code> field of    <code>Point</code> should be skipped.         If <code>ab</code> is used for deserialization, then <code>attributes</code> specifies that the    value for the <code>x</code> field of <code>Point</code> has been serialized as <code>\"X\"</code>, and that    the <code>y</code> field of <code>Point</code> should not be deserialized.     </p> </li> <li> <p><code>attributes</code> is an anonymous struct literal.           Each field name in <code>attributes</code> must match either a field or variant in     your <code>struct</code> or <code>union</code>, or the word <code>Container</code>. The former are known as     field/variant attributes, while the latter are known as container     attributes.</p> </li> <li> <p>Each field in <code>attributes</code> is also an anonymous struct literal. The    fields in these inner <code>struct</code> values depend on the kind of attribute    you're specifying (i.e., field/variant or container).</p> </li> </ol> <p>Supported Attributes</p> <p>For a complete list of the attributes supported by Getty, see here.</p>"},{"location":"user-guide/design/blocks-and-tuples/#type-defined-blocks","title":"Type-Defined Blocks","text":"<p>The blocks we've discussed so far are known as out-of-band blocks. They're defined separately from the type(s) that they operate on. Out-of-band blocks have their place, such as when you want to customize a type that you didn't define (e.g., the types in <code>std</code>). However, there's a more convenient way to do things for <code>struct</code> and <code>union</code> types that you did define yourself.</p> <p>If you define a block within a <code>struct</code> or <code>union</code>, Getty will automatically process it without you having to pass it to a (de)serializer. All you have to do is make sure the block is public and named <code>@\"getty.sb\"</code> (for serialization) or <code>@\"getty.db\"</code> (for deserialization).</p> <p>Type-defined blocks are defined exactly the same as attribute, serialization, and deserialization blocks are. The only difference is that you don't need an <code>is</code> function in a type-defined block.</p> Zig code<pre><code>const Point = struct {\nx: i32,\ny: i32,\npub const @\"getty.sb\" = struct {\npub const attributes = .{\n.x = .{ .rename = \"X\" },\n.y = .{ .skip = true },\n};\n};\n};\n</code></pre>"},{"location":"user-guide/design/blocks-and-tuples/#usage","title":"Usage","text":"<p>Once you've defined a block, you can pass them along to Getty via the <code>getty.Serializer</code> and <code>getty.Deserializer</code> interfaces. They take optional (de)serialization blocks as arguments.</p> <p>For example, the following defines a serializer that can serialize Booleans and Integers into JSON. It's generic over an SB, which it passes to Getty, making it even easier for us to customize Getty's behavior.</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nfn Serializer(comptime user_sb: ?type) type {\nreturn struct {\npub usingnamespace getty.Serializer(\n@This(),\nOk,\nError,\nuser_sb orelse null,\nnull,\nnull,\nnull,\nnull,\n.{\n.serializeBool = serializeBool,\n.serializeInt = serializeInt,\n},\n);\nconst Ok = void;\nconst Error = error{};\nfn serializeBool(_: @This(), value: bool) Error!Ok {\nstd.debug.print(\"{}\\n\", .{value});\n}\nfn serializeInt(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"{}\\n\", .{value});\n}\n};\n}\nconst sb = struct {\npub fn is(comptime T: type) bool {\nreturn T == bool;\n}\npub fn serialize(value: anytype, serializer: anytype) !@TypeOf(serializer).Ok {\nconst v: i32 = if (value) 1 else 0;\nreturn try serializer.serializeInt(v);\n}\n};\npub fn main() anyerror!void {\n// Normal\n{\nvar s = Serializer(null){};\nconst serializer = s.serializer();\ntry getty.serialize(true, serializer);\ntry getty.serialize(false, serializer);\n}\n// Custom\n{\nvar s = Serializer(sb){};\nconst serializer = s.serializer();\ntry getty.serialize(true, serializer);\ntry getty.serialize(false, serializer);\n}\n}\n</code></pre> Shell session<pre><code>$ zig build run\ntrue\nfalse\n1\n0\n</code></pre>"},{"location":"user-guide/design/blocks-and-tuples/#tuples","title":"Tuples","text":"<p>In order to pass multiple (de)serialization blocks to Getty, you can use (de)serialization tuples.</p> <p>A (de)serialization tuple is, well, a tuple of (de)serialization blocks. They can be used wherever a (de)serialization block can be used and allow you to do some pretty cool things. For example, suppose you had the following type:</p> Zig code<pre><code>const Point = struct {\nx: i32,\ny: i32,\n};\n</code></pre> <p>If all you wanted to do was serialize <code>Point</code> values as Sequences, you'd just write an SB and pass it along to Getty. However, what if you also wanted to serialize <code>i32</code> values as Booleans? One option is to stuff all of your custom serialization logic into a single block. But that gets messy really quick and inevitably becomes a pain to maintain.</p> <p>A much better solution is to break up your serialization logic into separate blocks. One for <code>Point</code> values and one for <code>i32</code> values. Then, you just group them together as a serialization tuple!</p> Zig code<pre><code>const point_sb = struct { ... };\nconst i32_sb = struct { ... };\nconst point_st = .{ point_sb, i32_sb };\n</code></pre>"},{"location":"user-guide/design/data-models/","title":"Data Models","text":"<p>A data model represents a set of types supported by Getty. The types within a data model are purely conceptual; they aren't actually Zig types. For example, there is no <code>i32</code> or <code>u64</code> in either of Getty's data models. Instead, they are both considered to the same type: Integer.</p>"},{"location":"user-guide/design/data-models/#models","title":"Models","text":"<p>Getty maintains two data models: one for serialization and another for deserialization.</p> SerializationDeserialization Boolean <p>Represented by a <code>bool</code> value.</p> Enum <p>Represented by any <code>enum</code> value.</p> Float <p>Represented by any floating-point value (<code>comptime_float</code>, <code>f16</code>, <code>f32</code>, <code>f64</code>, <code>f80</code>, <code>f128</code>).</p> Integer <p>Represented by any integer value (<code>comptime_int</code>, <code>u0</code> \u2013 <code>u65535</code>, <code>i0</code> \u2013 <code>i65535</code>).</p> Map <p>Represented by a <code>getty.ser.Map</code> interface value.</p> Null <p>Represented by a <code>null</code> value.</p> Seq <p>Represented by a <code>getty.ser.Seq</code> interface value.</p> Some <p>Represented by the payload of an optional value.</p> String <p>Represented by any string value as determined by <code>std.meta.trait.isZigString</code>.</p> Structure <p>Represented by a <code>getty.ser.Structure</code> interface value.</p> Void <p>Represented by a <code>void</code> value.</p> Boolean <p>Represented by a <code>bool</code> value.</p> Enum <p>Represented by any <code>enum</code> value.</p> Float <p>Represented by any floating-point value (<code>comptime_float</code>, <code>f16</code>, <code>f32</code>, <code>f64</code>, <code>f80</code>, <code>f128</code>).</p> Integer <p>Represented by any integer value (<code>comptime_int</code>, <code>u0</code> \u2013 <code>u65535</code>, <code>i0</code> \u2013 <code>i65535</code>).</p> Map <p>Represented by a <code>getty.de.MapAccess</code> interface value.</p> Null <p>Represented by a <code>null</code> value.</p> Seq <p>Represented by a <code>getty.de.SeqAccess</code> interface value.</p> Some <p>Represented by the payload of an optional value.</p> String <p>Represented by any string value as determined by <code>std.meta.trait.isZigString</code>.</p> Union <p>Represented by a <code>getty.de.UnionAccess</code> interface value and a <code>getty.de.VariantAccess</code> interface value.</p> Void <p>Represented by a <code>void</code> value.</p>"},{"location":"user-guide/design/data-models/#motivation","title":"Motivation","text":"<p>Getty's data models establish a generic baseline from which (de)serializers can operate.</p> <p> </p> Interactions <p>Notice how the (de)serializers never interact directly with Zig.</p> <ul> <li>Serializers receive values from Getty's data model and serialize them   into a data format.</li> <li>Deserializers receive values from a data format and deserialize them   into Getty's data model.</li> </ul> <p>This design often simplifies the job of a (de)serializer significantly. For example, suppose you wanted to serialize <code>[]i32</code>, <code>[100]i32</code>, <code>std.ArrayList(i32)</code>, and <code>std.TailQueue(i32)</code> values. Since Zig considers all of these types to be different, you'd have to write unique serialization logic for all of them (plus integers)!</p> <p>In Getty, you don't have to do nearly as much work. Getty considers all of the aforementioned types to be the same: they are all Sequences. This means that you only have to specify the serialization process for two types: Integers and Sequences. And by doing so, you'll automatically be able to serialize values of any of the aforementioned types, plus any other value whose type is supported by Getty and is considered a Sequence, such as <code>std.SinglyLinkedList</code> and <code>std.BoundedArray</code>.</p>"},{"location":"user-guide/design/interfaces/","title":"Interfaces","text":"<p>When building a (de)serializer in Getty, you will eventually have to implement an interface.</p> <p>Unfortunately, interfaces in Zig are a userspace thing so everyone has their own way of doing things. So, let's quickly go over how Getty implements interfaces and how you can use them.</p>"},{"location":"user-guide/design/interfaces/#definition","title":"Definition","text":"<p>A Getty interface is a function, and its constraints are specified as a parameter list. For instance, the following interface requires 3 associated types and 1 method from its implementations.</p> Zig code<pre><code>// (1)!\nfn BoolSerializer(\n// (2)!\ncomptime Context: type,\ncomptime O: type,\ncomptime E: type,\n// (3)!\ncomptime methods: struct {\nserializeBool: ?fn (Context, bool) E!O = null,\n},\n) type\n</code></pre> <ol> <li> <p>This function is an interface similar to the ones defined in Getty.</p> </li> <li> <p>These parameters are associated types that implementations of <code>BoolSerializer</code> must provide.</p> </li> <li> <p>This parameter contains the methods that implementations of <code>BoolSerializer</code> must or can provide.</p> <p>If a method is not provided by an implementation, it is up to the interface to decide what happens. Generally, a compile error is raised or an error is returned.</p> </li> </ol> <p>The return value of a Getty interface is a <code>struct</code> namespace that contains two declarations: an interface type and an interface function. A value of the interface type is an interface value.</p> Zig code<pre><code>fn BoolSerializer(\ncomptime Context: type,\ncomptime O: type,\ncomptime E: type,\ncomptime methods: struct {\nserializeBool: ?fn (Context, bool) E!O = null,\n},\n) type {\nreturn struct {\n// (2)!\npub const Interface = struct {\ncontext: Context,\npub const Ok = O;\npub const Error = E;\npub fn serializeBool(self: @This(), value: bool) Error!Ok {\nif (methods.serializeBool) |f| {\nreturn try f(self.context, value);\n}\n@compileError(\"serializeBool is unimplemented\");\n}\n};\n// (1)!\npub fn boolSerializer(self: Context) Interface {\nreturn .{ .context = self };\n}\n};\n}\n</code></pre> <ol> <li> <p>This function is an interface function. Its job is to return an interface value.</p> </li> <li> <p>This declaration is an interface type. They generally have:</p> <ul> <li>A single field to store an instance of an implementation.</li> <li>A few declarations that may be useful to implementations.</li> <li>Wrapper methods that define the interface's behavior.</li> </ul> </li> </ol> <p>Naming Conventions</p> <ul> <li> <p>Interface types are always named after the interface's import path. For   example, the interface type for the   <code>getty.de.SeqAccess</code>   interface is named <code>@\"getty.de.SeqAccess\"</code>.</p> </li> <li> <p>Interface functions are always named after the interface (in   <code>camelCase</code> format). For example, the interface type for the   <code>getty.de.SeqAccess</code>   interface is named <code>seqAccess</code>.</p> </li> </ul>"},{"location":"user-guide/design/interfaces/#implementation","title":"Implementation","text":"<p>To implement a Getty interface, call the interface and apply <code>usingnamespace</code> to its return value. This will import an interface type and interface function into your implementation.</p> Zig code<pre><code>const std = @import(\"std\");\nconst UselessSerializer = struct {\nusingnamespace BoolSerializer(\n@This(),\nvoid,\nerror{},\n.{},\n);\n};\nconst OppositeSerializer = struct {\nusingnamespace BoolSerializer(\nContext,\nOk,\nError,\n.{ .serializeBool = serializeBool },\n);\nconst Context = @This();\nconst Ok = void;\nconst Error = error{};\nfn serializeBool(_: Context, value: bool) Error!Ok {\nstd.debug.print(\"{}\\n\", .{!value});\n}\n};\n</code></pre>"},{"location":"user-guide/design/interfaces/#usage","title":"Usage","text":"<p>To use a value of, say <code>OppositeSerializer</code>, as an implementation of <code>BoolSerializer</code>:</p> Zig code<pre><code>pub fn main() anyerror!void {\nconst os = OppositeSerializer{}; // (1)!\nconst bs = os.boolSerializer();  // (2)!\n// (3)!\ntry bs.serializeBool(true);\ntry bs.serializeBool(false);\n}\n</code></pre> <ol> <li>Create a value of the implementing type, <code>OppositeSerializer</code>.</li> <li>Create an interface value from your implementation using the interface function.</li> <li>Use the interface value for all of your interface-y needs!</li> </ol> Shell session<pre><code>$ zig build run\nfalse\ntrue\n</code></pre>"},{"location":"user-guide/design/values/","title":"Values","text":""},{"location":"user-guide/design/values/#serialization","title":"Serialization","text":"<p>How a Zig value is represented within a data format is determined entirely by whichever Getty serializer you use. Therefore, it's important that you check how a serialization library is handling things before you start using it. As an example, here's how the Getty JSON library does things:</p> Shell session<pre><code>const a = {};                        // serialized as null\nconst b = \"foobar\";                  // serialized as \"foobar\"\nconst c = .foobar;                   // serialized as \"foobar\"\nconst d = .{ 1, 2, 3 };              // serialized as [1,2,3]\nconst e = .{ .x = 1, .y = 2 };       // serialized as {\"x\":1,\"y\":2}\nconst F = union(enum) { foo: i32 };\nconst f = U{ .foo = 1 };             // serialized as {\"foo\":1}\n</code></pre>"},{"location":"user-guide/design/values/#deserialization","title":"Deserialization","text":"<p>Similarly, it is up to a Getty deserializer to determine how values within a data format should be parsed and deserialized. For instance, the Getty JSON library has no issues converting the JSON object <code>{\"foo\":1}</code> into a tagged union. However, other deserializers may expect something different from their input data when deserializing into a union value.</p>"},{"location":"user-guide/tutorial/","title":"Tutorial","text":"<p>If you've ever written a Zig (de)serializer before, you probably wrote a function that took a value, switched on its type, and (de)serialized based on the resulting type information. You might have even called it <code>std.json</code>, as that's exactly how the module works! Unfortunately, this approach is quite brittle, inflexible, and usually ends up being a lot of unnecessary work.</p> <p>The goal of Getty is to help you avoid all of that and reduce the amount of code you need to write a (de)serializer that is customizable, performant, and able to support a wide variety of data types!</p> <p>As an example, the following code defines a JSON serializer that supports scalar and string values. At around 50 lines, <code>Serializer</code> is a fully functional serializer capable of converting values of type <code>bool</code>, <code>i32</code>, <code>enum{ foo }</code>, <code>[]u8</code>, <code>*const [5]u8</code>, <code>?void</code>, and more into JSON!</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\n@This(),\nOk,\nError,\nnull,\nnull,\nnull,\nnull,\nnull,\n.{\n.serializeBool = serializeBool,\n.serializeEnum = serializeEnum,\n.serializeFloat = serializeNumber,\n.serializeInt = serializeNumber,\n.serializeNull = serializeNull,\n.serializeSome = serializeSome,\n.serializeString = serializeString,\n.serializeVoid = serializeNull,\n},\n);\nconst Ok = void;\nconst Error = getty.ser.Error;\nfn serializeBool(_: @This(), value: bool) Error!Ok {\nstd.debug.print(\"{}\\n\", .{value});\n}\nfn serializeEnum(s: @This(), value: anytype) Error!Ok {\ntry s.serializeString(@tagName(value));\n}\nfn serializeNull(_: @This()) Error!Ok {\nstd.debug.print(\"null\\n\", .{});\n}\nfn serializeNumber(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"{}\\n\", .{value});\n}\nfn serializeSome(s: @This(), value: anytype) Error!Ok {\ntry getty.serialize(value, s.serializer());\n}\nfn serializeString(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"\\\"{s}\\\"\\n\", .{value});\n}\n};\npub fn main() !void {\nconst s = (Serializer{}).serializer();\ntry getty.serialize(\"Getty\", s);\n}\n</code></pre> Shell session<pre><code>$ zig build run\n\"Getty\"\n</code></pre> <p>In this tutorial, we'll slowly build up to above implementation so that by the end of it all you'll understand everything there is to know about it. We'll also be extending <code>Serializer</code> to support non-scalar types, such as <code>struct{ x: i32 }</code> and <code>std.ArrayList(i32)</code>. And to cap things off, we'll write ourselves a JSON deserializer and cover how custom (de)serialization works in Getty.</p> <p>Let's get started!</p>"},{"location":"user-guide/tutorial/customization/","title":"Customization","text":"<p>So far, Getty has taken care of all of the little (de)serialization details for us behind the scenes. But sometimes, you need more control. That's where Getty's customization features come in.</p> <p>Getty allows both users and (de)serializers to customize the (de)serialization process for types that you've defined yourself, as well as for types that you didn't define such as those in the standard library. Moreover, the customization enabled by Getty can be used in a local manner. That is, you can serialize a <code>bool</code> value as a String in one function and as an Integer in another, all without having to convert the value to a new or intermediate type.</p> <p>Customization in Getty revolves around Blocks and Tuples, which can be passed to Getty via the <code>*_sbt</code> and <code>*_dbt</code> parameters of the <code>getty.Serializer</code> or <code>getty.Deserializer</code> interfaces.</p>"},{"location":"user-guide/tutorial/customization/#out-of-band-customization","title":"Out-of-Band Customization","text":"<p>Here, we define a serialization block that serializes <code>bool</code> values as Integers.</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n// (1)!\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\n@This(),\nOk,\nError,\nblock, // (2)!\nnull,\nnull,\nnull,\nnull,\n.{ .serializeInt = serializeInt },\n);\nconst Ok = void;\nconst Error = error{};\nfn serializeInt(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"{}\\n\", .{value});\n}\n};\nconst block = struct {\n// (3)!\npub fn is(comptime T: type) bool {\nreturn T == bool;\n}\n// (4)!\npub fn serialize(value: anytype, serializer: anytype) !@TypeOf(serializer).Ok {\nconst v: i32 = if (value) 1 else 0;\nreturn try serializer.serializeInt(v);\n}\n};\npub fn main() anyerror!void {\nconst s = (Serializer{}).serializer();\ntry getty.serialize(true, s);\ntry getty.serialize(false, s);\n}\n</code></pre> <ol> <li> <p>This serializer only knows how to serialize Integers.</p> </li> <li> <p>With <code>block</code> being passed to Getty, <code>bool</code> values will now be     serialized into Getty's data model as Integers, which, of course, is a     type that <code>Serializer</code> knows how to serialize.</p> </li> <li> <p><code>is</code> specifies which types <code>block</code> applies to.</p> </li> <li> <p><code>serialize</code> specifies how to serialize values relevant to <code>block</code>.</p> <p>In this case, we serialize the incoming <code>bool</code> value as an Integer before passing it on to the serializer.</p> </li> </ol> Shell session<pre><code>$ zig build run\n1\n0\n</code></pre> <p>We can also make <code>Serializer</code> generic over a BT to make customization even easier for users.</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nfn Serializer(comptime user_sbt: anytype) type {\nreturn struct {\npub usingnamespace getty.Serializer(\n@This(),\nOk,\nError,\nuser_sbt,\nnull,\nnull,\nnull,\nnull,\n.{\n.serializeInt = serializeInt,\n.serializeString = serializeString,\n},\n);\nconst Ok = void;\nconst Error = error{};\nfn serializeInt(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"{}\\n\", .{value});\n}\nfn serializeString(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"\\\"{s}\\\"\\n\", .{value});\n}\n};\n}\nconst int_block = struct {\npub fn is(comptime T: type) bool {\nreturn T == bool;\n}\npub fn serialize(value: anytype, serializer: anytype) !@TypeOf(serializer).Ok {\nconst v: i32 = if (value) 1 else 0;\nreturn try serializer.serializeInt(v);\n}\n};\nconst string_block = struct {\npub fn is(comptime T: type) bool {\nreturn T == bool;\n}\npub fn serialize(value: anytype, serializer: anytype) !@TypeOf(serializer).Ok {\nconst v = if (value) \"true\" else \"false\";\nreturn try serializer.serializeString(v);\n}\n};\npub fn main() anyerror!void {\n// Integer\n{\nconst s = (Serializer(int_block){}).serializer();\ntry getty.serialize(true, s);\ntry getty.serialize(false, s);\n}\n// String\n{\nconst s = (Serializer(string_block){}).serializer();\ntry getty.serialize(true, s);\ntry getty.serialize(false, s);\n}\n}\n</code></pre> Shell session<pre><code>$ zig build run\n1\n0\n\"true\"\n\"false\"\n</code></pre>"},{"location":"user-guide/tutorial/customization/#in-band-customization","title":"In-Band Customization","text":"<p>Out-of-band customization has its uses, such as when you want to customize a type that you didn't define. However, there's a more convenient way to do things for <code>struct</code> and <code>union</code> types that you did define yourself.</p> <p>If you define a BT within a <code>struct</code> or <code>union</code>, Getty will automatically process it without you having to pass it in directly through a (de)serializer. Just make sure the BT is public and named either <code>@\"getty.sb\"</code> or <code>@\"getty.db\"</code> (<code>sb</code> for serialization, <code>db</code> for deserialization).</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Point = struct {\nx: i32,\ny: i32,\npub const @\"getty.sb\" = struct {\npub const attributes = .{\n.x = .{ .rename = \"X\" },\n.y = .{ .skip = true },\n};\n};\n};\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\n@This(),\nOk,\nError,\nnull,\nnull,\nnull,\nnull,\nStruct,\n.{\n.serializeInt = serializeInt,\n.serializeString = serializeString,\n.serializeStruct = serializeStruct,\n},\n);\nconst Ok = void;\nconst Error = error{};\nfn serializeInt(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"{}\", .{value});\n}\nfn serializeString(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"\\\"{s}\\\"\", .{value});\n}\nfn serializeStruct(_: @This(), comptime _: []const u8, _: usize) Error!Struct {\nstd.debug.print(\"{{\", .{});\nreturn Struct{};\n}\n};\nconst Struct = struct {\nfirst: bool = true,\npub usingnamespace getty.ser.Structure(\n*@This(),\nOk,\nError,\n.{\n.serializeField = serializeField,\n.end = end,\n},\n);\nconst Ok = Serializer.Ok;\nconst Error = Serializer.Error;\nfn serializeField(self: *@This(), comptime key: []const u8, value: anytype) Error!void {\n// Serialize key.\nswitch (self.first) {\ntrue =&gt; self.first = false,\nfalse =&gt; std.debug.print(\", \", .{}),\n}\ntry getty.serialize(key, (Serializer{}).serializer());\n// Serialize value.\nstd.debug.print(\": \", .{});\ntry getty.serialize(value, (Serializer{}).serializer());\n}\nfn end(_: *@This()) Error!Ok {\nstd.debug.print(\"}}\\n\", .{});\n}\n};\npub fn main() anyerror!void {\nconst v = Point{ .x = 1, .y = 2 };\nconst s = (Serializer{}).serializer();\ntry getty.serialize(v, s);\n}\n</code></pre> Shell session<pre><code>$ zig build run\n{\"X\": 1}\n</code></pre>"},{"location":"user-guide/tutorial/deserializers/","title":"Deserializers","text":"<p>Prerequisites</p> <p>This page assumes you know what Getty Interfaces are and how they work. If not, see here before continuing.</p> <p>Now that we have a serializer, let's write a simple (albeit slightly naive) JSON deserializer.</p>"},{"location":"user-guide/tutorial/deserializers/#scalar-deserialization","title":"Scalar Deserialization","text":"<p>Every Getty deserializer must implement the <code>getty.Deserializer</code> interface, shown below.</p> Zig code<pre><code>// (1)!\nfn Deserializer(\ncomptime Context: type, // (2)!\ncomptime E: type, // (3)!\n// (4)!\ncomptime user_dbt: anytype,\ncomptime deserializer_dbt: anytype,\n// (5)!\ncomptime methods: struct {\n// (6)!\ndeserializeAny: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeBool: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeEnum: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeFloat: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeIgnored: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeInt: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeMap: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeOptional: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeSeq: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeString: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeStruct: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeUnion: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeVoid: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\n},\n) type\n</code></pre> <ol> <li> <p>A <code>getty.Deserializer</code> deserializes     values from a data format into Getty's data model.</p> </li> <li> <p><code>Context</code> is a namespace that owns the method implementations passed to the     <code>methods</code> parameter.</p> <p>Usually, this is the type implementing <code>getty.Deserializer</code> or a pointer to it if mutability is required.</p> </li> <li> <p><code>E</code> is the error set returned by     <code>getty.Deserializer</code>'s methods upon     failure.</p> <p>The value of <code>E</code> must contain <code>getty.de.Error</code>, a base error set defined by Getty.</p> </li> <li> <p><code>user_dbt</code> and <code>deserializer_dbt</code> are optional user- and deserializer-defined     derialization blocks or tuples, respectively.</p> <p>They allow users and deserializers to customize Getty's deserialization behavior. If user- or deserializer-defined customization isn't supported, <code>null</code> can be passed in for these parameters.</p> </li> <li> <p><code>methods</code> contains all of the methods that implementations of     <code>getty.Deserializer</code> must     provide or can override.</p> </li> <li> <p>These methods are responsible for deserializing into a specific type in     Getty's data model from a data format.</p> <p>The <code>v</code> parameter in these methods is a <code>getty.de.Visitor</code> interface value.</p> <p>The <code>deserializeAny</code> and <code>deserializeIgnored</code> methods are pretty niche, so we can ignore them for this tutorial.</p> </li> </ol> <p>Quite the parameter list!</p> <p>Luckily, most of the parameters have default values we can use. So, let's start with the following:</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Deserializer = struct {\ntokens: std.json.TokenStream, // (1)!\nconst Self = @This();\npub usingnamespace getty.Deserializer(\n*Self,\nError,\nnull,\nnull,\n.{},\n);\nconst Error = getty.de.Error ||\nstd.json.TokenStream.Error ||\nstd.fmt.ParseIntError ||\nstd.fmt.ParseFloatError;\nconst De = Self.@\"getty.Deserializer\"; // (2)!\npub fn init(json: []const u8) Self {\nreturn .{ .tokens = std.json.TokenStream.init(json) };\n}\n};\n</code></pre> <ol> <li> <p>A JSON parser provided by the standard library.</p> </li> <li> <p>A convenient alias for our <code>getty.Deserializer</code> interface type.</p> </li> </ol> <p>Kind of a useless deserializer...</p> <p>But let's try deserializing a value with it anyways! We can do so by calling <code>getty.deserialize</code>, which takes an optional allocator, a type to deserialize into, and a <code>getty.Deserializer</code> interface value.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Deserializer = struct {\ntokens: std.json.TokenStream,\nconst Self = @This();\npub usingnamespace getty.Deserializer(\n*Self,\nError,\nnull,\nnull,\n.{},\n);\nconst Error = getty.de.Error ||\nstd.json.TokenStream.Error ||\nstd.fmt.ParseIntError ||\nstd.fmt.ParseFloatError;\nconst De = Self.@\"getty.Deserializer\";\npub fn init(json: []const u8) Self {\nreturn .{ .tokens = std.json.TokenStream.init(json) };\n}\n};\npub fn main() anyerror!void {\nconst s = \"true\";\nvar d = Deserializer.init(s);\nconst deserializer = d.deserializer();\nconst v = try getty.deserialize(null, bool, deserializer);\nstd.debug.print(\"{} ({})\\n\", .{ v, @TypeOf(v) });\n}\n</code></pre> Shell session<pre><code>$ zig build run\nerror: deserializeBool is not implemented by type: *main.Deserializer\n</code></pre> <p>Oh no, a compile error!</p> <p>Looks like Getty can't deserialize into the <code>bool</code> type unless <code>deserializeBool</code> is implemented.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Allocator = std.mem.Allocator;\nconst Deserializer = struct {\ntokens: std.json.TokenStream,\nconst Self = @This();\npub usingnamespace getty.Deserializer(\n*Self,\nError,\nnull,\nnull,\n.{\n.deserializeBool = deserializeBool,\n},\n);\nconst Error = getty.de.Error ||\nstd.json.TokenStream.Error ||\nstd.fmt.ParseIntError ||\nstd.fmt.ParseFloatError;\nconst De = Self.@\"getty.Deserializer\";\npub fn init(json: []const u8) Self {\nreturn .{ .tokens = std.json.TokenStream.init(json) };\n}\n// (1)!\nfn deserializeBool(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .True or token == .False) {\nreturn try v.visitBool(allocator, De, token == .True);\n}\n}\nreturn error.InvalidType;\n}\n};\npub fn main() anyerror!void {\nconst s = \"true\";\nvar d = Deserializer.init(s);\nconst deserializer = d.deserializer();\nconst v = try getty.deserialize(null, bool, deserializer);\nstd.debug.print(\"{} ({})\\n\", .{ v, @TypeOf(v) });\n}\n</code></pre> <ol> <li> <p>What we're doing in this function is:</p> <ol> <li>Parsing a token from the JSON data.</li> <li>Checking to see if the token is a JSON Boolean.</li> <li>Deserializing the token into a Boolean (<code>token == .True</code>).</li> <li>Passing the Boolean to the visitor, <code>v</code>.</li> </ol> </li> </ol> Shell session<pre><code>$ zig build run\ntrue (bool)\n</code></pre> <p>Success!</p> <p>Now let's do the same thing for <code>deserializeEnum</code>, <code>deserializeFloat</code>, <code>deserializeInt</code>, <code>deserializeString</code>, <code>deserializeVoid</code>, and <code>deserializeOptional</code>.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Allocator = std.mem.Allocator;\nconst Deserializer = struct {\ntokens: std.json.TokenStream,\nconst Self = @This();\npub usingnamespace getty.Deserializer(\n*Self,\nError,\nnull,\nnull,\n.{\n.deserializeBool = deserializeBool,\n.deserializeEnum = deserializeEnum,\n.deserializeFloat = deserializeFloat,\n.deserializeInt = deserializeInt,\n.deserializeString = deserializeString,\n.deserializeVoid = deserializeVoid,\n.deserializeOptional = deserializeOptional,\n},\n);\nconst Error = getty.de.Error ||\nstd.json.TokenStream.Error ||\nstd.fmt.ParseIntError ||\nstd.fmt.ParseFloatError;\nconst De = Self.@\"getty.Deserializer\";\npub fn init(json: []const u8) Self {\nreturn .{ .tokens = std.json.TokenStream.init(json) };\n}\nfn deserializeBool(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .True or token == .False) {\nreturn try v.visitBool(allocator, De, token == .True);\n}\n}\nreturn error.InvalidType;\n}\n// (1)!\nfn deserializeEnum(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .String) {\nconst str = token.String.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitString(allocator, De, str);\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeFloat(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Number) {\nconst str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitFloat(allocator, De, try std.fmt.parseFloat(f64, str));\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeInt(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Number) {\nconst str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\nif (token.Number.is_integer) {\nreturn try switch (str[0]) {\n'-' =&gt; v.visitInt(allocator, De, try std.fmt.parseInt(i64, str, 10)),\nelse =&gt; v.visitInt(allocator, De, try std.fmt.parseInt(u64, str, 10)),\n};\n}\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeString(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .String) {\nconst str = token.String.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitString(allocator, De, try allocator.?.dupe(u8, str));\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeVoid(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Null) {\nreturn try v.visitVoid(allocator, De);\n}\n}\nreturn error.InvalidType;\n}\n// (2)!\nfn deserializeOptional(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nconst backup = self.tokens;\nif (try self.tokens.next()) |token| {\nif (token == .Null) {\nreturn try v.visitNull(allocator, De);\n}\nself.tokens = backup;\nreturn try v.visitSome(allocator, self.deserializer());\n}\nreturn error.InvalidType;\n}\n};\npub fn main() anyerror!void {\nconst allocator = std.heap.page_allocator; // (3)!\nconst types = .{ i32, f32, []u8, enum { foo }, ?u8, void };\nconst jsons = .{ \"10\", \"10.0\", \"\\\"ABC\\\"\", \"\\\"foo\\\"\", \"null\", \"null\" };\ninline for (jsons) |s, i| {\nconst T = types[i];\nvar d = Deserializer.init(s);\nconst deserializer = d.deserializer();\nconst v = try getty.deserialize(allocator, T, deserializer);\ndefer getty.de.free(allocator, v); // (4)!\nstd.debug.print(\"{any} ({})\\n\", .{ v, @TypeOf(v) });\n}\n}\n</code></pre> <ol> <li> <p>Just like in <code>deserializeBool</code>, all we're doing in these functions is     parsing tokens, turning them into Getty values, and passing those values to     a visitor.</p> <p>By the way, you'll see <code>token.X.slice</code> come up pretty often in our deserializer. All it's doing is getting the string that corresponds to our token from the JSON data.</p> </li> <li> <p><code>deserializeOptional</code> is a bit different from the other methods. Instead of     passing a Getty value to a visitor, you pass a deserializer to <code>visitSome</code>.     The visitor will then restart the deserialization process using the     optional's payload.</p> <p>You can think of this method as a place to do some pre-processing before deserializing an actual payload value.</p> </li> <li> <p>To deserialize pointer values, Getty requires an allocator.</p> </li> <li> <p>This is a convenience function that lets you to easily free values that     were deserialized by Getty.</p> </li> </ol> Shell session<pre><code>$ zig build run\n10 (i32)\n1.0e+01 (f32)\n{ 65, 66, 67 } ([]u8)\nmain.main__enum_1315.foo (main.main__enum_1315)\nnull (?u8)\nvoid (void)\n</code></pre> <p>Not too shabby!</p> The <code>deserialize*</code> methods <p>When Getty calls <code>deserializeBool</code>, it is not telling <code>Deserializer</code> that it should parse and deserialize a JSON Boolean from its input data. Instead, Getty is simply providing a hint about the type that is being deserialized into. </p> <p>That is, Getty is telling <code>Deserializer</code>, \"Hey, the type that the user is deserializing into can most likely be constructed from a Getty Boolean, so you should probably deserialize your input data into one.\"</p> <p>What this means is that we don't have to limit ourselves to parsing only JSON Booleans in <code>deserializeBool</code>. We could, for instance, have <code>deserializeBool</code> support JSON numbers as well.</p> Zig code<pre><code>fn deserializeBool(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\n// JSON Booleans -&gt; Getty Booleans\nif (token == .True or token == .False) {\nreturn try v.visitBool(allocator, De, token == .True);\n}\n// JSON Numbers -&gt; Getty Booleans\nif (token == .Number) {\nif (token.Number.is_integer) {\nconst str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\nconst int = try std.fmt.parseInt(i64, str, 10);\nreturn try v.visitBool(allocator, De, int != 0);\n}\n}\n}\nreturn error.InvalidType;\n}\n</code></pre>"},{"location":"user-guide/tutorial/deserializers/#aggregate-deserialization","title":"Aggregate Deserialization","text":"<p>Alright, now let's take a look at deserialization for aggregate types.</p> <p>The difference between scalar and aggregate deserialization is that the aggregate types in Getty's data model do not directly map to any particular Zig type (or set of Zig types). That is, while Booleans are represented by <code>bool</code>s and Integers are represented by any Zig integer type, there is no native data type in Zig that is able to generically represent Sequences or Maps.</p> <p>This is where the aggregate deserialization interfaces come in. They represent the aggregate types within Getty's data model (from a deserialization perspective). There are four of them:</p> <code>getty.de.SeqAccess</code> <p>Represents a Sequence.</p> <code>getty.de.MapAccess</code> <p>Represents a Map.</p> <code>getty.de.UnionAccess</code>, <code>getty.de.VariantAccess</code> <p>Represents a Union.</p> <p>Let's start by implementing <code>deserializeSeq</code>, which uses the <code>getty.de.SeqAccess</code> interface.</p> getty.de.SeqAccess Zig code<pre><code>// (1)!\nfn SeqAccess(\ncomptime Context: type,\ncomptime E: type,\ncomptime methods: struct {\n// (2)!\nnextElementSeed: ?fn (Context, ?std.mem.Allocator, seed: anytype) E!?@TypeOf(seed).Value = null,\n},\n) type\n</code></pre> <ol> <li> <p>A <code>getty.de.SeqAccess</code> is responsible for deserializing elements of a Sequence into Zig.</p> </li> <li> <p>The <code>seed</code> parameter of <code>nextElementSeed</code> is a <code>getty.de.Seed</code>     interface value, which allows for stateful deserialization.</p> <p>By default, Getty passes in <code>getty.de.DefaultSeed</code> for the <code>seed</code> parameter. The default seed just calls <code>getty.deserialize</code> and can therefore be used for stateless deserialization.</p> </li> </ol> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Allocator = std.mem.Allocator;\nconst Deserializer = struct {\ntokens: std.json.TokenStream,\nconst Self = @This();\npub usingnamespace getty.Deserializer(\n*Self,\nError,\nnull,\nnull,\n.{\n.deserializeBool = deserializeBool,\n.deserializeEnum = deserializeEnum,\n.deserializeFloat = deserializeFloat,\n.deserializeInt = deserializeInt,\n.deserializeString = deserializeString,\n.deserializeVoid = deserializeVoid,\n.deserializeOptional = deserializeOptional,\n.deserializeSeq = deserializeSeq,\n},\n);\nconst Error = getty.de.Error ||\nstd.json.TokenStream.Error ||\nstd.fmt.ParseIntError ||\nstd.fmt.ParseFloatError;\nconst De = Self.@\"getty.Deserializer\";\npub fn init(json: []const u8) Self {\nreturn .{ .tokens = std.json.TokenStream.init(json) };\n}\nfn deserializeBool(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .True or token == .False) {\nreturn try v.visitBool(allocator, De, token == .True);\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeEnum(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .String) {\nconst str = token.String.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitString(allocator, De, str);\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeFloat(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Number) {\nconst str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitFloat(allocator, De, try std.fmt.parseFloat(f64, str));\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeInt(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Number) {\nconst str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\nif (token.Number.is_integer) {\nreturn try switch (str[0]) {\n'-' =&gt; v.visitInt(allocator, De, try std.fmt.parseInt(i64, str, 10)),\nelse =&gt; v.visitInt(allocator, De, try std.fmt.parseInt(u64, str, 10)),\n};\n}\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeString(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .String) {\nconst str = token.String.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitString(allocator, De, try allocator.?.dupe(u8, str));\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeVoid(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Null) {\nreturn try v.visitVoid(allocator, De);\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeOptional(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nconst backup = self.tokens;\nif (try self.tokens.next()) |token| {\nif (token == .Null) {\nreturn try v.visitNull(allocator, De);\n}\nself.tokens = backup;\nreturn try v.visitSome(allocator, self.deserializer());\n}\nreturn error.InvalidType;\n}\nfn deserializeSeq(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .ArrayBegin) {\nvar sa = SeqAccess{ .de = self };\nreturn try v.visitSeq(allocator, De, sa.seqAccess());\n}\n}\nreturn error.InvalidType;\n}\n};\nconst SeqAccess = struct {\nde: *Deserializer,\npub usingnamespace getty.de.SeqAccess(\n*@This(),\nDeserializer.Error,\n.{ .nextElementSeed = nextElementSeed },\n);\nfn nextElementSeed(self: *@This(), allocator: ?Allocator, seed: anytype) Deserializer.Error!?@TypeOf(seed).Value {\n// Deserialize element.\nconst element = seed.deserialize(allocator, self.de.deserializer()) catch |err| {\n// End of input was encountered early.\nif (self.de.tokens.i - 1 &gt;= self.de.tokens.slice.len) {\nreturn err;\n}\nreturn switch (self.de.tokens.slice[self.de.tokens.i - 1]) {\n']' =&gt; null, // End of sequence was encountered.\nelse =&gt; err, // Unexpected token was encountered.\n};\n};\nreturn element;\n}\n};\npub fn main() anyerror!void {\nconst allocator = std.heap.page_allocator;\nvar d = Deserializer.init(\"[1,2,3]\");\nconst deserializer = d.deserializer();\nconst v = try getty.deserialize(allocator, std.ArrayList(i32), deserializer);\ndefer v.deinit();\nstd.debug.print(\"{any} ({})\\n\", .{ v.items, @TypeOf(v) });\n}\n</code></pre> Shell session<pre><code>$ zig build run\n{ 1, 2, 3 } (array_list.ArrayListAligned(i32,null))\n</code></pre> <p>Hooray!</p> <p>Just like before, notice how we didn't have to write any iteration- or access-related code specific to <code>std.ArrayList</code> or any other Zig type. We just had to specify how JSON sequences (arrays) should be deserialized and Getty took care of the rest!</p> <p>Okay, that leaves us with <code>deserializeMap</code> and <code>deserializeUnion</code>. Let's implement the former, which uses the <code>getty.de.MapAccess</code> interface.</p> getty.de.MapAccess Zig code<pre><code>// (1)!\nfn MapAccess(\ncomptime Context: type,\ncomptime E: type,\ncomptime methods: struct {\nnextKeySeed: ?fn (Context, ?std.mem.Allocator, seed: anytype) E!?@TypeOf(seed).Value = null,\nnextValueSeed: ?fn (Context, ?std.mem.Allocator, seed: anytype) E!@TypeOf(seed).Value = null,\n},\n) type\n</code></pre> <ol> <li>A <code>getty.de.MapAccess</code> is responsible for deserializing entries of a Map into Zig.</li> </ol> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Allocator = std.mem.Allocator;\nconst Deserializer = struct {\ntokens: std.json.TokenStream,\nconst Self = @This();\npub usingnamespace getty.Deserializer(\n*Self,\nError,\nnull,\nnull,\n.{\n.deserializeBool = deserializeBool,\n.deserializeEnum = deserializeEnum,\n.deserializeFloat = deserializeFloat,\n.deserializeInt = deserializeInt,\n.deserializeString = deserializeString,\n.deserializeVoid = deserializeVoid,\n.deserializeOptional = deserializeOptional,\n.deserializeSeq = deserializeSeq,\n.deserializeMap = deserializeMap,\n},\n);\nconst Error = getty.de.Error ||\nstd.json.TokenStream.Error ||\nstd.fmt.ParseIntError ||\nstd.fmt.ParseFloatError;\nconst De = Self.@\"getty.Deserializer\";\npub fn init(json: []const u8) Self {\nreturn .{ .tokens = std.json.TokenStream.init(json) };\n}\nfn deserializeBool(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .True or token == .False) {\nreturn try v.visitBool(allocator, De, token == .True);\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeEnum(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .String) {\nconst str = token.String.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitString(allocator, De, str);\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeFloat(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Number) {\nconst str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitFloat(allocator, De, try std.fmt.parseFloat(f64, str));\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeInt(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Number) {\nconst str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\nif (token.Number.is_integer) {\nreturn try switch (str[0]) {\n'-' =&gt; v.visitInt(allocator, De, try std.fmt.parseInt(i64, str, 10)),\nelse =&gt; v.visitInt(allocator, De, try std.fmt.parseInt(u64, str, 10)),\n};\n}\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeString(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .String) {\nconst str = token.String.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitString(allocator, De, try allocator.?.dupe(u8, str));\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeVoid(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Null) {\nreturn try v.visitVoid(allocator, De);\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeOptional(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nconst backup = self.tokens;\nif (try self.tokens.next()) |token| {\nif (token == .Null) {\nreturn try v.visitNull(allocator, De);\n}\nself.tokens = backup;\nreturn try v.visitSome(allocator, self.deserializer());\n}\nreturn error.InvalidType;\n}\nfn deserializeSeq(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .ArrayBegin) {\nvar sa = SeqAccess{ .de = self };\nreturn try v.visitSeq(allocator, De, sa.seqAccess());\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeMap(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .ObjectBegin) {\nvar ma = MapAccess{ .de = self };\nreturn try v.visitMap(allocator, De, ma.mapAccess());\n}\n}\nreturn error.InvalidType;\n}\n};\nconst SeqAccess = struct {\nde: *Deserializer,\npub usingnamespace getty.de.SeqAccess(\n*@This(),\nDeserializer.Error,\n.{ .nextElementSeed = nextElementSeed },\n);\nfn nextElementSeed(self: *@This(), allocator: ?Allocator, seed: anytype) Deserializer.Error!?@TypeOf(seed).Value {\nconst element = seed.deserialize(allocator, self.de.deserializer()) catch |err| {\n// End of input was encountered early.\nif (self.de.tokens.i - 1 &gt;= self.de.tokens.slice.len) {\nreturn err;\n}\nreturn switch (self.de.tokens.slice[self.de.tokens.i - 1]) {\n']' =&gt; null, // End of sequence was encountered.\nelse =&gt; err, // Unexpected token was encountered.\n};\n};\nreturn element;\n}\n};\nconst MapAccess = struct {\nde: *Deserializer,\npub usingnamespace getty.de.MapAccess(\n*@This(),\nDeserializer.Error,\n.{\n.nextKeySeed = nextKeySeed,\n.nextValueSeed = nextValueSeed,\n},\n);\nfn nextKeySeed(self: *@This(), allocator: ?Allocator, seed: anytype) Deserializer.Error!?@TypeOf(seed).Value {\nconst tokens = self.d.tokens;\nif (try self.d.tokens.next()) |token| {\n// End of map was encountered.\nif (token == .ObjectEnd) {\nreturn null;\n}\n// Key was encountered.\nif (token == .String) {\n// Restore key.\nself.de.tokens = tokens;\n// Deserialize key.\nreturn try seed.deserialize(allocator, self.de.deserializer());\n}\n}\nreturn error.InvalidType;\n}\nfn nextValueSeed(self: *@This(), allocator: ?Allocator, seed: anytype) Deserializer.Error!@TypeOf(seed).Value {\nreturn try seed.deserialize(allocator, self.d.deserializer());\n}\n};\npub fn main() anyerror!void {\nconst allocator = std.heap.page_allocator;\nvar d = Deserializer.init(\"\\\"x\\\":1,\\\"y\\\":2\");\nconst deserializer = d.deserializer();\nconst v = try getty.deserialize(allocator, struct{ x: i32, y: i32 }, deserializer);\nstd.debug.print(\"{any} ({})\\n\", .{ v, @TypeOf(v) });\n}\n</code></pre> <ol> <li> <p>What we're doing here is telling Getty to perform deserialization again (by     calling <code>seed.deserialize</code>) so that we can deserialize an element from the     deserializer's input data.</p> <p>If there are no elements left (i.e., if <code>]</code> was encountered) then <code>null</code> is returned. Otherwise, the deserialized element is.</p> <p>The <code>seed</code> parameter of <code>nextElementSeed</code> is a <code>getty.de.Seed</code> interface value, which allows for stateful deserialization. We don't really need that for this tutorial, but we can still use <code>seed</code> since the default seed of Getty just calls <code>getty.deserialize</code>.</p> </li> </ol> Shell session<pre><code>$ zig build run\n{ 1, 2, 3 } (array_list.ArrayListAligned(i32,null))\n</code></pre>"},{"location":"user-guide/tutorial/serializers/","title":"Serializers","text":"<p>Prerequisites</p> <p>This page assumes you know what Getty Interfaces are and how they work. If not, see here before continuing.</p> <p>We'll write a JSON serializer that serializes values by printing their JSON equivalent to <code>STDERR</code>.</p>"},{"location":"user-guide/tutorial/serializers/#scalar-serialization","title":"Scalar Serialization","text":"<p>Every Getty serializer must implement the <code>getty.Serializer</code> interface, shown below.</p> Zig code<pre><code>// (1)!\nfn Serializer(\ncomptime Context: type, // (2)!\ncomptime O: type, // (3)!\ncomptime E: type, // (4)!\n// (5)!\ncomptime user_sbt: anytype,\ncomptime serializer_sbt: anytype,\n// (6)!\ncomptime Map: ?type,\ncomptime Seq: ?type,\ncomptime Structure: ?type,\n// (7)!\ncomptime methods: struct {\n// (8)!\nserializeBool: ?fn (Context, bool) E!O = null,\nserializeEnum: ?fn (Context, anytype) E!O = null,\nserializeFloat: ?fn (Context, anytype) E!O = null,\nserializeInt: ?fn (Context, anytype) E!O = null,\nserializeMap: ?fn (Context, ?usize) E!Map = null,\nserializeNull: ?fn (Context) E!O = null,\nserializeSeq: ?fn (Context, ?usize) E!Seq = null,\nserializeSome: ?fn (Context, anytype) E!O = null,\nserializeString: ?fn (Context, anytype) E!O = null,\nserializeStruct: ?fn (Context, comptime []const u8, usize) E!Structure = null,\nserializeVoid: ?fn (Context) E!O = null,\n},\n) type\n</code></pre> <ol> <li> <p>A <code>getty.Serializer</code> serializes     values from Getty's data model.</p> </li> <li> <p><code>Context</code> is a namespace that owns the method implementations passed to the     <code>methods</code> parameter.</p> <p>Usually, this is the type implementing <code>getty.Serializer</code> or a pointer to it if mutability is required.</p> </li> <li> <p><code>O</code> is the successful return type for most of     <code>getty.Serializer</code>'s methods.</p> </li> <li> <p><code>E</code> is the error set returned by     <code>getty.Serializer</code>'s methods upon     failure.</p> <p>The value of <code>E</code> must contain <code>getty.ser.Error</code>, a base error set defined by Getty.</p> </li> <li> <p><code>user_sbt</code> and <code>serializer_sbt</code> are optional user- and serializer-defined     serialization blocks or tuples, respectively.</p> <p>They allow users and serializers to customize Getty's serialization behavior. If user- or serializer-defined customization isn't supported, you can pass in <code>null</code> for these parameters.</p> </li> <li> <p><code>Map</code>, <code>Seq</code>, and <code>Structure</code> are optional types that implement Getty's     aggregate serialization interfaces.</p> <p>The aggregate serialization interfaces are <code>getty.ser.Map</code>, <code>getty.ser.Seq</code>, and <code>getty.ser.Structure</code>. I'm sure you can figure out which parameters should implement which interfaces.</p> <p>If you don't want to support serialization for aggregate types or if you simply haven't implemented it yet, you can pass in <code>null</code> for these parameters.</p> </li> <li> <p><code>methods</code> contains all of the methods that implementations of     <code>getty.Serializer</code> must provide     or can override.</p> </li> <li> <p>These methods are responsible for serializing a value in Getty's data     model into a data format.</p> </li> </ol> <p>Quite the parameter list!</p> <p>Luckily, most of the parameters have default values we can use. So, let's start with the following:</p> <code>src/main.zig</code><pre><code>const getty = @import(\"getty\");\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\n@This(),\nOk,\nError,\nnull,\nnull,\nnull,\nnull,\nnull,\n.{},\n);\nconst Ok = void;\nconst Error = getty.ser.Error;\n};\n</code></pre> <p>Kind of a useless serializer...</p> <p>But let's try serializing a value with it anyways! We can do so by calling <code>getty.serialize</code>, which takes a value to serialize and a <code>getty.Serializer</code> interface value.</p> <code>src/main.zig</code><pre><code>const getty = @import(\"getty\");\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\n@This(),\nOk,\nError,\nnull,\nnull,\nnull,\nnull,\nnull,\n.{},\n);\nconst Ok = void;\nconst Error = getty.ser.Error;\n};\npub fn main() anyerror!void {\nconst s = (Serializer{}).serializer();\ntry getty.serialize(true, s);\n}\n</code></pre> Shell session<pre><code>$ zig build run\n[...] error: serializeBool is not implemented by type: main.Serializer\n</code></pre> <p>Oh no, a compile error!</p> <p>Looks like Getty can't serialize <code>bool</code> values unless <code>serializeBool</code> is implemented.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\n@This(),\nOk,\nError,\nnull,\nnull,\nnull,\nnull,\nnull,\n.{\n.serializeBool = serializeBool,\n},\n);\nconst Ok = void;\nconst Error = getty.ser.Error;\nfn serializeBool(_: @This(), value: bool) Error!Ok {\nstd.debug.print(\"{}\", .{value});\n}\n};\npub fn main() anyerror!void {\nconst s = (Serializer{}).serializer();\ntry getty.serialize(true, s);\nstd.debug.print(\"\\n\", .{});\n}\n</code></pre> Shell session<pre><code>$ zig build run\ntrue\n</code></pre> <p>Success!</p> <p>Now let's do the same thing for <code>serializeEnum</code>, <code>serializeFloat</code>, <code>serializeInt</code>, <code>serializeNull</code>, <code>serializeSome</code>, <code>serializeString</code>, and <code>serializeVoid</code>.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\n@This(),\nOk,\nError,\nnull,\nnull,\nnull,\nnull,\nnull,\n.{\n.serializeBool = serializeBool,\n.serializeEnum = serializeEnum,\n.serializeFloat = serializeNumber,\n.serializeInt = serializeNumber,\n.serializeNull = serializeNull,\n.serializeSome = serializeSome,\n.serializeString = serializeString,\n.serializeVoid = serializeNull,\n},\n);\nconst Ok = void;\nconst Error = getty.ser.Error;\nfn serializeBool(_: @This(), value: bool) Error!Ok {\nstd.debug.print(\"{}\", .{value});\n}\nfn serializeEnum(self: @This(), value: anytype) Error!Ok {\ntry self.serializeString(@tagName(value));\n}\nfn serializeNull(_: @This()) Error!Ok {\nstd.debug.print(\"null\", .{});\n}\nfn serializeNumber(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"{}\", .{value});\n}\nfn serializeSome(self: @This(), value: anytype) Error!Ok {\ntry getty.serialize(value, self.serializer());\n}\nfn serializeString(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"\\\"{s}\\\"\", .{value});\n}\n};\npub fn main() anyerror!void {\nconst s = (Serializer{}).serializer();\ninline for (.{ 10, 10.0, \"string\", .variant, {}, null }) |v| {\ntry getty.serialize(v, s);\nstd.debug.print(\"\\n\", .{});\n}\n}\n</code></pre> Shell session<pre><code>$ zig build run\n10\n1.0e+01\n\"string\"\n\"variant\"\nnull\nnull\n</code></pre> <p>And there we have it! Our initial <code>Serializer</code> implementation, but now with a bit of context!</p> Method Reuse <p>Since the signatures of the <code>serializeFloat</code> and <code>serializeInt</code> methods are the same, we were able to implement both of them using one function: <code>serializeNumber</code>. We were also able to do the same thing for <code>serializeNull</code> and <code>serializeVoid</code>.</p> Private Methods <p>By keeping all of our method implementations private, we avoid polluting the public API of <code>Serializer</code> with interface-related code. Additionally, we ensure that users cannot mistakenly use a <code>Serializer</code> value instead of an interface value to perform serialization.</p> Type Validation <p>Even though the type of the <code>value</code> parameter for many of our methods is <code>anytype</code>, we didn't perform any type validation. That's because Getty ensures that an appropriate type will be passed to each function. For example, strings will be passed to <code>serializeString</code> and integers and floating-points will be passed to <code>serializeNumber</code>.</p>"},{"location":"user-guide/tutorial/serializers/#aggregate-serialization","title":"Aggregate Serialization","text":"<p>Alright, now let's take a look at serialization for aggregate types.</p> <p>If you'll recall, the <code>getty.Serializer</code> interface requires three associated types from its implementations: <code>Seq</code>, <code>Map</code>, and <code>Structure</code>. These are optional types that impelement the <code>getty.ser.Seq</code>, <code>getty.ser.Map</code> and <code>getty.ser.Structure</code> interfaces, respectively.</p> <p>Why do we need these parameters to create a serializer? Well, because aggregate types have all kinds of different access and iteration patterns, but Getty can't possibly know about all of them. As such, aggregate serialization methods like <code>serializeMap</code> are only responsible for starting the serialization process, before returning a value of either <code>Map</code>, <code>Seq</code>, or <code>Structure</code> (depending on which method was called). The returned value is then used by the caller to finish off serialization.</p> <p>To give you an example of what I mean, let's implement the <code>serializeSeq</code> method, which returns a value of type <code>Seq</code>, which is expected to implement the <code>getty.ser.Seq</code> interface.</p> getty.ser.Seq Zig code<pre><code>// (1)!\nfn Seq(\ncomptime Context: type,\n// (2)!\ncomptime O: type,\ncomptime E: type,\ncomptime methods: struct {\nserializeElement: ?fn (Context, anytype) E!void = null,\nend: ?fn (Context) E!O = null,\n},\n) type\n</code></pre> <ol> <li> <p>A <code>getty.ser.Seq</code> is responsible     for serializing the elements of a Sequence and ending the     serialization process for a Sequence.</p> </li> <li> <p>The value of these parameters must match the <code>O</code> and <code>E</code> values of a     corresponding     <code>getty.Serializer</code>     implementation.</p> </li> </ol> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\n@This(),\nOk,\nError,\nnull,\nnull,\nnull,\nSeq,\nnull,\n.{\n.serializeBool = serializeBool,\n.serializeEnum = serializeEnum,\n.serializeFloat = serializeNumber,\n.serializeInt = serializeNumber,\n.serializeNull = serializeNull,\n.serializeSeq = serializeSeq,\n.serializeSome = serializeSome,\n.serializeString = serializeString,\n.serializeVoid = serializeNull,\n},\n);\nconst Ok = void;\nconst Error = getty.ser.Error;\nfn serializeBool(_: @This(), value: bool) Error!Ok {\nstd.debug.print(\"{}\", .{value});\n}\nfn serializeEnum(s: @This(), value: anytype) Error!Ok {\ntry s.serializeString(@tagName(value));\n}\nfn serializeNull(_: @This()) Error!Ok {\nstd.debug.print(\"null\", .{});\n}\nfn serializeNumber(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"{}\", .{value});\n}\n// (1)!\nfn serializeSeq(_: @This(), _: ?usize) Error!Seq {\nstd.debug.print(\"[\", .{});\nreturn Seq{};\n}\nfn serializeSome(s: @This(), value: anytype) Error!Ok {\ntry getty.serialize(value, s.serializer());\n}\nfn serializeString(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"\\\"{s}\\\"\", .{value});\n}\n};\nconst Seq = struct {\nfirst: bool = true,\npub usingnamespace getty.ser.Seq(\n*@This(),\nOk,\nError,\n.{\n.serializeElement = serializeElement,\n.end = end,\n},\n);\nconst Ok = Serializer.Ok;\nconst Error = Serializer.Error;\nfn serializeElement(s: *@This(), value: anytype) Error!void {\nswitch (s.first) {\ntrue =&gt; s.first = false,\nfalse =&gt; std.debug.print(\",\", .{}),\n}\ntry getty.serialize(value, (Serializer{}).serializer());\n}\nfn end(_: *@This()) Error!Ok {\nstd.debug.print(\"]\", .{});\n}\n};\npub fn main() anyerror!void {\nconst s = (Serializer{}).serializer();\nvar list = std.ArrayList(i32).init(std.heap.page_allocator);\ndefer list.deinit();\ntry list.append(1);\ntry list.append(2);\ntry list.append(3);\ntry getty.serialize(list, s);\nstd.debug.print(\"\\n\", .{});\n}\n</code></pre> <ol> <li>The 2<sup>nd</sup> parameter of <code>serializeSeq</code> is an optional length for the    Sequence being serialized.</li> </ol> Shell session<pre><code>$ zig build run\n[1,2,3]\n</code></pre> <p>Hooray!</p> <p>If you'll notice, we didn't have to write any iteration- or access-related code specific to the <code>std.ArrayList</code> type. All we had to do was specify how sequence serialization should start, how elements should be serialized, and how serialization should end. And Getty took care of the rest!</p> <p>Okay, that leaves us with <code>serializeMap</code> and <code>serializeStruct</code>, which return implementations of <code>getty.ser.Map</code> and <code>getty.ser.Structure</code>, respectively.</p> getty.ser.Map Zig code<pre><code>// (1)!\nfn Map(\ncomptime Context: type,\n// (2)!\ncomptime O: type,\ncomptime E: type,\ncomptime methods: struct {\nserializeKey: ?fn (Context, anytype) E!void = null,\nserializeValue: ?fn (Context, anytype) E!void = null,\nend: ?fn (Context) E!O = null,\n},\n) type\n</code></pre> <ol> <li> <p>A <code>getty.ser.Map</code> is responsible     for serializing the keys and values of a Map and ending the     serialization process for a Map.</p> </li> <li> <p>The value of these parameters must match the <code>O</code> and <code>E</code> values of a     corresponding     <code>getty.Serializer</code>     implementation.</p> </li> </ol> getty.ser.Structure Zig code<pre><code>// (1)!\nfn Structure(\ncomptime Context: type,\n// (2)!\ncomptime O: type,\ncomptime E: type,\ncomptime methods: struct {\nserializeField: ?fn (Context, comptime []const u8, anytype) E!void = null,\nend: ?fn (Context) E!O = null,\n},\n) type\n</code></pre> <ol> <li> <p>A <code>getty.ser.Structure</code> is     responsible for serializing the fields of a Structure and ending the     serialization process for a Structure.</p> </li> <li> <p>The value of these parameters must match the <code>O</code> and <code>E</code> values of a     corresponding     <code>getty.Serializer</code>     implementation.</p> </li> </ol> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\n@This(),\nOk,\nError,\nnull,\nnull,\nMap,\nSeq,\nMap,\n.{\n.serializeBool = serializeBool,\n.serializeEnum = serializeEnum,\n.serializeFloat = serializeNumber,\n.serializeInt = serializeNumber,\n.serializeMap = serializeMap,\n.serializeNull = serializeNull,\n.serializeSeq = serializeSeq,\n.serializeSome = serializeSome,\n.serializeString = serializeString,\n.serializeStruct = serializeStruct,\n.serializeVoid = serializeNull,\n},\n);\nconst Ok = void;\nconst Error = getty.ser.Error;\nfn serializeBool(_: @This(), value: bool) Error!Ok {\nstd.debug.print(\"{}\", .{value});\n}\nfn serializeEnum(s: @This(), value: anytype) Error!Ok {\ntry s.serializeString(@tagName(value));\n}\n// (1)!\nfn serializeMap(_: @This(), _: ?usize) Error!Map {\nstd.debug.print(\"{{\", .{});\nreturn Map{};\n}\nfn serializeNull(_: @This()) Error!Ok {\nstd.debug.print(\"null\", .{});\n}\nfn serializeNumber(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"{}\", .{value});\n}\nfn serializeSeq(_: @This(), _: ?usize) Error!Seq {\nstd.debug.print(\"[\", .{});\nreturn Seq{};\n}\nfn serializeSome(self: @This(), value: anytype) Error!Ok {\ntry getty.serialize(value, self.serializer());\n}\nfn serializeString(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"\\\"{s}\\\"\", .{value});\n}\n// (2)!\nfn serializeStruct(self: @This(), comptime _: []const u8, len: usize) Error!Map {\nreturn try self.serializeMap(len);\n}\n};\nconst Seq = struct {\nfirst: bool = true,\npub usingnamespace getty.ser.Seq(\n*@This(),\nOk,\nError,\n.{\n.serializeElement = serializeElement,\n.end = end,\n},\n);\nconst Ok = Serializer.Ok;\nconst Error = Serializer.Error;\nfn serializeElement(self: *@This(), value: anytype) Error!void {\nswitch (self.first) {\ntrue =&gt; self.first = false,\nfalse =&gt; std.debug.print(\",\", .{}),\n}\ntry getty.serialize(value, (Serializer{}).serializer());\n}\nfn end(_: *@This()) Error!Ok {\nstd.debug.print(\"]\", .{});\n}\n};\nconst Map = struct {\nfirst: bool = true,\npub usingnamespace getty.ser.Map(\n*@This(),\nOk,\nError,\n.{\n.serializeKey = serializeKey,\n.serializeValue = serializeValue,\n.end = end,\n},\n);\npub usingnamespace getty.ser.Structure(\n*@This(),\nOk,\nError,\n.{\n.serializeField = serializeField,\n.end = end,\n},\n);\nconst Ok = Serializer.Ok;\nconst Error = Serializer.Error;\nfn serializeKey(self: *@This(), value: anytype) Error!void {\nswitch (self.first) {\ntrue =&gt; self.first = false,\nfalse =&gt; std.debug.print(\",\", .{}),\n}\ntry getty.serialize(value, (Serializer{}).serializer());\n}\nfn serializeValue(_: *@This(), value: anytype) Error!void {\nstd.debug.print(\":\", .{});\ntry getty.serialize(value, (Serializer{}).serializer());\n}\nfn serializeField(self: *@This(), comptime key: []const u8, value: anytype) Error!void {\ntry self.serializeKey(key);\ntry self.serializeValue(value);\n}\nfn end(_: *@This()) Error!Ok {\nstd.debug.print(\"}}\", .{});\n}\n};\npub fn main() anyerror!void {\nconst s = (Serializer{}).serializer();\nvar map = std.StringHashMap(i32).init(std.heap.page_allocator);\ndefer map.deinit();\ntry map.put(\"x\", 1);\ntry map.put(\"y\", 2);\ntry getty.serialize(map, s);\nstd.debug.print(\"\\n\", .{});\n}\n</code></pre> <ol> <li> <p>The 2<sup>nd</sup> parameter of <code>serializeMap</code> is an optional length for the    Map being serialized.</p> </li> <li> <p>The 2<sup>nd</sup> parameter of <code>serializeStruct</code> is the name that should be used    for the Structure being serialized.</p> </li> </ol> Shell session<pre><code>$ zig build run\n{\"x\":1,\"y\":2}\n</code></pre> <p>And there we go! Our JSON serializer is now complete!</p>"},{"location":"user-guide/tutorial/setup/","title":"Setup","text":"<p>To begin, we need to set up a new project:</p> <ol> <li> <p>Create a Zig project called <code>getty-learn</code>:</p> Shell session<pre><code>mkdir getty-learn\ncd getty-learn\nzig init-exe\n</code></pre> </li> <li> <p>Install Getty into the <code>lib/getty</code> directory within <code>getty-learn</code>:</p> Shell session<pre><code>git clone https://github.com/getty-zig/getty lib/getty\n</code></pre> </li> <li> <p>Make <code>getty-learn</code> aware of Getty by calling <code>addPackagePath</code> in <code>build.zig</code>:</p> <code>build.zig</code><pre><code>const std = @import(\"std\");\npub fn build(b: *std.build.Builder) void {\n// ...\nconst exe = b.addExecutable(\"getty-learn\", \"src/main.zig\");\nexe.setTarget(target);\nexe.setBuildMode(mode);\nexe.addPackagePath(\"getty\", \"lib/getty/src/getty.zig\");\nexe.install();\n}\n</code></pre> </li> <li> <p>Replace the contents of <code>src/main.zig</code> with the following:</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\npub fn main() anyerror!void {\nstd.debug.print(\"{}\\n\", .{getty});\n}\n</code></pre> </li> <li> <p>Run the application to make sure everything is working correctly:</p> Shell session<pre><code>$ zig build run\ngetty\n</code></pre> </li> </ol> <p>And that's it! Now we can start writing our serializer.</p>"}]}