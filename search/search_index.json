{"config":{"lang":["en"],"separator":"[\\s\\-]+"},"docs":[{"title":"Getty","text":"<p>Getty is a framework for building robust, optimal, and reusable (de)serializers in Zig.</p>","location":""},{"title":"Goals","text":"<ul> <li>Minimize the amount of code required for (de)serializer implementations.</li> <li>Enable granular customization of the (de)serialization process.</li> <li>Avoid as much performance overhead as possible.</li> </ul>","location":"#goals"},{"title":"Features","text":"<ul> <li>Compile-time (de)serialization.</li> <li>Out-of-the-box support for a wide variety of standard library types.</li> <li>Local customization of (de)serialization logic for both existing and remote types.</li> <li>Data model abstractions that serve as simple and generic baselines for (de)serializers.</li> </ul>","location":"#features"},{"title":"Quick Start","text":"<p>The following example defines a JSON serializer that supports Booleans and Sequences.</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\nconst allocator = std.heap.page_allocator;\n\nconst Serializer = struct {\n    pub usingnamespace getty.Serializer(\n        Serializer,\n        Ok,\n        Error,\n        null,\n        null,\n        null,\n        Seq,\n        null,\n        .{\n            .serializeBool = serializeBool,\n            .serializeSeq = serializeSeq,\n        },\n    );\n\n    const Ok = void;\n    const Error = error{};\n\n    fn serializeBool(_: Serializer, value: bool) Error!Ok {\n        std.debug.print(\"{}\", .{value});\n    }\n\n    fn serializeSeq(_: Serializer, _: ?usize) Error!Seq {\n        std.debug.print(\"[\", .{});\n        return Seq{};\n    }\n\n    const Seq = struct {\n        first: bool = true,\n\n        pub usingnamespace getty.ser.Seq(\n            *Seq,\n            Ok,\n            Error,\n            .{\n                .serializeElement = serializeElement,\n                .end = end,\n            },\n        );\n\n        fn serializeElement(self: *Seq, value: anytype) Error!void {\n            switch (self.first) {\n                true =&gt; self.first = false,\n                false =&gt; std.debug.print(\", \", .{}),\n            }\n\n            try getty.serialize(value, (Serializer{}).serializer());\n        }\n\n        fn end(_: *Seq) Error!Ok {\n            std.debug.print(\"]\\n\", .{});\n        }\n    };\n};\n\npub fn main() anyerror!void {\n    const s = (Serializer{}).serializer();\n\n    // Primitives\n    try getty.serialize(.{ true, false }, s);\n    try getty.serialize([_]bool{ true, false }, s);\n    try getty.serialize(&amp;&amp;&amp;[_]bool{ true, false }, s);\n    try getty.serialize(@Vector(2, bool){ true, false }, s);\n\n    // std.ArrayList\n    var list = std.ArrayList(bool).init(allocator);\n    defer list.deinit();\n    try list.appendSlice(&amp;.{ true, false });\n    try getty.serialize(list, s);\n\n    // std.BoundedArray\n    var arr = try std.BoundedArray(bool, 2).fromSlice(&amp;.{ true, false });\n    try getty.serialize(arr, s);\n}\n</code></pre> Shell session<pre><code>$ zig build run\n[true, false]\n[true, false]\n[true, false]\n[true, false]\n[true, false]\n[true, false]\n</code></pre>","location":"#quick-start"},{"title":"Blog","text":"","location":"blog/"},{"title":"Concepts","text":"","location":"concepts/"},{"title":"Blocks and Tuples","text":"<p>Blocks are the fundamental building blocks (pun intended) of Getty's (de)serialization process.</p> <p>They define how types should be serialized or deserialized into. For example, all of the ways a <code>bool</code> value can be serialized by Getty are specified in the <code>getty.ser.blocks.Bool</code> block, and all of the ways that you can deserialize into a <code>[5]i32</code> are defined in <code>getty.de.blocks.Array</code>.</p> <p>Internally, Getty uses blocks to form its core (de)serialization behavior. However, they are also the main mechanism for customization in Getty. Both users and (de)serializers can take advantage of blocks in order to customize the way Getty (de)serializes values, as we'll see later on.</p>","location":"concepts/blocks-and-tuples/"},{"title":"Blocks","text":"<p>A block is nothing more than a <code>struct</code> namespace that specifies two things:</p> <ol> <li>The type(s) that should be (de)serialized by the block.</li> <li>How to serialize or deserialize into values of those types.</li> </ol> <p>There are a few different kinds of blocks you can make in Getty, so let's go over them now.</p>","location":"concepts/blocks-and-tuples/#blocks"},{"title":"Serialization Blocks","text":"<p>To manually define the serialization process for a type, you can use a serialization block.</p> Zig code<pre><code>const sb = struct {\n    // (1)\n    pub fn is(comptime T: type) bool {\n        return T == bool;\n    }\n\n    // (2)\n    pub fn serialize(value: anytype, serializer: anytype) @TypeOf(serializer).Error!@TypeOf(serializer).Ok {\n        // Convert bool value to a Getty Integer.\n        const v: i32 = if (value) 1 else 0;\n\n        // Pass the Getty Integer value to the serializer.\n        return try serializer.serializeInt(v);\n    }\n};\n</code></pre> <ol> <li> <p><code>is</code> specifies which types can be serialized by the <code>sb</code> block.           In this case, the <code>sb</code> block applies only to <code>bool</code> values.</p> </li> <li> <p><code>serialize</code> specifies how to serialize values relevant to the <code>sb</code> block into Getty's data model.           In this case, we're telling Getty to serialize <code>bool</code> values as Integers.</p> </li> </ol>","location":"concepts/blocks-and-tuples/#serialization-blocks"},{"title":"Deserialization Blocks","text":"<p>To manually define the deserialization process for a type, you can use a deserialization block.</p> Zig code<pre><code>const db = struct {\n    // (1)\n    pub fn is(comptime T: type) bool {\n        return T == bool;\n    }\n\n    // (2)\n    pub fn deserialize(\n        allocator: ?std.mem.Allocator,\n        comptime _: type, // (3)\n        deserializer: anytype,\n        visitor: anytype,\n    ) @TypeOf(deserializer).Error!@TypeOf(visitor).Value {\n        return try deserializer.deserializeInt(allocator, visitor);\n    }\n\n    // (4)\n    pub fn Visitor(comptime Value: type) type {\n        return struct {\n            pub usingnamespace getty.de.Visitor(\n                @This(),\n                Value,\n                .{ .visitInt = visitInt },\n            );\n\n            pub fn visitInt(\n                _: @This(),\n                allocator: ?std.mem.Allocator,\n                comptime Deserializer: type,\n                input: anytype,\n            ) Deserializer.Error!Value {\n                return input != 0;\n            }\n        };\n    }\n};\n</code></pre> <ol> <li> <p><code>is</code> specifies which types can be deserialized into by the <code>db</code> block.           In this case, the <code>db</code> block applies only to <code>bool</code> values.</p> </li> <li> <p><code>deserialize</code> specifies the hint that Getty should provide a deserializer     about the type being deserialized into.           In this case, we call <code>deserializeInt</code>, which means that Getty will tell     the deserializer that the Zig type being deserialized into can probably be     made from a Getty Integer.</p> </li> <li> <p>This parameter (often named <code>T</code>) is the current type being deserialized into.           Usually, you don't need it unless you're doing pointer deserialization.</p> </li> <li> <p><code>Visitor</code> is a generic type that implements <code>getty.de.Visitor</code>.           Visitors are responsible for specifying how to deserialize values from     Getty's data model into Zig. In this case, our visitor can deserialize     Integers into <code>bool</code> values, which it does by simply returning     whether or not the integer is 0.</p> </li> </ol>","location":"concepts/blocks-and-tuples/#deserialization-blocks"},{"title":"Attribute Blocks","text":"<p>SBs and DBs are typically used for complex modifications to Getty's (de)serialization processes. For simpler customizations, you can usually get away with the more convenient attribute blocks.</p>  <p>Compatibility</p> <p>Attribute blocks may only be defined by <code>struct</code>, <code>enum</code>, and <code>union</code> types.</p>  <p>With ABs, Getty's default (de)serialization processes are used. For example, <code>struct</code> values would be serialized using the default <code>getty.ser.blocks.Struct</code> block and deserialized with the default <code>getty.de.blocks.Struct</code> block. However, based on the attributes that you specify, slight changes to these default processes will take effect.</p>  <p>Support</p> <p>For a complete list of the attributes supported by Getty, see here.</p>  <p>Regardless of whether you're serializing or deserializing, ABs are always defined like so:</p> Zig code<pre><code>const Point = struct {\n    x: i32,\n    y: i32 = 123,\n};\n\nconst ab = struct {\n    pub fn is(comptime T: type) bool {\n        return T == Point;\n    }\n\n    // (1)\n    pub const attributes = .{ // (2)\n        .x = .{ .rename = \"X\" }, // (3)\n        .y = .{ .skip = true },\n    };\n};\n</code></pre> <ol> <li> <p><code>attributes</code> specifies various (de)serialization properties for values    relevant to the <code>ab</code> block.         If <code>ab</code> is used for serialization, then <code>attributes</code> specifies that the <code>x</code>    field of <code>Point</code> should be serialized as <code>\"X\"</code>, and that the <code>y</code> field of    <code>Point</code> should be skipped.         If <code>ab</code> is used for deserialization, then <code>attributes</code> specifies that the    value for the <code>x</code> field of <code>Point</code> has been serialized as <code>\"X\"</code>, and that    the <code>y</code> field of <code>Point</code> should not be deserialized.     </p> </li> <li> <p><code>attributes</code> is an anonymous struct literal.           Each field name in <code>attributes</code> must match either a field or variant in     your <code>struct</code>, <code>enum</code>, or <code>union</code>, or the word     <code>Container</code>. The former are known as field/variant attributes, while     the latter are known as container attributes.</p> </li> <li> <p>Each field in <code>attributes</code> is also an anonymous struct literal. The    fields in these inner <code>struct</code> values depend on the kind of attribute    you're specifying (i.e., field/variant or container).</p> </li> </ol>","location":"concepts/blocks-and-tuples/#attribute-blocks"},{"title":"Usage","text":"<p>Once you've defined a block, you can pass them along to Getty via the <code>getty.Serializer</code> and <code>getty.Deserializer</code> interfaces. They take optional (de)serialization blocks as arguments.</p> <p>For example, the following defines a serializer that can serialize Booleans and Integers into JSON. It's generic over an SB, which it passes to Getty, allowing us to easily customize Getty's behavior.</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\nfn Serializer(comptime user_sb: ?type) type {\n    return struct {\n        pub usingnamespace getty.Serializer(\n            @This(),\n            Ok,\n            Error,\n            user_sb orelse null,\n            null,\n            null,\n            null,\n            null,\n            .{\n                .serializeBool = serializeBool,\n                .serializeInt = serializeInt,\n            },\n        );\n\n        const Ok = void;\n        const Error = error{};\n\n        fn serializeBool(_: @This(), value: bool) Error!Ok {\n            std.debug.print(\"{}\\n\", .{value});\n        }\n\n        fn serializeInt(_: @This(), value: anytype) Error!Ok {\n            std.debug.print(\"{}\\n\", .{value});\n        }\n    };\n}\n\nconst sb = struct {\n    pub fn is(comptime T: type) bool {\n        return T == bool;\n    }\n\n    pub fn serialize(value: anytype, serializer: anytype) !@TypeOf(serializer).Ok {\n        const v: i32 = if (value) 1 else 0;\n        return try serializer.serializeInt(v);\n    }\n};\n\npub fn main() anyerror!void {\n    // Normal\n    {\n        var s = Serializer(null){};\n        const serializer = s.serializer();\n\n        try getty.serialize(true, serializer);\n        try getty.serialize(false, serializer);\n    }\n\n    // Custom\n    {\n        var s = Serializer(sb){};\n        const serializer = s.serializer();\n\n        try getty.serialize(true, serializer);\n        try getty.serialize(false, serializer);\n    }\n}\n</code></pre> Shell session<pre><code>$ zig build run\ntrue\nfalse\n1\n0\n</code></pre>","location":"concepts/blocks-and-tuples/#usage"},{"title":"Tuples","text":"<p>In order to pass multiple (de)serialization blocks to Getty, you can use (de)serialization tuples.</p> <p>A (de)serialization tuple is, well, a tuple of (de)serialization blocks. They can be used wherever a (de)serialization block can be used and allow you to do some pretty cool things. For example, suppose you had the following type:</p> Zig code<pre><code>const Point = struct {\n    x: i32,\n    y: i32,\n};\n</code></pre> <p>If all you wanted to do was serialize <code>Point</code> values as Sequences, you'd just write an SB and pass it along to Getty. However, what if you also wanted to serialize <code>i32</code> values as Booleans? One option is to stuff all of your custom serialization logic into a single block. But that gets messy really quick and inevitably becomes a pain to maintain.</p> <p>A much better solution is to break up your serialization logic into separate blocks. One for <code>Point</code> values and one for <code>i32</code> values. Then, you just group them together as a serialization tuple!</p> Zig code<pre><code>const point_sb = struct { ... };\nconst i32_sb = struct { ... };\n\nconst point_st = .{ point_sb, i32_sb };\n</code></pre>","location":"concepts/blocks-and-tuples/#tuples"},{"title":"Data Models","text":"<p>A data model represents a set of types supported by Getty. The types within a data model are purely conceptual; they aren't actually Zig types. For example, there is no <code>i32</code> or <code>u64</code> in either of Getty's data models. Instead, they are both considered to the same type: Integer.</p> <p>Getty maintains two data models: one for serialization and another for deserialization.</p>  SerializationDeserialization    Boolean  <p>Represented by a <code>bool</code> value.</p>  Enum  <p>Represented by any <code>enum</code> value.</p>  Float  <p>Represented by any floating-point value (<code>comptime_float</code>, <code>f16</code>, <code>f32</code>, <code>f64</code>, <code>f80</code>, <code>f128</code>).</p>  Integer  <p>Represented by any integer value (<code>comptime_int</code>, <code>u0</code> \u2013 <code>u65535</code>, <code>i0</code> \u2013 <code>i65535</code>).</p>  Map  <p>Represented by a <code>getty.ser.Map</code> interface value.</p>  Null  <p>Represented by a <code>null</code> value.</p>  Seq  <p>Represented by a <code>getty.ser.Seq</code> interface value.</p>  Some  <p>Represented by the payload of an optional value.</p>  String  <p>Represented by any string value as determined by <code>std.meta.trait.isZigString</code>.</p>  Structure  <p>Represented by a <code>getty.ser.Structure</code> interface value.</p>  Void  <p>Represented by a <code>void</code> value.</p>      Boolean  <p>Represented by a <code>bool</code> value.</p>  Enum  <p>Represented by any <code>enum</code> value.</p>  Float  <p>Represented by any floating-point value (<code>comptime_float</code>, <code>f16</code>, <code>f32</code>, <code>f64</code>, <code>f80</code>, <code>f128</code>).</p>  Integer  <p>Represented by any integer value (<code>comptime_int</code>, <code>u0</code> \u2013 <code>u65535</code>, <code>i0</code> \u2013 <code>i65535</code>).</p>  Map  <p>Represented by a <code>getty.de.MapAccess</code> interface value.</p>  Null  <p>Represented by a <code>null</code> value.</p>  Seq  <p>Represented by a <code>getty.de.SeqAccess</code> interface value.</p>  Some  <p>Represented by the payload of an optional value.</p>  String  <p>Represented by any string value as determined by <code>std.meta.trait.isZigString</code>.</p>  Union  <p>Represented by a <code>getty.de.UnionAccess</code> interface value and a <code>getty.de.VariantAccess</code> interface value.</p>  Void  <p>Represented by a <code>void</code> value.</p>","location":"concepts/data-models/"},{"title":"Motivation","text":"<p>Getty's data models establish a generic baseline from which (de)serializers can operate.</p>  <p> </p>   Interactions <p>Notice how the (de)serializers never interact directly with Zig.</p> <ul> <li>Serializers receive values from Getty's data model and serialize them into a data format.</li> <li>Deserializers receive values from a data format and deserialize them into Getty's data model.</li> </ul>  <p>The data models simplify the job of a (de)serializer significantly. For example, suppose you wanted to serialize <code>[]i32</code>, <code>[100]i32</code>, <code>std.ArrayList(i32)</code>, and <code>std.TailQueue(i32)</code> values. Since Zig considers all of these types to be different, you'd have to write unique serialization logic for all of them (and integers)!</p> <p>In Getty, you don't have to do so much work. Getty considers all of the aforementioned types to be the same: they are all Sequences. This means that you only have to specify the serialization process for two types: Integers and Sequences. And by doing so, you'll automatically be able to serialize values of any of the aforementioned types, plus any other value whose type is supported by Getty and is considered a Sequence, such as <code>std.BoundedArray</code> and <code>std.SinglyLinkedList</code>.</p>","location":"concepts/data-models/#motivation"},{"title":"Interfaces","text":"<p>When building a (de)serializer in Getty, you will eventually have to implement an interface.</p> <p>Unfortunately, interfaces in Zig are a userspace thing so everyone has their own way of doing things. So, let's quickly go over how Getty implements interfaces and how you can use them.</p>","location":"concepts/interfaces/"},{"title":"Definition","text":"<p>A Getty interface is a function, and its constraints are specified as a parameter list. For instance, the following interface requires 3 associated types and 1 method from its implementations.</p> Zig code<pre><code>// (1)\nfn BoolSerializer(\n    // (2)\n    comptime Context: type,\n    comptime O: type,\n    comptime E: type,\n\n    // (3)\n    comptime methods: struct {\n        serializeBool: ?fn (Context, bool) E!O = null,\n    },\n) type\n</code></pre> <ol> <li> <p>This function is an interface similar to the ones defined in Getty.</p> </li> <li> <p>These parameters are associated types that implementations of <code>BoolSerializer</code> must provide.</p> </li> <li> <p>This parameter contains the methods that implementations of <code>BoolSerializer</code> must or can provide.</p> </li> </ol> <p>The return value of a Getty interface is a <code>struct</code> namespace that contains two declarations: an interface type and an interface function. A value of the interface type is an interface value.</p> Zig code<pre><code>fn BoolSerializer(\n    comptime Context: type,\n    comptime O: type,\n    comptime E: type,\n    comptime methods: struct {\n        serializeBool: ?fn (Context, bool) E!O = null,\n    },\n) type {\n    return struct {\n        // (2)\n        pub const Interface = struct {\n            context: Context,\n\n            pub const Ok = O;\n            pub const Error = E;\n\n            pub fn serializeBool(self: @This(), value: bool) Error!Ok {\n                if (methods.serializeBool) |f| {\n                    return try f(self.context, value);\n                }\n\n                @compileError(\"serializeBool is unimplemented\");\n            }\n        };\n\n        // (1)\n        pub fn boolSerializer(self: Context) Interface {\n            return .{ .context = self };\n        }\n    };\n}\n</code></pre> <ol> <li> <p>This function is an interface function. Its job is to return an interface value.</p> </li> <li> <p>This declaration is an interface type. They generally have:</p> <ul> <li>A single field to store an instance of an implementation.</li> <li>A few declarations that may be useful to implementations.</li> <li>Wrapper methods that define the interface's behavior.</li> </ul> </li> </ol>","location":"concepts/interfaces/#definition"},{"title":"Implementation","text":"<p>To implement a Getty interface, call the interface and apply <code>usingnamespace</code> to its return value. This will import an interface type and interface function into your implementation.</p> Zig code<pre><code>const std = @import(\"std\");\n\nconst UselessSerializer = struct {\n    usingnamespace BoolSerializer(\n        @This(),\n        void,\n        error{},\n        .{},\n    );\n};\n\nconst OppositeSerializer = struct {\n    usingnamespace BoolSerializer(\n        Context,\n        Ok,\n        Error,\n        .{ .serializeBool = serializeBool },\n    );\n\n    const Context = @This();\n    const Ok = void;\n    const Error = error{};\n\n    fn serializeBool(_: Context, value: bool) Error!Ok {\n        std.debug.print(\"{}\\n\", .{!value});\n    }\n};\n</code></pre>","location":"concepts/interfaces/#implementation"},{"title":"Usage","text":"<p>To use a value of, say <code>OppositeSerializer</code>, as an implementation of <code>BoolSerializer</code>:</p> Zig code<pre><code>pub fn main() anyerror!void {\n    const os = OppositeSerializer{}; // (1)\n    const bs = os.boolSerializer();  // (2)\n\n    // (3)\n    try bs.serializeBool(true);\n    try bs.serializeBool(false);\n}\n</code></pre> <ol> <li>Create a value of the implementing type, <code>OppositeSerializer</code>.</li> <li>Create an interface value from your implementation using the interface function.</li> <li>Use the interface value for all of your interface-y needs!</li> </ol> Shell session<pre><code>$ zig build run\nfalse\ntrue\n</code></pre>","location":"concepts/interfaces/#usage"},{"title":"Values","text":"","location":"concepts/values/"},{"title":"Serialization","text":"<p>How a Zig value is represented within a data format is determined entirely by whichever Getty serializer you use. Therefore, it's important that you check how a serialization library is handling things before you start using it. As an example, here's how the Getty JSON library does things:</p> Shell session<pre><code>const a = {};                        // serialized as null\nconst b = \"foobar\";                  // serialized as \"foobar\"\nconst c = .foobar;                   // serialized as \"foobar\"\nconst d = .{ 1, 2, 3 };              // serialized as [1,2,3]\nconst e = .{ .x = 1, .y = 2 };       // serialized as {\"x\":1,\"y\":2}\nconst F = union(enum) { foo: i32 };\nconst f = U{ .foo = 1 };             // serialized as {\"foo\":1}\n</code></pre>","location":"concepts/values/#serialization"},{"title":"Deserialization","text":"<p>Similarly, it is up to a Getty deserializer to determine how values within a data format should be parsed and deserialized into Getty's data model. For instance, the Getty JSON library has no issues converting the JSON object <code>{\"foo\":1}</code> into a tagged union. However, other deserializers may expect something different from their input data when deserializing into a union value.</p>","location":"concepts/values/#deserialization"},{"title":"Contributing","text":"<p>Contributions to Getty are very welcome! \ud83d\ude04</p> <p>This document contains some information and a few guidelines to help get you started. If you have questions about contributing or Getty, feel free to reach out on the Getty Discord.</p>","location":"contributing/"},{"title":"Zig","text":"<ul> <li>Getty currently tracks the <code>master</code> release of Zig, so make sure your version is updated.</li> </ul>","location":"contributing/#zig"},{"title":"Issues","text":"<ul> <li> <p>GitHub Issues are used exclusively for tracking bugs and feature requests for Getty.</p> </li> <li> <p>When filing an issue, please provide a brief explanation on how to reproduce your issue.</p> </li> <li> <p>When filing a feature request, please check if the latest version of Getty already implements the feature beforehand and whether there's already an issue filed for your feature.</p> </li> </ul>","location":"contributing/#issues"},{"title":"Pull Requests","text":"<ul> <li> <p>Please follow our Style Guide whenever contributing code.</p> </li> <li> <p>Before submitting a PR, please test your changes and ensure that the test suite passes locally.</p> </li> <li> <p>When submitting a PR, please have it be relative to a recent Git tip.</p> </li> <li> <p>If you push a new version of a PR, please add a comment about the new   version. Notifications aren't sent for commits, so it's easy to miss updates   without an explicit comment.</p> </li> </ul>","location":"contributing/#pull-requests"},{"title":"Workflow","text":"<p>Getty uses the Git Flow model for its development. Essentially, what that means is:</p> <ul> <li> <p>The <code>main</code> branch is strictly for releases. Do not work on or branch off of it.</p> </li> <li> <p>The <code>develop</code> branch is an integration branch for features and fixes. Do not work on it.</p> </li> <li> <p>Features are developed on <code>feature/&lt;name&gt;</code> branches, which branch off of <code>develop</code>.</p> </li> <li> <p>Fixes are developed on <code>fix/&lt;name&gt;</code> branches, which branch off of <code>develop</code>.</p> </li> </ul>","location":"contributing/#workflow"},{"title":"Style Guide","text":"<p>This document describes the coding style that all new code for Getty should try to conform to.</p>","location":"contributing/style-guide/"},{"title":"Formatting","text":"<ul> <li> <p>All code should be formatted by <code>zig fmt</code>. If your code isn't properly formatted, the CI will fail.</p> </li> <li> <p>When writing a comment, use <code>///</code> for public API descriptions and <code>//</code> for everything else.</p> </li> <li> <p>Try to limit lines to 100 characters. It's okay to go over though, so long as things are readable.</p> </li> </ul>","location":"contributing/style-guide/#formatting"},{"title":"Naming","text":"<ul> <li>Follow the naming conventions listed here.</li> </ul>","location":"contributing/style-guide/#naming"},{"title":"Getting Started","text":"<p>Getty is a framework that helps you build (de)serializers in Zig.</p> <p>If you've ever written a Zig (de)serializer before, you probably wrote a function that took a value, switched on its type, and (de)serialized based on the resulting type information. You might have even called it <code>std.json</code> too as that's exactly how the module works. Unfortunately, this approach is quite brittle, inflexible, and usually ends up being a lot of unnecessary work.</p> <p>The goal of Getty is to help you avoid all of that and reduce the amount of code you need to write a (de)serializer that is customizable, performant, and able to support a wide variety of data types!</p>","location":"getting-started/"},{"title":"Architecture","text":"<p>At a high-level, Getty consists of two flows: one for serialization and another for deserialization.</p>  SerializationDeserialization   <ol> <li>A Zig value is passed to Getty.</li> <li>Based on the value's type, a serialization block is selected and executed by Getty.</li> <li>The block serializes the passed-in value into Getty's data model.</li> <li>The resulting Getty value is passed to a Serializer, which serializes it into an output data format.</li> </ol>   <ol> <li>A Zig type is passed to Getty.</li> <li>Based on the type, a deserialization block is selected and executed by Getty.</li> <li>The block prompts a Deserializer to deserialize its input data into Getty's data model.</li> <li>The resulting Getty value is passed to a Visitor, which converts it into a Zig value of the initial type.</li> </ol>      <p> </p>","location":"getting-started/#architecture"},{"title":"Guide","text":"","location":"getting-started/guide/"},{"title":"Installation","text":"<p>To install Getty for your project, you can use any of the methods listed on this page.</p>  Verification <p>Once you've installed Getty, you can check that everything is working by running the following program.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\npub fn main() !void {\n    std.debug.print(\"{}\\n\", .{getty});\n}\n</code></pre> Shell session<pre><code>$ zig build run\ngetty\n</code></pre>","location":"getting-started/installation/"},{"title":"Manual","text":"<p>Prerequisites</p> <p>These steps require that you have the <code>master</code> version of Zig installed.</p>  <ol> <li> <p>Add Getty to your project.</p> Shell session<pre><code>git clone https://github.com/getty-zig/getty lib/getty\n</code></pre> </li> <li> <p>Make the following change in <code>build.zig</code>.</p> <code>build.zig</code><pre><code>const std = @import(\"std\");\n\npub fn build(b: *std.build.Builder) void {\n    // ...\n\n    const exe = b.addExecutable(\"getty-learn\", \"src/main.zig\");\n    exe.setTarget(target);\n    exe.setBuildMode(mode);\n    exe.addPackagePath(\"getty\", \"lib/getty/src/getty.zig\");\n    exe.install();\n}\n</code></pre> </li> </ol>","location":"getting-started/installation/#manual"},{"title":"Gyro","text":"<p>Prerequisites</p> <p>These steps require that you have the <code>master</code> version of Zig and the Gyro package manager installed.</p>  <ol> <li> <p>Add Getty to your project.</p> Shell session<pre><code>gyro add -s github getty-zig/getty\ngyro fetch\n</code></pre> </li> <li> <p>Make the following changes to <code>build.zig</code>.</p> <code>build.zig</code><pre><code>const std = @import(\"std\");\nconst pkgs = @import(\"deps.zig\").pkgs;\n\npub fn build(b: *std.build.Builder) void {\n    // ...\n\n    const exe = b.addExecutable(\"getty-learn\", \"src/main.zig\");\n    exe.setTarget(target);\n    exe.setBuildMode(mode);\n    pkgs.addAllTo(exe);\n    exe.install();\n}\n</code></pre> </li> </ol>","location":"getting-started/installation/#gyro"},{"title":"Zigmod","text":"<p>Prerequisites</p> <p>These steps require that you have the <code>master</code> version of Zig and the Zigmod package manager installed.</p>  <ol> <li> <p>Make the following changes to <code>zigmod.yml</code>.</p> <code>zigmod.yml</code><pre><code># ...\n\nroot_dependencies:\n  - src: git https://gitub.com/getty-zig/getty\n</code></pre> </li> <li> <p>Add Getty to your project.</p> Shell session<pre><code>zigmod fetch\n</code></pre> </li> <li> <p>Make the following changes in <code>build.zig</code>.</p> <code>build.zig</code><pre><code>const std = @import(\"std\");\nconst deps = @import(\"deps.zig\");\n\npub fn build(b: *std.build.Builder) void {\n    // ...\n\n    const exe = b.addExecutable(\"getty-learn\", \"src/main.zig\");\n    exe.setTarget(target);\n    exe.setBuildMode(mode);\n    deps.addAllTo(exe);\n    exe.install();\n}\n</code></pre> </li> </ol>","location":"getting-started/installation/#zigmod"}]}