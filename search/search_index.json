{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Getty","text":"<p>Getty is a framework for building robust, optimal, and reusable (de)serializers in Zig.</p> <p></p> <p></p>"},{"location":"#goals","title":"Goals","text":"<ul> <li>Simplify (de)serializer implementations.</li> <li>Enable granular customization of the (de)serialization process.</li> <li>Avoid as much performance overhead as possible.</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Compile-time (de)serialization.</li> <li>Out-of-the-box support for a wide variety of standard library types.</li> <li>Local customization of (de)serialization logic for existing and remote types.</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>The following code uses the Getty JSON library to demonstrate how (de)serialization works.</p> Zig code<pre><code>const std = @import(\"std\");\nconst json = @import(\"json\");\nconst allocator = std.heap.page_allocator;\nconst Point = struct {\nx: i32,\ny: i32,\n};\npub fn main() !void {\nconst value = Point{ .x = 1, .y = 2 };\n// Serialize a Point value into JSON.\nconst serialized = try json.toSlice(allocator, value);\ndefer allocator.free(serialized);\n// Deserialize JSON data into a Point.\nconst deserialized = try json.fromSlice(null, Point, serialized);\n// Print results.\nstd.debug.print(\"{s}\\n\", .{serialized});\nstd.debug.print(\"{}\\n\", .{deserialized});\n}\n</code></pre> Shell session<pre><code>$ zig build run\n{\"x\":1,\"y\":2}\nmain.Point{ .x = 1, .y = 2 }\n</code></pre>"},{"location":"blog/","title":"Blog","text":""},{"location":"blog/announcing-getty-010/","title":"Announcing Getty 0.1.0","text":"<p>I am happy to announce the initial version of Getty, 0.1.0. </p> <p>Getty is a framework for building robust, optimal, and reusable serializers/deserializers in Zig. To install Getty, follow the instructions listed on the Installation page.</p>"},{"location":"blog/announcing-getty-010/#whats-in-010","title":"What's in 0.1.0","text":""},{"location":"blog/announcing-getty-010/#core-deserialization","title":"Core (de)serialization","text":"<p>Getty wouldn't be much of a (de)serialization framework if you couldn't (de)serialize anything. So, the initial release brings with it some core (de)serialization capabilities. Specifically, support was added for the following types:</p> Serialization <ul> <li>Array</li> <li>Bool</li> <li>Enum</li> <li>Error set</li> <li>Float</li> <li>Integer</li> <li>Null</li> <li>Optional</li> <li>Pointer (one, slice)</li> <li>Struct</li> <li>Tuple</li> <li>Union</li> <li>Vector</li> <li>Void</li> <li><code>std.ArrayListAligned</code></li> <li><code>std.ArrayListAlignedUnmanaged</code></li> <li><code>std.HashMap</code></li> <li><code>std.HashMapUnmanaged</code></li> <li><code>std.SinglyLinkedList</code></li> <li><code>std.TailQueue</code></li> </ul> Deserialization <ul> <li>Array</li> <li>Bool</li> <li>Enum (non-literal)</li> <li>Float</li> <li>Integer</li> <li>Optional</li> <li>Pointer (one, slice)</li> <li>Struct</li> <li>Tuple</li> <li>Union</li> <li>Void</li> <li><code>std.ArrayListAligned</code></li> <li><code>std.ArrayListAlignedUnmanaged</code></li> <li><code>std.HashMap</code></li> <li><code>std.HashMapUnmanaged</code></li> <li><code>std.SinglyLinkedList</code></li> <li><code>std.TailQueue</code></li> </ul>"},{"location":"blog/announcing-getty-010/#customization","title":"Customization","text":"<p>In addition to the core (de)serialization functionality, this release of Getty also introduces customization blocks, which can be used to define or modify the (de)serialization process.</p>"},{"location":"blog/announcing-getty-020/","title":"Announcing Getty 0.2.0","text":"<p>I am happy to announce a new version of Getty, 0.2.0. </p> <p>Getty is a framework for building robust, optimal, and reusable serializers/deserializers in Zig. To install Getty, follow the instructions listed on the Installation page.</p>"},{"location":"blog/announcing-getty-020/#whats-in-020","title":"What's in 0.2.0","text":""},{"location":"blog/announcing-getty-020/#revamped-interfaces","title":"Revamped Interfaces","text":"<p>Thanks to stage2, there were lots of improvements made to the interfaces in Getty. Most notably:</p> <ul> <li>Required method parameters are now optional struct fields, making implementing interfaces much simpler.</li> <li>Most associated types have been made optional, so no more <code>getty.TODO</code>.</li> <li>Empty error sets are now allowed.</li> <li>No more relying on <code>undefined</code> errors to indicate that a unimplemented method was called. Getty can now have <code>@compileError</code>s in its interfaces to let you know about that.</li> </ul> Zig code<pre><code>const Serializer = struct {\npub usingnamespace Serializer(\n@This(),\nvoid,\nerror{},\nnull,\nnull,\nnull,\nnull,\nnull,\n.{ .serializeBool = serializeBool },\n);\n};\n</code></pre>"},{"location":"blog/announcing-getty-020/#simpler-customization","title":"Simpler Customization","text":"<p>On the customization side of things, two main features have been added.</p> <p>First, you can now write type-defined blocks/tuples (TBT), which are (de)serialization blocks/tuples defined within a <code>struct</code> or <code>union</code> type. Getty will automatically process TBTs, meaning that you don't have to pass them in explicitly.</p> <p>Second, preliminary support for attributes have landed. Attributes allow you to easily configure the (de)serialization process for a type without having to manually write everything out. This release introduced support only for the <code>skip</code>, <code>rename</code>, and <code>ignore_unknown_fields</code> attributes.</p> Zig code<pre><code>const std = @import(\"std\");\nconst json = @import(\"json\");\nconst allocator = std.heap.page_allocator;\nconst Point = struct {\nx: i32,\ny: i32,\npub const @\"getty.sbt\" = struct {\npub fn is(comptime T: type) bool {\nreturn T == Point;\n}\npub const attributes = .{\n.x = .{ .rename = \"X\" },\n.y = .{ .skip = true },\n};\n};\n};\npub fn main() !void {\n_ = try json.toSlice(allocator, Point{ .x = 1, .y = 2 }); // {\"X\":1}\n}\n</code></pre>"},{"location":"blog/announcing-getty-020/#union-serialization","title":"Union Serialization","text":"<p>Before, unions were serialized as their payload value. However, this made things inconsistent as there was no good way to go back during deserialization with that approach.</p> <p>To fix this, unions are now serialized using the externally tagged format by default.</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst json = @import(\"json\");\nconst allocator = std.heap.page_allocator;\npub fn main() !void {\nconst U = union(enum) { foo: i32 };\nvar slice = try json.toSlice(allocator, U{ .foo = 123 });\ndefer allocator.free(slice);\nstd.debug.print(\"{s}\\n\", .{slice}); // {\"foo\":123}\n}\n</code></pre>"},{"location":"blog/announcing-getty-020/#ignoring-deserialized-data","title":"Ignoring Deserialized Data","text":"<p>A new method has been added to the <code>getty.Deserializer</code> interface: <code>deserializeIgnored</code>. This method is intended to be used whenever the input data of a deserializer should be ignored. For example, when the <code>skip</code> attribute is set for a <code>struct</code>, <code>deserializeIgnored</code> can be called in order to ignore a key and/or value in the deserializer's input data.</p>"},{"location":"blog/announcing-getty-020/#support","title":"Support","text":"<p>Some new types are now supported by Getty!</p> Serialization <ul> <li><code>std.BoundedArray</code></li> </ul> Deserialization <ul> <li>Union (tagged)</li> <li>Union (untagged)</li> <li>Sentinel-terminated slice</li> </ul>"},{"location":"blog/announcing-getty-020/#other-changes","title":"Other Changes","text":"<p>There are other changes in the Getty 0.2.0 release. You can see the full changelog here.</p>"},{"location":"blog/announcing-getty-021/","title":"Announcing Getty 0.2.1","text":"<p>A new point release of Getty has been published, 0.2.1.</p> <p>Getty is a framework for building robust, optimal, and reusable serializers/deserializers in Zig. To install Getty, follow the instructions listed on the Installation page.</p>"},{"location":"blog/announcing-getty-021/#whats-in-021","title":"What's in 0.2.1","text":"<p>Getty 0.2.1 is a minor update that is designed to prepare the project for the Git Flow workflow. The release batches together some improvements and fixes to make the transition easier.</p> <ul> <li> <p>Serialization and deserialization support for <code>std.BufMap</code> has been added.</p> </li> <li> <p><code>examples/build.zig</code> has been fixed, so now the examples successfully compile and run.</p> </li> </ul>"},{"location":"blog/announcing-getty-021/#other-changes","title":"Other Changes","text":"<p>There are other changes in the Getty 0.2.1 release. You can see the full changelog here.</p>"},{"location":"blog/announcing-getty-022/","title":"Announcing Getty 0.2.2","text":"<p>A new point release of Getty has been published, 0.2.2.</p> <p>Getty is a framework for building robust, optimal, and reusable serializers/deserializers in Zig. To install Getty, follow the instructions listed on the Installation page.</p>"},{"location":"blog/announcing-getty-022/#whats-in-022","title":"What's in 0.2.2","text":"<p>Getty 0.2.2 addresses a few issues caused by changes in the standard library and shields.io.</p> <ul> <li>To reference a field's type, the standard library switched to <code>type</code> instead of <code>field_type</code>.</li> <li>The build badge link apparently requires a branch to be specified now.</li> </ul>"},{"location":"blog/announcing-getty-022/#other-changes","title":"Other Changes","text":"<p>There are other changes in the Getty 0.2.2 release. You can see the full changelog here.</p>"},{"location":"blog/announcing-getty-030/","title":"Announcing Getty 0.3.0","text":"<p>I am happy to announce a new version of Getty, 0.3.0. </p> <p>Getty is a framework for building robust, optimal, and reusable serializers/deserializers in Zig. To install Getty, follow the instructions listed on the Installation page.</p>"},{"location":"blog/announcing-getty-030/#whats-in-030","title":"What's in 0.3.0","text":""},{"location":"blog/announcing-getty-030/#deserialize-anything","title":"Deserialize anything","text":"<p>The <code>deserializeAny</code> method has been added to the <code>getty.Deserializer</code> interface.</p> <p><code>deserializeAny</code> enables deserializers of self-describing formats (e.g., JSON) to drive themselves based on their own input data. This can be useful if, for instance, a user wants to deserialize into a value from multiple possible data types (e.g., JSON array or JSON object).</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst json = @import(\"json\");\nconst Allocator = std.mem.Allocator;\nconst Point = struct {\nx: i32,\ny: i32,\npub const @\"getty.db\" = struct {\n// \ud83d\udc4b Here, we call deserializeAny to let the deserializer drive\n//    itself.\npub fn deserialize(a: ?Allocator, comptime _: type, d: anytype, v: anytype) !Point {\nreturn try d.deserializeAny(a, v);\n}\n// \ud83d\udc4b Here, we define a visitor that is able to produce Point values\n//    from both Maps and Sequences.\npub fn Visitor(comptime _: type) type {\nreturn struct {\npub usingnamespace getty.de.Visitor(\n@This(),\nPoint,\n.{\n.visitMap = visitMap,\n.visitSeq = visitSeq,\n},\n);\npub fn visitMap(_: @This(), a: ?Allocator, comptime _: type, map: anytype) !Point {\nvar point: Point = undefined;\nwhile (try map.nextKey(a, []const u8)) |key| {\nif (std.mem.eql(u8, \"x\", key)) {\npoint.x = try map.nextValue(a, i32);\ncontinue;\n}\nif (std.mem.eql(u8, \"y\", key)) {\npoint.y = try map.nextValue(a, i32);\ncontinue;\n}\nreturn error.UnknownField;\n}\nreturn point;\n}\npub fn visitSeq(_: @This(), a: ?Allocator, comptime _: type, seq: anytype) !Point {\nvar point: Point = undefined;\ninline for (std.meta.fields(Point)) |field| {\nif (try seq.nextElement(a, i32)) |elem| {\n@field(point, field.name) = elem;\n}\n}\nif (try seq.nextElement(a, getty.de.Ignored) != null) {\nreturn error.InvalidLength;\n}\nreturn point;\n}\n};\n}\n};\n};\npub fn main() !void {\n// \ud83d\udc4b Here, we deserialize into a Point from a JSON object.\nconst str1 = \"{\\\"x\\\":1,\\\"y\\\":2}\";\nconst point1 = try json.fromSlice(std.heap.page_allocator, Point, str1);\n// \ud83d\udc4b Here, we deserialize into a Point from a JSON array.\nconst str2 = \"[1,2]\";\nconst point2 = try json.fromSlice(null, Point, str2);\nstd.debug.print(\"{}\\n\", .{point1});\nstd.debug.print(\"{}\\n\", .{point2});\n}\n</code></pre> Shell session<pre><code>$ zig build run\nmain.Point{ .x = 1, .y = 2 }\nmain.Point{ .x = 1, .y = 2 }\n</code></pre>"},{"location":"blog/announcing-getty-030/#new-union-attributes","title":"New union attributes","text":"<p>The <code>skip</code> and <code>rename</code> attributes are now supported by unions.</p> <ul> <li> <p>Renaming a union variant will change the tag that Getty uses during (de)serialization.</p> Zig code<pre><code>const std = @import(\"std\");\nconst json = @import(\"json\");\nconst allocator = std.heap.page_allocator;\nconst Union = union(enum) {\nfoo: i32,\nbar: i32,\npub const @\"getty.sb\" = block;\npub const @\"getty.db\" = block;\nconst block = struct {\npub const attributes = .{\n.foo = .{ .rename = \"FOO\" },\n};\n};\n};\npub fn main() !void {\nconst s = try json.toSlice(allocator, Union{ .foo = 1 });\ndefer allocator.free(s);\nconst d = try json.fromSlice(null, Union, s);\nstd.debug.print(\"{s}\\n\", .{s});\nstd.debug.print(\"{}\\n\", .{d});\n}\n</code></pre> Shell session<pre><code>{\"FOO\":1}\nmain.Union{ .foo = 1 }\n</code></pre> </li> <li> <p>Attempting to (de)serialize a skipped union variant will return an <code>UnknownVariant</code>error.</p> Zig code<pre><code>const std = @import(\"std\");\nconst json = @import(\"json\");\nconst allocator = std.heap.page_allocator;\nconst Union = union(enum) {\nfoo: i32,\nbar: i32,\npub const @\"getty.sb\" = struct {\npub const attributes = .{\n.bar = .{ .skip = true },\n};\n};\n};\npub fn main() !void {\n_ = try json.toSlice(allocator, Union{ .bar = 1 });\n}\n</code></pre> Shell session<pre><code>$ zig build run\nerror: UnknownVariant\n(cut)\n</code></pre> </li> </ul>"},{"location":"blog/announcing-getty-030/#goodbye-is-function-sort-of","title":"Goodbye <code>is</code> function (sort of)","text":"<p>Type-defined blocks no longer require an <code>is</code> function to be declared.</p> <p>Type-defined blocks are only ever processed for the type that they're defined in, so it didn't really make any sense to require an <code>is</code> function in them.</p> <p>Also gone are type-defined tuples, for pretty much the same reason. If type-defined blocks are only ever processed against whatever type they're defined in, there's no reason to allow multiple blocks to be specified in a tuple since the first matching block will always get chosen.</p> Zig code<pre><code>const std = @import(\"std\");\nconst json = @import(\"json\");\nconst allocator = std.heap.page_allocator;\nconst Point = struct {\nx: i32,\ny: i32,\npub const @\"getty.sb\" = struct {\npub fn serialize(v: anytype, ser: anytype) !@TypeOf(ser).Ok {\nvar s = try ser.serializeSeq(2);\nconst seq = s.seq();\ntry seq.serializeElement(v.x);\ntry seq.serializeElement(v.y);\nreturn try seq.end();\n}\n};\n};\npub fn main() !void {\nconst point = Point{ .x = 1, .y = 2 };\nconst slice = try json.toSlice(allocator, point);\ndefer allocator.free(slice);\nstd.debug.print(\"{s}\\n\", .{slice});\n}\n</code></pre> Shell session<pre><code>[1,2]\n</code></pre>"},{"location":"blog/announcing-getty-030/#key-allocation","title":"Key allocation","text":"<p>Deserialization of Map keys has always been a pain point for Getty.</p> <p>Specifically, it was difficult for a visitor to tell whether or not a deserialized key was allocated, and therefore whether or not it should/could be deallocated. Which is important, since knowing the difference would allow us to avoid memory leaks, enable compile-time deserialization of <code>struct</code> values, and unlock performance gains for certain map-like data structures.</p> <p>Originally, the convention was to simply assume that all deserialized (pointer) map keys are allocated, except in the case of <code>struct</code>s. However, that turned out to be super inconsistent, confusing for newcomers, and it didn't even really work in the general case.</p> <p>Getty 0.3.0 fixes this problem by adding a new method to the <code>getty.de.MapAccess</code> interface, <code>isKeyAllocated</code>. Visitors can simply query this method to determine whether or not a key is allocated. By default, the method returns <code>true</code> if the key type being deserialized into is a pointer. But of course, implementations are free to override this method however they like!</p> <p>Below is a snippet from Getty JSON's <code>getty.de.MapAccess</code> implementation for <code>struct</code> values. Here, <code>isKeyAllocated</code> returns <code>true</code> only for strings that contain escaped characters.</p> Zig code<pre><code>fn StructAccess(comptime D: type) type {\nreturn struct {\nd: *D,\nis_key_allocated: bool = false, // \ud83d\udc4b By default, keys are not\n//    allocated.\nconst Self = @This();\nfn isKeyAllocated(self: *Self, comptime _: type) bool {\nreturn self.is_key_allocated;\n}\nfn nextKeySeed(self: *Self, a: ?Allocator, seed: anytype) Error!?@TypeOf(seed).Value {\n// \ud83d\udc4b Parse token from input data.\nif (try self.d.tokens.next()) |token| {\nswitch (token) {\n.String =&gt; |t| {\n// \ud83d\udc4b Get string from token.\nconst slice = t.slice(self.d.tokens.slice, self.d.tokens.i - 1);\n// \ud83d\udc4b If the string has escaped characters, set\n//    is_key_allocated to true since unescaping\n//    a string requires allocation.\nself.is_key_allocated = t.escapes == .Some;\n// \ud83d\udc4b Give the visitor the correct string.\nreturn switch (t.escapes) {\n.None =&gt; slice,\n.Some =&gt; try unescapeString(a.?, token.String, slice),\n};\n},\n.ObjectEnd =&gt; return null,\nelse =&gt; {},\n}\n}\nreturn error.InvalidType;\n}\n// (cut)\n};\n}\n// (cut)\n</code></pre>"},{"location":"blog/announcing-getty-030/#ignoring-values","title":"Ignoring values","text":"<p>Getty's default deserialization tuple now contains a block for <code>getty.de.Ignored</code>.</p> <p>By deserializing into this type, visitors can easily skip and ignore deserialized values, which is useful when deserializing aggregate types. For example, you often have to do a final call to <code>nextElement</code> or <code>nextKey</code> to make sure that there are no more remaining elements/entries; <code>getty.de.Ignored</code> is the perfect type to pass in for that final call.</p>"},{"location":"blog/announcing-getty-030/#mandatory-errors","title":"Mandatory errors","text":"<p>To ensure compatibility with Getty's default blocks and to enable visitors to return <code>error.Unsupported</code> (which is needed for <code>deserializeAny</code>), the error sets of serializers and deserializers must now contain <code>getty.ser.Error</code> and <code>getty.de.Error</code>, respectively.</p> <p>Getty will check for these error sets at compile-time and let you know if you forgot them.</p>"},{"location":"blog/announcing-getty-030/#support","title":"Support","text":"<p>Some new types are now supported by Getty!</p> Serialization <ul> <li><code>std.ArrayHashMap</code></li> <li><code>std.ArrayHashMapUnmanaged</code></li> <li><code>std.PackedIntArray</code></li> <li><code>std.PackedIntSlice</code></li> <li><code>std.net.Address</code></li> </ul> Deserialization <ul> <li>Non-string, sentinel-terminated slices</li> <li><code>std.ArrayHashMap</code></li> <li><code>std.ArrayHashMapUnmanaged</code></li> <li><code>std.BoundedArray</code></li> <li><code>std.PackedIntArray</code></li> <li><code>std.PackedIntSlice</code></li> <li><code>std.net.Address</code></li> </ul>"},{"location":"blog/announcing-getty-030/#other-changes","title":"Other Changes","text":"<p>There are other changes in the Getty 0.3.0 release. You can see the full changelog here.</p>"},{"location":"blog/announcing-getty-040/","title":"Announcing Getty 0.4.0","text":"<p>I am happy to announce a new version of Getty, 0.4.0. </p> <p>Getty is a framework for building robust, optimal, and reusable serializers/deserializers in Zig. To install Getty, follow the instructions listed on the Installation page.</p>"},{"location":"blog/announcing-getty-040/#whats-in-040","title":"What's in 0.4.0","text":"<p>Despite 0.3.0 coming out less than a month ago, we already have a new major version! Apparently, living at the <code>HEAD</code> of Zig is quite an unstable life. Who would've thunk!</p> <p>This release contains bug fixes, adds support for a handful of new types, and introduces a few breaking changes to the API and build process (the Zig package manager is alive!).</p>"},{"location":"blog/announcing-getty-040/#allocators-for-sbs","title":"Allocators for SBs","text":"<p>The <code>getty.serialize</code> function and the <code>serialize</code> function in SBs now take an optional allocator as a parameter.</p> <p>This change allows SBs to allocate memory on the heap should they need to before they hand off serialization to a serializer. One example of where this change can be useful is the SB for <code>std.SemanticVersion</code>, which dynamically allocates space whenever formatting a version number since they can be arbitrarily long.</p>"},{"location":"blog/announcing-getty-040/#packaging-getty","title":"Packaging Getty","text":"<p>Zig's new package manager is now capable of adding Getty to your projects!</p> <p>The Installation page has been updated to reflect this and walks you through the new steps. The old, manual way of installing Getty will not work anymore, so be sure to update your <code>build.zig</code> (and <code>build.zig.zon</code>) accordingly! </p> <p>Support for Gyro and Zigmod has been removed. All hail the Zig package manager!</p>"},{"location":"blog/announcing-getty-040/#fixes","title":"Fixes","text":"<ul> <li>The <code>rename</code> attribute has been fixed so that it no longer acts as an alias. (a52ec21)</li> <li>DBs now return <code>error.MissingAllocator</code> when allocation is required but no allocator is present. Before, they would simply panic after attempting to unwrap a <code>null</code> allocator. (644cfc5)</li> <li>The <code>blocks</code> namespaces no longer group similar types together under a single declaration. That is, <code>blocks.ArrayList</code> and <code>blocks.ArrayListAligned</code> are now separate declaration. (5e366ca)</li> <li>The test deserializer now properly checks the length of sequence tokens. (0ca32de)</li> <li>Serialization examples now use the <code>getty.ser.Error</code> error set. (bba74b7)</li> <li><code>README</code> links and badges have been fixed. (94231c2)</li> </ul>"},{"location":"blog/announcing-getty-040/#support","title":"Support","text":"<p>Some new types are now supported by Getty!</p> Serialization <ul> <li><code>std.MultiArrayList</code></li> <li><code>std.SemanticVersion</code></li> <li><code>std.IntegerBitSet</code></li> </ul> Deserialization <ul> <li><code>std.MultiArrayList</code></li> <li><code>std.SemanticVersion</code></li> <li><code>std.IntegerBitSet</code></li> </ul>"},{"location":"blog/announcing-getty-040/#other-changes","title":"Other Changes","text":"<p>There are other changes in the Getty 0.4.0 release. You can see the full changelog here.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions to Getty are very welcome!</p> <p>This page provides some information and a few guidelines to help get you started on your contributing journey. If you have any questions, feel free to reach out on the Getty Discord.</p>"},{"location":"contributing/#zig","title":"Zig","text":"<ul> <li>Getty currently tracks the <code>master</code> release of Zig, so make sure your version is updated.</li> </ul>"},{"location":"contributing/#issues","title":"Issues","text":"<ul> <li> <p>GitHub Issues are used exclusively for tracking bugs and feature requests for Getty.</p> </li> <li> <p>When filing an issue, please provide a brief explanation on how to reproduce your issue.</p> </li> <li> <p>When filing a feature request, please check if the latest version of Getty already implements the feature beforehand and whether there's already an issue filed for your feature.</p> </li> </ul>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<ul> <li> <p>Before submitting a PR, please test your changes and ensure that the test suite passes locally.</p> </li> <li> <p>When submitting a PR, please have it be relative to a recent Git tip.</p> </li> <li> <p>If you push a new version of a PR, please add a comment about the new version. Notifications aren't sent for commits, so it's easy to miss updates without an explicit comment.</p> </li> </ul>"},{"location":"user-guide/","title":"User Guide","text":"<p>This is the official guide for the Getty framework, and is designed to serve as both:</p> <ul> <li>An introduction to writing serializers and deserializers with Getty.</li> <li>A reference for more experienced Getty developers.</li> </ul>"},{"location":"user-guide/installation/","title":"Installation","text":"<p>To install Getty:</p> <ol> <li> <p>Declare Getty as a dependency by writing the following in <code>build.zig.zon</code>:</p> <p>Warning</p> <p>Be sure to replace <code>&lt;COMMIT&gt;</code> in the URL with a commit from Getty.</p> <p><code>build.zig.zon</code><pre><code>.{\n.name = \"my-project\",\n.version = \"0.0.0\",\n.dependencies = .{\n.getty = .{\n.url = \"https://github.com/getty-zig/getty/archive/&lt;COMMIT&gt;.tar.gz\",\n},\n},\n}\n</code></pre> </p> </li> <li> <p>Expose Getty as a module by adding the following lines to <code>build.zig</code>:</p> <p><code>build.zig</code><pre><code>const std = @import(\"std\");\npub fn build(b: *std.Build) void {\nconst target = b.standardTargetOptions(.{});\nconst optimize = b.standardOptimizeOption(.{});\nconst opts = .{ .target = target, .optimize = optimize };\nconst getty_mod = b.dependency(\"getty\", opts).module(\"getty\");\nconst exe = b.addExecutable(.{\n.name = \"my-project\",\n.root_source_file = .{ .path = \"src/main.zig\" },\n.target = target,\n.optimize = optimize,\n});\nexe.addModule(\"getty\", getty_mod);\nexe.install();\n// (snip)\n}\n</code></pre> </p> </li> <li> <p>Obtain Getty's package hash by running <code>zig build</code>:</p> <p>Shell session<pre><code>$ zig build\nmy-project/build.zig.zon:6:20: error: url field is missing corresponding hash field\n        .url = \"https://github.com/getty-zig/getty/archive/&lt;COMMIT&gt;.tar.gz\",\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnote: expected .hash = \"&lt;HASH&gt;\",\n</code></pre> </p> </li> <li> <p>Update <code>build.zig.zon</code> with the obtained hash value:</p> <code>build.zig.zon</code><pre><code>.{\n.name = \"my-project\",\n.version = \"0.0.0\",\n.dependencies = .{\n.getty = .{\n.url = \"https://github.com/getty-zig/getty/archive/&lt;COMMIT&gt;.tar.gz\",\n.hash = \"&lt;HASH&gt;\",\n},\n},\n}\n</code></pre> </li> </ol>"},{"location":"user-guide/design/","title":"Design","text":"<p>This section contains information regarding the design of and concepts used by Getty.</p>"},{"location":"user-guide/design/architecture/","title":"Architecture","text":"<p>At a high-level, Getty consists of two flows: a serialization and a deserialization flow.</p> <p> </p> SerializationDeserialization <p>In the serialization flow:</p> <ol> <li>A Zig value is passed to Getty.</li> <li>Based on the value's type, a serialization block is selected and executed by Getty.</li> <li>The block serializes the passed-in value into Getty's data model.</li> <li>The resulting value is passed to a Serializer, which serializes it into an output data format.</li> </ol> <p>In the deserialization flow: </p> <ol> <li>A Zig type is passed to Getty.</li> <li>Based on the type, a deserialization block is selected and executed by Getty.</li> <li>The block prompts a Deserializer to deserialize its input data into Getty's data model.</li> <li>The resulting value is passed to a Visitor, which converts it into a value of the initial type.</li> </ol>"},{"location":"user-guide/design/blocks-and-tuples/","title":"Blocks and Tuples","text":"<p>Blocks are the fundamental building blocks (pun intended) of Getty's (de)serialization process.</p> <p>They define how types should be serialized or deserialized into. For example, all of the ways a <code>bool</code> value can be serialized by Getty are specified in the <code>getty.ser.blocks.Bool</code> block, and all of the ways that you can deserialize into a <code>[5]i32</code> are defined in <code>getty.de.blocks.Array</code>.</p> <p>Internally, Getty uses blocks to form its core (de)serialization behavior. However, they are also the main mechanism for customization in Getty. Users and (de)serializers can take advantage of blocks in order to customize the way Getty (de)serializes values, as we'll see later on.</p>"},{"location":"user-guide/design/blocks-and-tuples/#blocks","title":"Blocks","text":"<p>A block is nothing more than a <code>struct</code> namespace that specifies two things:</p> <ol> <li>The type(s) that should be (de)serialized by the block.</li> <li>How to serialize or deserialize into values of those types.</li> </ol> <p>There are a few different kinds of blocks you can make in Getty, so let's go over them now.</p>"},{"location":"user-guide/design/blocks-and-tuples/#serialization-blocks","title":"Serialization Blocks","text":"<p>To manually define the serialization process for a type, you can use a serialization block.</p> Zig code<pre><code>const sb = struct {\n// (1)!\npub fn is(comptime T: type) bool {\nreturn T == bool;\n}\n// (2)!\npub fn serialize(\nallocator: ?std.mem.Allocator,\nvalue: anytype,\nserializer: anytype,\n) @TypeOf(serializer).Error!@TypeOf(serializer).Ok {\n_ = allocator;\n// Convert bool value to a Getty Integer.\nconst v: i32 = if (value) 1 else 0;\n// Pass the Getty Integer value to the serializer.\nreturn try serializer.serializeInt(v);\n}\n};\n</code></pre> <ol> <li> <p><code>is</code> specifies which types can be serialized by the <code>sb</code> block.           In this case, the <code>sb</code> block applies only to <code>bool</code> values.</p> </li> <li> <p><code>serialize</code> specifies how to serialize values relevant to the <code>sb</code> block into Getty's data model.           In this case, we're telling Getty to serialize <code>bool</code> values as Integers.</p> </li> </ol>"},{"location":"user-guide/design/blocks-and-tuples/#deserialization-blocks","title":"Deserialization Blocks","text":"<p>To manually define the deserialization process for a type, you can use a deserialization block.</p> Zig code<pre><code>const db = struct {\n// (1)!\npub fn is(comptime T: type) bool {\nreturn T == bool;\n}\n// (2)!\npub fn deserialize(\nallocator: ?std.mem.Allocator,\ncomptime T: type,\ndeserializer: anytype,\nvisitor: anytype,\n) @TypeOf(deserializer).Error!@TypeOf(visitor).Value {\n_ = T; // (3)!\nreturn try deserializer.deserializeInt(allocator, visitor);\n}\n// (4)!\npub fn Visitor(comptime Value: type) type {\nreturn struct {\npub usingnamespace getty.de.Visitor(\n@This(),\nValue,\n.{ .visitInt = visitInt },\n);\npub fn visitInt(\nself: @This(),\nallocator: ?std.mem.Allocator,\ncomptime Deserializer: type,\ninput: anytype,\n) Deserializer.Error!Value {\n_ = self;\n_ = allocator;\nreturn input != 0;\n}\n};\n}\n};\n</code></pre> <ol> <li> <p><code>is</code> specifies which types can be deserialized into by the <code>db</code> block.           In this case, the <code>db</code> block applies only to <code>bool</code> values.</p> </li> <li> <p><code>deserialize</code> specifies the hint that Getty should provide a deserializer     about the type being deserialized into.           In this case, we call <code>deserializeInt</code>, which means that Getty will tell     the deserializer that the Zig type being deserialized into can probably be     made from a Getty Integer.</p> </li> <li> <p><code>T</code> is the current type being deserialized into.           Usually, you don't need it unless you're doing pointer deserialization.</p> </li> <li> <p><code>Visitor</code> is a generic type that implements <code>getty.de.Visitor</code>.           Visitors are responsible for specifying how to deserialize values from     Getty's data model into Zig. In this case, our visitor can deserialize     Integers into <code>bool</code> values, which it does by simply returning     whether or not the integer is 0.</p> </li> </ol>"},{"location":"user-guide/design/blocks-and-tuples/#attribute-blocks","title":"Attribute Blocks","text":"<p>SBs and DBs are typically used for complex modifications to Getty's (de)serialization processes. For simpler customizations, you can usually get away with the more convenient attribute blocks.</p> <p>Compatibility</p> <p>Attribute blocks may only be defined by <code>struct</code> and <code>union</code> types.</p> <p>With ABs, Getty's default (de)serialization processes are used. For example, <code>struct</code> values would be serialized using the default <code>getty.ser.blocks.Struct</code> block and deserialized with the default <code>getty.de.blocks.Struct</code> block. However, based on the attributes that you specify, slight changes to these default processes will take effect.</p> <p>Regardless of whether you're serializing or deserializing, ABs are always defined like so:</p> Zig code<pre><code>const Point = struct {\nx: i32,\ny: i32 = 123,\n};\nconst ab = struct {\npub fn is(comptime T: type) bool {\nreturn T == Point;\n}\n// (1)!\npub const attributes = .{ // (2)!\n.x = .{ .rename = \"X\" }, // (3)!\n.y = .{ .skip = true },\n};\n};\n</code></pre> <ol> <li> <p><code>attributes</code> specifies various (de)serialization properties for values    relevant to the <code>ab</code> block.         If <code>ab</code> is used for serialization, then <code>attributes</code> specifies that the <code>x</code>    field of <code>Point</code> should be serialized as <code>\"X\"</code>, and that the <code>y</code> field of    <code>Point</code> should be skipped.         If <code>ab</code> is used for deserialization, then <code>attributes</code> specifies that the    value for the <code>x</code> field of <code>Point</code> has been serialized as <code>\"X\"</code>, and that    the <code>y</code> field of <code>Point</code> should not be deserialized.     </p> </li> <li> <p><code>attributes</code> is an anonymous struct literal.           Each field name in <code>attributes</code> must match either a field or variant in     your <code>struct</code> or <code>union</code>, or the word <code>Container</code>. The former are known as     field/variant attributes, while the latter are known as container     attributes.</p> </li> <li> <p>Each field in <code>attributes</code> is also an anonymous struct literal. The    fields in these inner <code>struct</code> values depend on the kind of attribute    you're specifying (i.e., field/variant or container).</p> </li> </ol> <p>Supported Attributes</p> <p>For a complete list of the attributes supported by Getty, see here.</p>"},{"location":"user-guide/design/blocks-and-tuples/#type-defined-blocks","title":"Type-Defined Blocks","text":"<p>The blocks we've discussed so far are known as out-of-band blocks. They're defined separately from the type(s) that they operate on. Out-of-band blocks have their place, such as when you want to customize a type that you didn't define (e.g., the types in <code>std</code>). However, there's a more convenient way to do things for <code>struct</code> and <code>union</code> types that you did define yourself.</p> <p>If you define a block within a <code>struct</code> or <code>union</code>, Getty will automatically process it without you having to pass it to a (de)serializer. All you have to do is make sure that the block is public and named <code>@\"getty.sb\"</code> (for serialization) or <code>@\"getty.db\"</code> (for deserialization).</p> <p>Type-defined blocks are defined exactly the same as attribute and (de)serialization blocks are. The only difference is that you don't need to define an <code>is</code> function.</p> Zig code<pre><code>const Point = struct {\nx: i32,\ny: i32,\npub const @\"getty.sb\" = struct {\npub const attributes = .{\n.x = .{ .rename = \"X\" },\n.y = .{ .skip = true },\n};\n};\n};\n</code></pre>"},{"location":"user-guide/design/blocks-and-tuples/#usage","title":"Usage","text":"<p>Once you've defined a block, you can pass them along to Getty via the <code>getty.Serializer</code> and <code>getty.Deserializer</code> interfaces. They take optional (de)serialization blocks as arguments.</p> <p>For example, the following defines a serializer that can serialize Booleans and Integers into JSON. It's generic over an SB, which it passes to Getty, making it even easier for us to customize Getty's behavior.</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nfn Serializer(comptime user_sb: anytype) type {\nreturn struct {\npub usingnamespace getty.Serializer(\n@This(),\nOk,\nError,\nuser_sb,\nnull,\nnull,\nnull,\nnull,\n.{\n.serializeBool = serializeBool,\n.serializeInt = serializeInt,\n},\n);\nconst Ok = void;\nconst Error = getty.ser.Error;\nfn serializeBool(_: @This(), value: bool) Error!Ok {\nstd.debug.print(\"{}\\n\", .{value});\n}\nfn serializeInt(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"{}\\n\", .{value});\n}\n};\n}\nconst sb = struct {\npub fn is(comptime T: type) bool {\nreturn T == bool;\n}\npub fn serialize(_: ?std.mem.Allocator, value: anytype, serializer: anytype) !@TypeOf(serializer).Ok {\nconst v: i32 = if (value) 1 else 0;\nreturn try serializer.serializeInt(v);\n}\n};\npub fn main() !void {\n// Normal\n{\nvar s = Serializer(null){};\nconst serializer = s.serializer();\ntry getty.serialize(null, true, serializer);\ntry getty.serialize(null, false, serializer);\n}\n// Custom\n{\nvar s = Serializer(sb){};\nconst serializer = s.serializer();\ntry getty.serialize(null, true, serializer);\ntry getty.serialize(null, false, serializer);\n}\n}\n</code></pre> Shell session<pre><code>$ zig build run\ntrue\nfalse\n1\n0\n</code></pre>"},{"location":"user-guide/design/blocks-and-tuples/#tuples","title":"Tuples","text":"<p>In order to pass multiple (de)serialization blocks to Getty, you can use (de)serialization tuples.</p> <p>A (de)serialization tuple is, well, a tuple of (de)serialization blocks. They can be used wherever a (de)serialization block can be used and allow you to do some pretty cool things. For example, suppose you had the following type:</p> Zig code<pre><code>const Point = struct {\nx: i32,\ny: i32,\n};\n</code></pre> <p>If all you wanted to do was serialize <code>Point</code> values as Sequences, you'd just write an SB and pass it along to Getty. However, what if you also wanted to serialize <code>i32</code> values as Booleans? One option is to stuff all of your custom serialization logic into a single block. But that gets messy really quick and inevitably becomes a pain to maintain.</p> <p>A much better solution is to break up your serialization logic into separate blocks. One for <code>Point</code> values and one for <code>i32</code> values. Then, you just group them together as a serialization tuple!</p> Zig code<pre><code>const point_sb = struct { ... };\nconst i32_sb = struct { ... };\nconst point_st = .{ point_sb, i32_sb };\n</code></pre>"},{"location":"user-guide/design/data-models/","title":"Data Models","text":"<p>A data model represents a set of types that are supported by Getty. The types within a data model are purely conceptual; they aren't actually Zig types. For example, there is no <code>i32</code> or <code>u64</code> in either of Getty's data models. Instead, they're both considered to be Integers.</p>"},{"location":"user-guide/design/data-models/#models","title":"Models","text":"<p>Getty maintains two data models: one for serialization and another for deserialization.</p> Serialization Boolean <p>Represented by a <code>bool</code> value.</p> Enum <p>Represented by any <code>enum</code> value.</p> Float <p>Represented by any floating-point value (<code>comptime_float</code>, <code>f16</code>, <code>f32</code>, <code>f64</code>, <code>f80</code>, <code>f128</code>).</p> Integer <p>Represented by any integer value (<code>comptime_int</code>, <code>u0</code> \u2013 <code>u65535</code>, <code>i0</code> \u2013 <code>i65535</code>).</p> Map <p>Represented by a <code>getty.ser.Map</code> interface value.</p> Null <p>Represented by a <code>null</code> value.</p> Seq <p>Represented by a <code>getty.ser.Seq</code> interface value.</p> Some <p>Represented by the payload of an optional value.</p> String <p>Represented by any string value as determined by <code>std.meta.trait.isZigString</code>.</p> Structure <p>Represented by a <code>getty.ser.Structure</code> interface value.</p> Void <p>Represented by a <code>void</code> value.</p> Deserialization Boolean <p>Represented by a <code>bool</code> value.</p> Enum <p>Represented by any <code>enum</code> value.</p> Float <p>Represented by any floating-point value (<code>comptime_float</code>, <code>f16</code>, <code>f32</code>, <code>f64</code>, <code>f80</code>, <code>f128</code>).</p> Integer <p>Represented by any integer value (<code>comptime_int</code>, <code>u0</code> \u2013 <code>u65535</code>, <code>i0</code> \u2013 <code>i65535</code>).</p> Map <p>Represented by a <code>getty.de.MapAccess</code> interface value.</p> Null <p>Represented by a <code>null</code> value.</p> Seq <p>Represented by a <code>getty.de.SeqAccess</code> interface value.</p> Some <p>Represented by the payload of an optional value.</p> String <p>Represented by any string value as determined by <code>std.meta.trait.isZigString</code>.</p> Union <p>Represented by a <code>getty.de.UnionAccess</code> interface value and a <code>getty.de.VariantAccess</code> interface value.</p> Void <p>Represented by a <code>void</code> value.</p>"},{"location":"user-guide/design/data-models/#motivation","title":"Motivation","text":"<p>Getty's data models establish a generic baseline from which (de)serializers can operate.</p> <p> </p> <p>This design often simplifies the job of a (de)serializer significantly. For example, suppose you wanted to serialize <code>[]i32</code>, <code>[100]i32</code>, <code>std.ArrayList(i32)</code>, and <code>std.TailQueue(i32)</code> values. Since Zig considers all of these types to be different, you'd have to write unique serialization logic for all of them (as well as for integers)!</p> <p>In Getty, you don't have to do nearly as much work. Getty considers all of the aforementioned types to be the same: they are all Sequences. This means that you only have to specify the serialization process for two types: Integers and Sequences. And by doing so, you'll automatically be able to serialize values of any of the aforementioned types, plus any other value whose type is supported by Getty and is considered a Sequence, such as <code>std.SinglyLinkedList</code> and <code>std.BoundedArray</code>.</p> <p>Interactions</p> <p>Notice how (de)serializers in Getty never interact directly with Zig.</p> <ul> <li>Serializers receive values from Getty's data model and serialize them   into a data format.</li> <li>Deserializers receive values from a data format and deserialize them   into Getty's data model.</li> </ul>"},{"location":"user-guide/design/values/","title":"Values","text":""},{"location":"user-guide/design/values/#serialization","title":"Serialization","text":"<p>How a Zig value is represented within a data format is determined entirely by whichever Getty serializer you use. Therefore, it's important that you check how a serialization library is handling things before you start using it.</p> <p>As an example, here's how the Getty JSON library does things:</p> Shell session<pre><code>const a = {};                        // serialized as null\nconst b = \"foobar\";                  // serialized as \"foobar\"\nconst c = .foobar;                   // serialized as \"foobar\"\nconst d = .{ 1, 2, 3 };              // serialized as [1,2,3]\nconst e = .{ .x = 1, .y = 2 };       // serialized as {\"x\":1,\"y\":2}\nconst F = union(enum) { foo: i32 };\nconst f = U{ .foo = 1 };             // serialized as {\"foo\":1}\n</code></pre>"},{"location":"user-guide/design/values/#deserialization","title":"Deserialization","text":"<p>Similarly, it is up to a Getty deserializer to determine how values within a data format should be parsed and deserialized. For instance, the Getty JSON library has no issues converting the JSON object <code>{\"foo\":1}</code> into a tagged union. However, other deserializers may expect something different from their input data when deserializing into a union value.</p>"},{"location":"user-guide/tutorial/","title":"Tutorial","text":"<p>The goal of Getty is to help you write (de)serializers that are robust, customizable, performant, and able to easily support a wide variety of data types.</p> <p>For example, consider the following code, which defines a JSON serializer that supports scalar and string values. It can convert values of type <code>bool</code>, <code>i32</code>, <code>f64</code>, <code>enum{ foo, bar }</code>, <code>[]u8</code>, <code>*const [3]u8</code>, <code>?*void</code>, and more into JSON!</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\n@This(),\nOk,\nError,\nnull,\nnull,\nnull,\nnull,\nnull,\n.{\n.serializeBool = serializeBool,\n.serializeFloat = serializeNumber,\n.serializeInt = serializeNumber,\n.serializeNull = serializeNothing,\n.serializeString = serializeString,\n.serializeVoid = serializeNothing,\n.serializeEnum = serializeEnum,\n.serializeSome = serializeSome,\n},\n);\nconst Ok = void;\nconst Error = getty.ser.Error;\nfn serializeBool(_: @This(), value: bool) Error!Ok {\nstd.debug.print(\"{}\\n\", .{value});\n}\nfn serializeNumber(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"{}\\n\", .{value});\n}\nfn serializeNothing(_: @This()) Error!Ok {\nstd.debug.print(\"null\\n\", .{});\n}\nfn serializeString(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"\\\"{s}\\\"\\n\", .{value});\n}\nfn serializeEnum(s: @This(), value: anytype) Error!Ok {\ntry s.serializeString(@tagName(value));\n}\nfn serializeSome(s: @This(), value: anytype) Error!Ok {\ntry getty.serialize(null, value, s.serializer());\n}\n};\npub fn main() !void {\nconst s = (Serializer{}).serializer();\ntry getty.serialize(null, \"Getty\", s);\n}\n</code></pre> Shell session<pre><code>$ zig build run\n\"Getty\"\n</code></pre> <p>In this tutorial, we'll:</p> <ul> <li>Build up to the above <code>Serializer</code> implementation.</li> <li>Extend <code>Serializer</code> to support non-scalar types, such as <code>std.ArrayList</code>.</li> <li>Write a JSON deserializer.</li> <li>Learn how to customize the (de)serialization process.</li> </ul>"},{"location":"user-guide/tutorial/customization/","title":"Customization","text":"<p>So far, Getty has taken care of all of the little (de)serialization details for us behind the scenes. But sometimes, you need more control. That's where Getty's customization features come in.</p> <p>Getty allows both users and (de)serializers to customize the (de)serialization process for types that you've defined yourself, as well as for types that you didn't define such as those in the standard library. Moreover, the customization enabled by Getty can be used in a local manner. That is, you can serialize a <code>bool</code> value as a String in one function and as an Integer in another, all without having to convert the value to a new or intermediate type.</p> <p>Customization in Getty revolves around Blocks and Tuples, which can be passed to Getty via the <code>*_sbt</code> and <code>*_dbt</code> parameters of the <code>getty.Serializer</code> or <code>getty.Deserializer</code> interfaces.</p>"},{"location":"user-guide/tutorial/customization/#out-of-band-customization","title":"Out-of-Band Customization","text":"<p>Here, we define a serialization block that serializes <code>bool</code> values as Integers.</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n// (1)!\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\n@This(),\nOk,\nError,\nblock, // (2)!\nnull,\nnull,\nnull,\nnull,\n.{ .serializeInt = serializeInt },\n);\nconst Ok = void;\nconst Error = error{};\nfn serializeInt(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"{}\\n\", .{value});\n}\n};\nconst block = struct {\n// (3)!\npub fn is(comptime T: type) bool {\nreturn T == bool;\n}\n// (4)!\npub fn serialize(value: anytype, serializer: anytype) !@TypeOf(serializer).Ok {\nconst v: i32 = if (value) 1 else 0;\nreturn try serializer.serializeInt(v);\n}\n};\npub fn main() !void {\nconst s = (Serializer{}).serializer();\ntry getty.serialize(null, true, s);\ntry getty.serialize(null, false, s);\n}\n</code></pre> <ol> <li> <p>This serializer only knows how to serialize Integers.</p> </li> <li> <p>With <code>block</code> being passed to Getty, <code>bool</code> values will now be     serialized into Getty's data model as Integers, which, of course, is a     type that <code>Serializer</code> knows how to serialize.</p> </li> <li> <p><code>is</code> specifies which types <code>block</code> applies to.</p> </li> <li> <p><code>serialize</code> specifies how to serialize values relevant to <code>block</code>.</p> <p>In this case, we serialize the incoming <code>bool</code> value as an Integer before passing it on to the serializer.</p> </li> </ol> Shell session<pre><code>$ zig build run\n1\n0\n</code></pre> <p>We can also make <code>Serializer</code> generic over a BT to make customization even easier for users.</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nfn Serializer(comptime user_sbt: anytype) type {\nreturn struct {\npub usingnamespace getty.Serializer(\n@This(),\nOk,\nError,\nuser_sbt,\nnull,\nnull,\nnull,\nnull,\n.{\n.serializeInt = serializeInt,\n.serializeString = serializeString,\n},\n);\nconst Ok = void;\nconst Error = error{};\nfn serializeInt(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"{}\\n\", .{value});\n}\nfn serializeString(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"\\\"{s}\\\"\\n\", .{value});\n}\n};\n}\nconst int_block = struct {\npub fn is(comptime T: type) bool {\nreturn T == bool;\n}\npub fn serialize(value: anytype, serializer: anytype) !@TypeOf(serializer).Ok {\nconst v: i32 = if (value) 1 else 0;\nreturn try serializer.serializeInt(v);\n}\n};\nconst string_block = struct {\npub fn is(comptime T: type) bool {\nreturn T == bool;\n}\npub fn serialize(value: anytype, serializer: anytype) !@TypeOf(serializer).Ok {\nconst v = if (value) \"true\" else \"false\";\nreturn try serializer.serializeString(v);\n}\n};\npub fn main() !void {\n// Integer\n{\nconst s = (Serializer(int_block){}).serializer();\ntry getty.serialize(null, true, s);\ntry getty.serialize(null, false, s);\n}\n// String\n{\nconst s = (Serializer(string_block){}).serializer();\ntry getty.serialize(null, true, s);\ntry getty.serialize(null, false, s);\n}\n}\n</code></pre> Shell session<pre><code>$ zig build run\n1\n0\n\"true\"\n\"false\"\n</code></pre>"},{"location":"user-guide/tutorial/customization/#in-band-customization","title":"In-Band Customization","text":"<p>Out-of-band customization has its uses, such as when you want to customize a type that you didn't define. However, there's a more convenient way to do things for <code>struct</code> and <code>union</code> types that you did define yourself.</p> <p>If you define a BT within a <code>struct</code> or <code>union</code>, Getty will automatically process it without you having to pass it in directly through a (de)serializer. Just make sure the BT is public and named either <code>@\"getty.sb\"</code> or <code>@\"getty.db\"</code> (<code>sb</code> for serialization, <code>db</code> for deserialization).</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Point = struct {\nx: i32,\ny: i32,\npub const @\"getty.sb\" = struct {\npub const attributes = .{\n.x = .{ .rename = \"X\" },\n.y = .{ .skip = true },\n};\n};\n};\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\n@This(),\nOk,\nError,\nnull,\nnull,\nnull,\nnull,\nStruct,\n.{\n.serializeInt = serializeInt,\n.serializeString = serializeString,\n.serializeStruct = serializeStruct,\n},\n);\nconst Ok = void;\nconst Error = error{};\nfn serializeInt(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"{}\", .{value});\n}\nfn serializeString(_: @This(), value: anytype) Error!Ok {\nstd.debug.print(\"\\\"{s}\\\"\", .{value});\n}\nfn serializeStruct(_: @This(), comptime _: []const u8, _: usize) Error!Struct {\nstd.debug.print(\"{{\", .{});\nreturn Struct{};\n}\n};\nconst Struct = struct {\nfirst: bool = true,\npub usingnamespace getty.ser.Structure(\n*@This(),\nOk,\nError,\n.{\n.serializeField = serializeField,\n.end = end,\n},\n);\nconst Ok = Serializer.Ok;\nconst Error = Serializer.Error;\nfn serializeField(self: *@This(), comptime key: []const u8, value: anytype) Error!void {\n// Serialize key.\nswitch (self.first) {\ntrue =&gt; self.first = false,\nfalse =&gt; std.debug.print(\", \", .{}),\n}\ntry getty.serialize(null, key, (Serializer{}).serializer());\n// Serialize value.\nstd.debug.print(\": \", .{});\ntry getty.serialize(null, value, (Serializer{}).serializer());\n}\nfn end(_: *@This()) Error!Ok {\nstd.debug.print(\"}}\\n\", .{});\n}\n};\npub fn main() !void {\nconst v = Point{ .x = 1, .y = 2 };\nconst s = (Serializer{}).serializer();\ntry getty.serialize(null, v, s);\n}\n</code></pre> Shell session<pre><code>$ zig build run\n{\"X\": 1}\n</code></pre>"},{"location":"user-guide/tutorial/deserializers/","title":"Deserializers","text":"<p>Let's write a simple (albeit slightly naive) JSON deserializer.</p>"},{"location":"user-guide/tutorial/deserializers/#scalar-deserialization","title":"Scalar Deserialization","text":"<p>Every Getty deserializer implements the <code>getty.Deserializer</code> interface, shown below.</p> Zig code<pre><code>// (1)!\nfn Deserializer(\ncomptime Context: type, // (2)!\ncomptime E: type, // (3)!\n// (4)!\ncomptime user_dbt: anytype,\ncomptime deserializer_dbt: anytype,\n// (5)!\ncomptime methods: struct {\n// (6)!\ndeserializeAny: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeBool: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeEnum: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeFloat: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeIgnored: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeInt: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeMap: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeOptional: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeSeq: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeString: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeStruct: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeUnion: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\ndeserializeVoid: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\n},\n) type\n</code></pre> <ol> <li> <p>A <code>getty.Deserializer</code> deserializes     values from a data format into Getty's data model.</p> </li> <li> <p><code>Context</code> is a namespace that owns the method implementations passed to the     <code>methods</code> parameter.</p> <p>Usually, this is the type implementing <code>getty.Deserializer</code> or a pointer to it if mutability is required.</p> </li> <li> <p><code>E</code> is the error set returned by     <code>getty.Deserializer</code>'s methods upon     failure.</p> <p>The value of <code>E</code> must contain <code>getty.de.Error</code>, a base error set defined by Getty.</p> </li> <li> <p><code>user_dbt</code> and <code>deserializer_dbt</code> are optional user- and deserializer-defined     derialization blocks or tuples, respectively.</p> <p>They allow users and deserializers to customize Getty's deserialization behavior. If user- or deserializer-defined customization isn't supported, <code>null</code> can be passed in for these parameters.</p> </li> <li> <p><code>methods</code> lists every method that a <code>Deserializer</code> must     provide or can override.</p> </li> <li> <p>These methods are responsible for deserializing into a specific type in     Getty's data model from a data format.</p> <p>The <code>v</code> parameter in these methods is a <code>getty.de.Visitor</code> interface value.</p> <p>The <code>deserializeAny</code> and <code>deserializeIgnored</code> methods are pretty niche, so we can ignore them for this tutorial.</p> </li> </ol> <p>Quite the parameter list!</p> <p>Luckily, most of the parameters have default values we can use. So, let's start with the following implementation:</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Deserializer = struct {\ntokens: std.json.TokenStream, // (1)!\nconst Self = @This();\npub usingnamespace getty.Deserializer(\n*Self,\nError,\nnull,\nnull,\n.{},\n);\nconst Error = getty.de.Error ||\nstd.json.TokenStream.Error ||\nstd.fmt.ParseIntError ||\nstd.fmt.ParseFloatError;\nconst De = Self.@\"getty.Deserializer\"; // (2)!\npub fn init(json: []const u8) Self {\nreturn .{ .tokens = std.json.TokenStream.init(json) };\n}\n};\n</code></pre> <ol> <li> <p>A JSON parser provided by the standard library.</p> </li> <li> <p>A convenient alias for our <code>getty.Deserializer</code> interface type.</p> </li> </ol> <p>Kind of a useless deserializer...</p> <p>But let's try deserializing a value with it anyways! We can do so by calling <code>getty.deserialize</code>, which takes an optional allocator, a type to deserialize into, and a <code>getty.Deserializer</code> interface value.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Deserializer = struct {\ntokens: std.json.TokenStream,\nconst Self = @This();\npub usingnamespace getty.Deserializer(\n*Self,\nError,\nnull,\nnull,\n.{},\n);\nconst Error = getty.de.Error ||\nstd.json.TokenStream.Error ||\nstd.fmt.ParseIntError ||\nstd.fmt.ParseFloatError;\nconst De = Self.@\"getty.Deserializer\";\npub fn init(json: []const u8) Self {\nreturn .{ .tokens = std.json.TokenStream.init(json) };\n}\n};\npub fn main() !void {\nconst s = \"true\";\nvar d = Deserializer.init(s);\nconst deserializer = d.deserializer();\nconst v = try getty.deserialize(null, bool, deserializer);\nstd.debug.print(\"{} ({})\\n\", .{ v, @TypeOf(v) });\n}\n</code></pre> Shell session<pre><code>$ zig build run\nerror: deserializeBool is not implemented by type: *main.Deserializer\n</code></pre> <p>Oh no, a compile error!</p> <p>Looks like Getty can't deserialize into the <code>bool</code> type unless <code>deserializeBool</code> is implemented.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Allocator = std.mem.Allocator;\nconst Deserializer = struct {\ntokens: std.json.TokenStream,\nconst Self = @This();\npub usingnamespace getty.Deserializer(\n*Self,\nError,\nnull,\nnull,\n.{\n.deserializeBool = deserializeBool,\n},\n);\nconst Error = getty.de.Error ||\nstd.json.TokenStream.Error ||\nstd.fmt.ParseIntError ||\nstd.fmt.ParseFloatError;\nconst De = Self.@\"getty.Deserializer\";\npub fn init(json: []const u8) Self {\nreturn .{ .tokens = std.json.TokenStream.init(json) };\n}\n// (1)!\nfn deserializeBool(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .True or token == .False) {\nreturn try v.visitBool(allocator, De, token == .True);\n}\n}\nreturn error.InvalidType;\n}\n};\npub fn main() !void {\nconst s = \"true\";\nvar d = Deserializer.init(s);\nconst deserializer = d.deserializer();\nconst v = try getty.deserialize(null, bool, deserializer);\nstd.debug.print(\"{} ({})\\n\", .{ v, @TypeOf(v) });\n}\n</code></pre> <ol> <li> <p>What we're doing in this function is:</p> <ol> <li>Parsing a token from the JSON data.</li> <li>Checking to see if the token is a JSON Boolean.</li> <li>Deserializing the token into a Boolean (<code>token == .True</code>).</li> <li>Passing the Boolean to the visitor, <code>v</code>.</li> </ol> </li> </ol> Shell session<pre><code>$ zig build run\ntrue (bool)\n</code></pre> <p>Success!</p> <p>Now let's do the same thing for <code>deserializeEnum</code>, <code>deserializeFloat</code>, <code>deserializeInt</code>, <code>deserializeString</code>, <code>deserializeVoid</code>, and <code>deserializeOptional</code>.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Allocator = std.mem.Allocator;\nconst Deserializer = struct {\ntokens: std.json.TokenStream,\nconst Self = @This();\npub usingnamespace getty.Deserializer(\n*Self,\nError,\nnull,\nnull,\n.{\n.deserializeBool = deserializeBool,\n.deserializeEnum = deserializeEnum,\n.deserializeFloat = deserializeFloat,\n.deserializeInt = deserializeInt,\n.deserializeString = deserializeString,\n.deserializeVoid = deserializeVoid,\n.deserializeOptional = deserializeOptional,\n},\n);\nconst Error = getty.de.Error ||\nstd.json.TokenStream.Error ||\nstd.fmt.ParseIntError ||\nstd.fmt.ParseFloatError;\nconst De = Self.@\"getty.Deserializer\";\npub fn init(json: []const u8) Self {\nreturn .{ .tokens = std.json.TokenStream.init(json) };\n}\nfn deserializeBool(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .True or token == .False) {\nreturn try v.visitBool(allocator, De, token == .True);\n}\n}\nreturn error.InvalidType;\n}\n// (1)!\nfn deserializeEnum(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .String) {\nconst str = token.String.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitString(allocator, De, str);\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeFloat(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Number) {\nconst str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitFloat(allocator, De, try std.fmt.parseFloat(f64, str));\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeInt(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Number) {\nconst str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\nif (token.Number.is_integer) {\nreturn try switch (str[0]) {\n'-' =&gt; v.visitInt(allocator, De, try std.fmt.parseInt(i64, str, 10)),\nelse =&gt; v.visitInt(allocator, De, try std.fmt.parseInt(u64, str, 10)),\n};\n}\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeString(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .String) {\nconst str = token.String.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitString(allocator, De, try allocator.?.dupe(u8, str));\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeVoid(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Null) {\nreturn try v.visitVoid(allocator, De);\n}\n}\nreturn error.InvalidType;\n}\n// (2)!\nfn deserializeOptional(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nconst backup = self.tokens;\nif (try self.tokens.next()) |token| {\nif (token == .Null) {\nreturn try v.visitNull(allocator, De);\n}\nself.tokens = backup;\nreturn try v.visitSome(allocator, self.deserializer());\n}\nreturn error.InvalidType;\n}\n};\npub fn main() !void {\nconst allocator = std.heap.page_allocator; // (3)!\nconst types = .{ i32, f32, []u8, enum { foo }, ?u8, void };\nconst jsons = .{ \"10\", \"10.0\", \"\\\"ABC\\\"\", \"\\\"foo\\\"\", \"null\", \"null\" };\ninline for (jsons) |s, i| {\nconst T = types[i];\nvar d = Deserializer.init(s);\nconst deserializer = d.deserializer();\nconst v = try getty.deserialize(allocator, T, deserializer);\ndefer getty.de.free(allocator, v); // (4)!\nstd.debug.print(\"{any} ({})\\n\", .{ v, @TypeOf(v) });\n}\n}\n</code></pre> <ol> <li> <p>Just like in <code>deserializeBool</code>, all we're doing in these functions is     parsing tokens, turning them into Getty values, and passing those values to     a visitor.</p> <p>By the way, you'll see <code>token.X.slice</code> come up pretty often in our deserializer. All it's doing is getting the string that corresponds to our token from the JSON data.</p> </li> <li> <p><code>deserializeOptional</code> is a bit different from the other methods. Instead of     passing a Getty value to a visitor, you pass a deserializer to <code>visitSome</code>.     The visitor will then restart the deserialization process using the     optional's payload.</p> <p>You can think of this method as a place to do some pre-processing before deserializing an actual payload value.</p> </li> <li> <p>To deserialize pointer values, Getty requires an allocator.</p> </li> <li> <p>This is a convenience function that lets you to easily free values that     were deserialized by Getty.</p> </li> </ol> Shell session<pre><code>$ zig build run\n10 (i32)\n1.0e+01 (f32)\n{ 65, 66, 67 } ([]u8)\nmain.main__enum_1315.foo (main.main__enum_1315)\nnull (?u8)\nvoid (void)\n</code></pre> <p>Not too shabby!</p> The <code>deserialize*</code> methods <p>When Getty calls <code>deserializeBool</code>, it is not telling <code>Deserializer</code> that it should parse and deserialize a JSON Boolean from its input data. Instead, Getty is simply providing a hint about the type that is being deserialized into. </p> <p>That is, Getty is telling <code>Deserializer</code>, \"Hey, the type that the user is deserializing into can most likely be constructed from a Getty Boolean, so you should probably deserialize your input data into one.\"</p> <p>What this means is that we don't have to limit ourselves to parsing only JSON Booleans in <code>deserializeBool</code>. We could, for instance, have <code>deserializeBool</code> support JSON numbers as well.</p> Zig code<pre><code>fn deserializeBool(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\n// JSON Booleans -&gt; Getty Booleans\nif (token == .True or token == .False) {\nreturn try v.visitBool(allocator, De, token == .True);\n}\n// JSON Numbers -&gt; Getty Booleans\nif (token == .Number) {\nif (token.Number.is_integer) {\nconst str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\nconst int = try std.fmt.parseInt(i64, str, 10);\nreturn try v.visitBool(allocator, De, int != 0);\n}\n}\n}\nreturn error.InvalidType;\n}\n</code></pre>"},{"location":"user-guide/tutorial/deserializers/#aggregate-deserialization","title":"Aggregate Deserialization","text":"<p>Alright, now let's take a look at deserialization for aggregate types.</p> <p>The difference between scalar and aggregate deserialization is that the aggregate types in Getty's data model do not directly map to any particular Zig type (or set of Zig types). That is, while Booleans are represented by <code>bool</code>s and Integers are represented by any Zig integer type, there is no native data type in Zig that is able to generically represent Sequences or Maps.</p> <p>This is where the aggregate deserialization interfaces come in. They represent the aggregate types within Getty's data model (from a deserialization perspective). There are four of them:</p> <code>getty.de.SeqAccess</code> <p>Represents a Sequence.</p> <code>getty.de.MapAccess</code> <p>Represents a Map.</p> <code>getty.de.UnionAccess</code>, <code>getty.de.VariantAccess</code> <p>Represents a Union.</p> <p>Let's start by implementing <code>deserializeSeq</code>, which uses the <code>getty.de.SeqAccess</code> interface.</p> getty.de.SeqAccess Zig code<pre><code>// (1)!\nfn SeqAccess(\ncomptime Context: type,\ncomptime E: type,\ncomptime methods: struct {\n// (2)!\nnextElementSeed: ?fn (Context, ?std.mem.Allocator, seed: anytype) E!?@TypeOf(seed).Value = null,\n},\n) type\n</code></pre> <ol> <li> <p>A <code>getty.de.SeqAccess</code> is responsible for deserializing elements of a Sequence into Zig.</p> </li> <li> <p>The <code>seed</code> parameter of <code>nextElementSeed</code> is a <code>getty.de.Seed</code>     interface value, which allows for stateful deserialization.</p> <p>By default, Getty passes in <code>getty.de.DefaultSeed</code> <code>seed</code>. The default seed just calls <code>getty.deserialize</code> and can therefore be used for stateless deserialization.</p> </li> </ol> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Allocator = std.mem.Allocator;\nconst Deserializer = struct {\ntokens: std.json.TokenStream,\nconst Self = @This();\npub usingnamespace getty.Deserializer(\n*Self,\nError,\nnull,\nnull,\n.{\n.deserializeBool = deserializeBool,\n.deserializeEnum = deserializeEnum,\n.deserializeFloat = deserializeFloat,\n.deserializeInt = deserializeInt,\n.deserializeString = deserializeString,\n.deserializeVoid = deserializeVoid,\n.deserializeOptional = deserializeOptional,\n.deserializeSeq = deserializeSeq,\n},\n);\nconst Error = getty.de.Error ||\nstd.json.TokenStream.Error ||\nstd.fmt.ParseIntError ||\nstd.fmt.ParseFloatError;\nconst De = Self.@\"getty.Deserializer\";\npub fn init(json: []const u8) Self {\nreturn .{ .tokens = std.json.TokenStream.init(json) };\n}\nfn deserializeBool(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .True or token == .False) {\nreturn try v.visitBool(allocator, De, token == .True);\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeEnum(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .String) {\nconst str = token.String.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitString(allocator, De, str);\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeFloat(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Number) {\nconst str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitFloat(allocator, De, try std.fmt.parseFloat(f64, str));\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeInt(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Number) {\nconst str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\nif (token.Number.is_integer) {\nreturn try switch (str[0]) {\n'-' =&gt; v.visitInt(allocator, De, try std.fmt.parseInt(i64, str, 10)),\nelse =&gt; v.visitInt(allocator, De, try std.fmt.parseInt(u64, str, 10)),\n};\n}\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeString(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .String) {\nconst str = token.String.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitString(allocator, De, try allocator.?.dupe(u8, str));\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeVoid(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Null) {\nreturn try v.visitVoid(allocator, De);\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeOptional(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nconst backup = self.tokens;\nif (try self.tokens.next()) |token| {\nif (token == .Null) {\nreturn try v.visitNull(allocator, De);\n}\nself.tokens = backup;\nreturn try v.visitSome(allocator, self.deserializer());\n}\nreturn error.InvalidType;\n}\nfn deserializeSeq(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .ArrayBegin) {\nvar sa = SeqAccess{ .de = self };\nreturn try v.visitSeq(allocator, De, sa.seqAccess());\n}\n}\nreturn error.InvalidType;\n}\n};\nconst SeqAccess = struct {\nde: *Deserializer,\npub usingnamespace getty.de.SeqAccess(\n*@This(),\nDeserializer.Error,\n.{ .nextElementSeed = nextElementSeed },\n);\nfn nextElementSeed(self: *@This(), allocator: ?Allocator, seed: anytype) Deserializer.Error!?@TypeOf(seed).Value {\n// Deserialize element.\nconst element = seed.deserialize(allocator, self.de.deserializer()) catch |err| {\n// End of input was encountered early.\nif (self.de.tokens.i - 1 &gt;= self.de.tokens.slice.len) {\nreturn err;\n}\nreturn switch (self.de.tokens.slice[self.de.tokens.i - 1]) {\n']' =&gt; null, // End of sequence was encountered.\nelse =&gt; err, // Unexpected token was encountered.\n};\n};\nreturn element;\n}\n};\npub fn main() !void {\nconst allocator = std.heap.page_allocator;\nvar d = Deserializer.init(\"[1,2,3]\");\nconst deserializer = d.deserializer();\nconst v = try getty.deserialize(allocator, std.ArrayList(i32), deserializer);\ndefer v.deinit();\nstd.debug.print(\"{any} ({})\\n\", .{ v.items, @TypeOf(v) });\n}\n</code></pre> Shell session<pre><code>$ zig build run\n{ 1, 2, 3 } (array_list.ArrayListAligned(i32,null))\n</code></pre> <p>Hooray!</p> <p>Just like before, notice how we didn't have to write any iteration- or access-related code specific to <code>std.ArrayList</code> or any other Zig type. We just had to specify how JSON sequences (arrays) should be deserialized and Getty took care of the rest!</p> <p>Okay, that leaves us with <code>deserializeMap</code> and <code>deserializeUnion</code>. Let's implement the former, which uses the <code>getty.de.MapAccess</code> interface.</p> getty.de.MapAccess Zig code<pre><code>// (1)!\nfn MapAccess(\ncomptime Context: type,\ncomptime E: type,\ncomptime methods: struct {\nnextKeySeed: ?fn (Context, ?std.mem.Allocator, seed: anytype) E!?@TypeOf(seed).Value = null,\nnextValueSeed: ?fn (Context, ?std.mem.Allocator, seed: anytype) E!@TypeOf(seed).Value = null,\n},\n) type\n</code></pre> <ol> <li>A <code>getty.de.MapAccess</code> is responsible for deserializing entries of a Map into Zig.</li> </ol> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Allocator = std.mem.Allocator;\nconst Deserializer = struct {\ntokens: std.json.TokenStream,\nconst Self = @This();\npub usingnamespace getty.Deserializer(\n*Self,\nError,\nnull,\nnull,\n.{\n.deserializeBool = deserializeBool,\n.deserializeEnum = deserializeEnum,\n.deserializeFloat = deserializeFloat,\n.deserializeInt = deserializeInt,\n.deserializeString = deserializeString,\n.deserializeVoid = deserializeVoid,\n.deserializeOptional = deserializeOptional,\n.deserializeSeq = deserializeSeq,\n.deserializeMap = deserializeMap,\n},\n);\nconst Error = getty.de.Error ||\nstd.json.TokenStream.Error ||\nstd.fmt.ParseIntError ||\nstd.fmt.ParseFloatError;\nconst De = Self.@\"getty.Deserializer\";\npub fn init(json: []const u8) Self {\nreturn .{ .tokens = std.json.TokenStream.init(json) };\n}\nfn deserializeBool(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .True or token == .False) {\nreturn try v.visitBool(allocator, De, token == .True);\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeEnum(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .String) {\nconst str = token.String.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitString(allocator, De, str);\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeFloat(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Number) {\nconst str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitFloat(allocator, De, try std.fmt.parseFloat(f64, str));\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeInt(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Number) {\nconst str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\nif (token.Number.is_integer) {\nreturn try switch (str[0]) {\n'-' =&gt; v.visitInt(allocator, De, try std.fmt.parseInt(i64, str, 10)),\nelse =&gt; v.visitInt(allocator, De, try std.fmt.parseInt(u64, str, 10)),\n};\n}\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeString(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .String) {\nconst str = token.String.slice(self.tokens.slice, self.tokens.i - 1);\nreturn try v.visitString(allocator, De, try allocator.?.dupe(u8, str));\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeVoid(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .Null) {\nreturn try v.visitVoid(allocator, De);\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeOptional(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nconst backup = self.tokens;\nif (try self.tokens.next()) |token| {\nif (token == .Null) {\nreturn try v.visitNull(allocator, De);\n}\nself.tokens = backup;\nreturn try v.visitSome(allocator, self.deserializer());\n}\nreturn error.InvalidType;\n}\nfn deserializeSeq(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .ArrayBegin) {\nvar sa = SeqAccess{ .de = self };\nreturn try v.visitSeq(allocator, De, sa.seqAccess());\n}\n}\nreturn error.InvalidType;\n}\nfn deserializeMap(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\nif (try self.tokens.next()) |token| {\nif (token == .ObjectBegin) {\nvar ma = MapAccess{ .de = self };\nreturn try v.visitMap(allocator, De, ma.mapAccess());\n}\n}\nreturn error.InvalidType;\n}\n};\nconst SeqAccess = struct {\nde: *Deserializer,\npub usingnamespace getty.de.SeqAccess(\n*@This(),\nDeserializer.Error,\n.{ .nextElementSeed = nextElementSeed },\n);\nfn nextElementSeed(self: *@This(), allocator: ?Allocator, seed: anytype) Deserializer.Error!?@TypeOf(seed).Value {\nconst element = seed.deserialize(allocator, self.de.deserializer()) catch |err| {\n// End of input was encountered early.\nif (self.de.tokens.i - 1 &gt;= self.de.tokens.slice.len) {\nreturn err;\n}\nreturn switch (self.de.tokens.slice[self.de.tokens.i - 1]) {\n']' =&gt; null, // End of sequence was encountered.\nelse =&gt; err, // Unexpected token was encountered.\n};\n};\nreturn element;\n}\n};\nconst MapAccess = struct {\nde: *Deserializer,\npub usingnamespace getty.de.MapAccess(\n*@This(),\nDeserializer.Error,\n.{\n.nextKeySeed = nextKeySeed,\n.nextValueSeed = nextValueSeed,\n},\n);\nfn nextKeySeed(self: *@This(), allocator: ?Allocator, seed: anytype) Deserializer.Error!?@TypeOf(seed).Value {\nconst tokens = self.d.tokens;\nif (try self.d.tokens.next()) |token| {\n// End of map was encountered.\nif (token == .ObjectEnd) {\nreturn null;\n}\n// Key was encountered.\nif (token == .String) {\n// Restore key.\nself.de.tokens = tokens;\n// Deserialize key.\nreturn try seed.deserialize(allocator, self.de.deserializer());\n}\n}\nreturn error.InvalidType;\n}\nfn nextValueSeed(self: *@This(), allocator: ?Allocator, seed: anytype) Deserializer.Error!@TypeOf(seed).Value {\nreturn try seed.deserialize(allocator, self.d.deserializer());\n}\n};\npub fn main() !void {\nconst allocator = std.heap.page_allocator;\nvar d = Deserializer.init(\"\\\"x\\\":1,\\\"y\\\":2\");\nconst deserializer = d.deserializer();\nconst v = try getty.deserialize(allocator, struct{ x: i32, y: i32 }, deserializer);\nstd.debug.print(\"{any} ({})\\n\", .{ v, @TypeOf(v) });\n}\n</code></pre> <ol> <li> <p>What we're doing here is telling Getty to perform deserialization again (by     calling <code>seed.deserialize</code>) so that we can deserialize an element from the     deserializer's input data.</p> <p>If there are no elements left (i.e., if <code>]</code> was encountered) then <code>null</code> is returned. Otherwise, the deserialized element is.</p> <p>The <code>seed</code> parameter of <code>nextElementSeed</code> is a <code>getty.de.Seed</code> interface value, which allows for stateful deserialization. We don't really need that for this tutorial, but we can still use <code>seed</code> since the default seed of Getty just calls <code>getty.deserialize</code>.</p> </li> </ol> Shell session<pre><code>$ zig build run\n{ 1, 2, 3 } (array_list.ArrayListAligned(i32,null))\n</code></pre>"},{"location":"user-guide/tutorial/interfaces/","title":"Interfaces","text":"<p>Interfaces are a big part of Getty, so let's take some time now to learn a bit about them.</p>"},{"location":"user-guide/tutorial/interfaces/#interface","title":"Interface","text":"<p>In Getty, an interface is a function whose parameter list specifies constraints and behaviors. For example, the following code defines an interface that requires from its implementations three associated types (<code>Context</code>, <code>O</code>, <code>E</code>) and one method (<code>serializeBool</code>).</p> Zig code<pre><code>fn BoolSerializer(\n// (1)!\ncomptime Context: type,\ncomptime O: type,\ncomptime E: type,\n// (2)!\ncomptime methods: struct {\nserializeBool: ?fn (Context, bool) E!O = null,\n},\n) type\n</code></pre> <ol> <li> <p><code>Context</code>, <code>O</code>, and <code>E</code> are types that implementations of <code>BoolSerializer</code>     must provide.</p> </li> <li> <p><code>methods</code> lists every method that implementations of <code>BoolSerializer</code> must     provide or can override.</p> <p>If a method is not provided by an implementation, it is up to the interface to decide what happens. Generally, a compile error is raised, an error is returned, or a default implementation is used.</p> </li> </ol> <p>The return value of an interface is a namespace (i.e., a <code>struct</code> type with no fields) that contains two declarations: an interface type and an interface function.</p> Zig code<pre><code>fn BoolSerializer(\ncomptime Context: type,\ncomptime O: type,\ncomptime E: type,\ncomptime methods: struct {\nserializeBool: ?fn (Context, bool) E!O = null,\n},\n) type {\nreturn struct {\n// (2)!\npub const Interface = struct {\ncontext: Context,\npub const Ok = O;\npub const Error = E;\npub fn serializeBool(self: @This(), value: bool) Error!Ok {\nif (methods.serializeBool) |f| {\nreturn try f(self.context, value);\n}\n@compileError(\"serializeBool is unimplemented\");\n}\n};\n// (1)!\npub fn boolSerializer(self: Context) Interface {\nreturn .{ .context = self };\n}\n};\n}\n</code></pre> <ol> <li> <p><code>boolSerializer</code> is an interface function.</p> <p>Its job is to return a value of the interface type, also known as an interface value.</p> </li> <li> <p><code>Interface</code> is an interface type. They generally have:</p> <ul> <li>A single field to store an instance of an implementation.</li> <li>Wrapper declarations that may come in handy.</li> <li>Wrapper methods that define the interface's behavior.</li> </ul> </li> </ol> <p>Naming Conventions</p> <ul> <li> <p>Interface types are always named after the interface's import path. For   example, the interface type for the   <code>getty.de.SeqAccess</code>   interface is named <code>@\"getty.de.SeqAccess\"</code>.</p> </li> <li> <p>Interface functions are always named after the interface in <code>camelCase</code>   format. For example, the interface function for the   <code>getty.de.SeqAccess</code>   interface is named <code>seqAccess</code>.</p> </li> </ul>"},{"location":"user-guide/tutorial/interfaces/#implementation","title":"Implementation","text":"<p>To implement a Getty interface, call the interface and apply <code>usingnamespace</code> to the returned value. An interface type and an interface function will be imported into your implementation.</p> Zig code<pre><code>const std = @import(\"std\");\nconst SerializerA = struct {\nusingnamespace BoolSerializer(\n@This(),\nvoid,\nerror{},\n.{},\n);\n};\nconst SerializerB = struct {\nusingnamespace BoolSerializer(\nContext,\nOk,\nError,\n.{ .serializeBool = serializeBool },\n);\nconst Context = @This();\nconst Ok = void;\nconst Error = error{};\nfn serializeBool(_: Context, value: bool) Error!Ok {\nstd.debug.print(\"{}\\n\", .{!value});\n}\n};\n</code></pre>"},{"location":"user-guide/tutorial/interfaces/#usage","title":"Usage","text":"<p>To use a value of, say <code>SerializerB</code>, as an implementation of <code>BoolSerializer</code>:</p> Zig code<pre><code>pub fn main() !void {\nconst s = SerializerB{}; // (1)!\nconst bs = s.boolSerializer();  // (2)!\n// (3)!\ntry bs.serializeBool(true);\ntry bs.serializeBool(false);\n}\n</code></pre> <ol> <li>Create a value of the implementing type, <code>OppositeSerializer</code>.</li> <li>Create an interface value from the implementation using the interface function.</li> <li>Use the interface value for all of your interface-y needs!</li> </ol> Shell session<pre><code>$ zig build run\nfalse\ntrue\n</code></pre>"},{"location":"user-guide/tutorial/interfaces/#next-steps","title":"Next Steps","text":"<p>Okay, that should be enough to get us through the tutorial. Let's get started!</p>"},{"location":"user-guide/tutorial/serializers/","title":"Serializers","text":"<p>Let's write a JSON serializer that serializes values by printing their JSON equivalent to <code>STDERR</code>.</p>"},{"location":"user-guide/tutorial/serializers/#scalar-serialization","title":"Scalar Serialization","text":"<p>Every Getty serializer must implement the <code>getty.Serializer</code> interface, shown below.</p> Zig code<pre><code>// (1)!\nfn Serializer(\ncomptime Context: type, // (2)!\ncomptime O: type, // (3)!\ncomptime E: type, // (4)!\n// (5)!\ncomptime user_sbt: anytype,\ncomptime serializer_sbt: anytype,\n// (6)!\ncomptime Map: ?type,\ncomptime Seq: ?type,\ncomptime Structure: ?type,\n// (7)!\ncomptime methods: struct {\nserializeBool: ?fn (Context, bool) E!O = null,\nserializeEnum: ?fn (Context, anytype) E!O = null,\nserializeFloat: ?fn (Context, anytype) E!O = null,\nserializeInt: ?fn (Context, anytype) E!O = null,\nserializeMap: ?fn (Context, ?usize) E!Map = null,\nserializeNull: ?fn (Context) E!O = null,\nserializeSeq: ?fn (Context, ?usize) E!Seq = null,\nserializeSome: ?fn (Context, anytype) E!O = null,\nserializeString: ?fn (Context, anytype) E!O = null,\nserializeStruct: ?fn (Context, comptime []const u8, usize) E!Structure = null,\nserializeVoid: ?fn (Context) E!O = null,\n},\n) type\n</code></pre> <ol> <li> <p>A <code>Serializer</code> serializes values from Getty's data model into a data format.</p> </li> <li> <p><code>Context</code> is a namespace that owns the method implementations passed to the     <code>methods</code> parameter.</p> <p>Usually, this is the type implementing <code>getty.Serializer</code> or a pointer to it if mutability is required.</p> </li> <li> <p><code>O</code> is the successful return type for most of a <code>Serializer</code>'s methods.</p> </li> <li> <p><code>E</code> is the error set returned by a <code>Serializer</code>'s methods upon failure.</p> <p><code>E</code> must contain <code>getty.ser.Error</code>.</p> </li> <li> <p><code>user_sbt</code> and <code>serializer_sbt</code> are optional user- and serializer-defined     SBTs, respectively.</p> <p>SBTs allow users and serializers to customize Getty's serialization behavior. If user- or serializer-defined customization isn't supported, you can pass in <code>null</code>.</p> </li> <li> <p><code>Map</code>, <code>Seq</code>, and <code>Structure</code> are optional types that implement Getty's     aggregate serialization interfaces.</p> <p>Those interfaces are <code>getty.ser.Map</code>, <code>getty.ser.Seq</code>, and <code>getty.ser.Structure</code>.</p> </li> <li> <p><code>methods</code> lists every method that a <code>Serializer</code> must provide or can     override.</p> </li> </ol> <p>Quite the parameter list!</p> <p>Luckily, most of the parameters have default values we can use. So, let's start with the following implementation:</p> <code>src/main.zig</code><pre><code>const getty = @import(\"getty\");\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\nContext,\nOk,\nError,\nnull,\nnull,\nnull,\nnull,\nnull,\n.{},\n);\nconst Context = @This();\nconst Ok = void;\nconst Error = getty.ser.Error;\n};\n</code></pre> <p>To serialize a value using <code>Serializer</code>, we can call <code>getty.serialize</code>, which takes an optional allocator, a value to serialize, and a <code>getty.Serializer</code> interface value.</p> <code>src/main.zig</code><pre><code>const getty = @import(\"getty\");\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\nContext,\nOk,\nError,\nnull,\nnull,\nnull,\nnull,\nnull,\n.{},\n);\nconst Context = @This();\nconst Ok = void;\nconst Error = getty.ser.Error;\n};\npub fn main() !void {\nconst s = (Serializer{}).serializer();\ntry getty.serialize(null, true, s);\n}\n</code></pre> Shell session<pre><code>$ zig build run\n[...] error: serializeBool is not implemented by type: main.Serializer\n</code></pre> <p>A compile error!</p> <p>It looks like Getty can't serialize <code>bool</code>s unless <code>serializeBool</code> is implemented. Let's fix that.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\nContext,\nOk,\nError,\nnull,\nnull,\nnull,\nnull,\nnull,\n.{\n.serializeBool = serializeBool,\n},\n);\nconst Context = @This();\nconst Ok = void;\nconst Error = getty.ser.Error;\nfn serializeBool(_: Context, value: bool) Error!Ok {\nstd.debug.print(\"{}\", .{value});\n}\n};\npub fn main() !void {\nconst s = (Serializer{}).serializer();\ntry getty.serialize(null, true, s);\nstd.debug.print(\"\\n\", .{});\n}\n</code></pre> Shell session<pre><code>$ zig build run\ntrue\n</code></pre> <p>Success!</p> <p>Now let's do the same thing for <code>serializeFloat</code>, <code>serializeInt</code>, <code>serializeNull</code>, <code>serializeString</code>, <code>serializeVoid</code>, <code>serializeEnum</code>, and <code>serializeSome</code>.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\nContext,\nOk,\nError,\nnull,\nnull,\nnull,\nnull,\nnull,\n.{\n.serializeBool = serializeBool,\n.serializeFloat = serializeNumber,\n.serializeInt = serializeNumber,\n.serializeNull = serializeNothing,\n.serializeString = serializeString,\n.serializeVoid = serializeNothing,\n.serializeEnum = serializeEnum,\n.serializeSome = serializeSome,\n},\n);\nconst Context = @This();\nconst Ok = void;\nconst Error = getty.ser.Error;\nfn serializeBool(_: Context, value: bool) Error!Ok {\nstd.debug.print(\"{}\", .{value});\n}\nfn serializeNumber(_: Context, value: anytype) Error!Ok {\nstd.debug.print(\"{}\", .{value});\n}\nfn serializeString(_: Context, value: anytype) Error!Ok {\nstd.debug.print(\"\\\"{s}\\\"\", .{value});\n}\nfn serializeEnum(c: Context, value: anytype) Error!Ok {\ntry c.serializeString(@tagName(value));\n}\nfn serializeNothing(_: Context) Error!Ok {\nstd.debug.print(\"null\", .{});\n}\nfn serializeSome(c: Context, value: anytype) Error!Ok {\ntry getty.serialize(null, value, c.serializer());\n}\n};\npub fn main() !void {\nconst s = (Serializer{}).serializer();\ninline for (.{ 10, 10.0, \"string\", .variant, {}, null }) |v| {\ntry getty.serialize(null, v, s);\nstd.debug.print(\"\\n\", .{});\n}\n}\n</code></pre> Shell session<pre><code>$ zig build run\n10\n1.0e+01\n\"string\"\n\"variant\"\nnull\nnull\n</code></pre> <p>And there we go, our initial <code>Serializer</code> implementation from before!</p> Method Reuse <p>You can use the same function to implement multiple required methods.</p> <p>For example, we used <code>serializeNumber</code> to implement <code>serializeInt</code> and <code>serializeFloat</code>. We also used <code>serializeNothing</code> to implement <code>serializeNull</code> and <code>serializeVoid</code>.</p> Private Methods <p>Method implementations can be kept private.</p> <p>By marking them private, we avoid polluting the public API of <code>Serializer</code> with interface-related code. Additionally, we ensure that users cannot mistakenly use a value of the implementing type to perform serialization. Instead, they will always be forced to use a <code>getty.Serializer</code> interface value.</p> Type Validation <p>You don't need to validate the <code>value</code> parameter of the <code>serialize*</code> methods.</p> <p>Getty ensures that an appropriate type will be passed to each function. For example, strings will be passed to <code>serializeString</code>, and integers and floating-points will be passed to <code>serializeNumber</code>.</p>"},{"location":"user-guide/tutorial/serializers/#aggregate-serialization","title":"Aggregate Serialization","text":"<p>Now let's take a look at serialization for aggregate types.</p> <p>If you'll recall, <code>getty.Serializer</code> required three associated types from its implementations: <code>Seq</code>, <code>Map</code>, and <code>Structure</code>. Each type is expected to implement one of Getty's aggregate serialization interfaces, which are <code>getty.ser.Seq</code>, <code>getty.ser.Map</code> and <code>getty.ser.Structure</code>.</p> <p>The reason we need <code>Seq</code>, <code>Map</code>, and <code>Structure</code> is because aggregate types have all kinds of different access and iteration patterns, but Getty can't possibly know about all of them. Therefore, the aggregate serialization methods (e.g., <code>serializeSeq</code>) are responsible only for starting the serialization process, before returning a value of either <code>Seq</code>, <code>Map</code>, or <code>Structure</code>. The returned value is then used by the caller to finish serialization in whatever way they want.</p> <p>To give you an example of what I mean, let's implement the <code>serializeSeq</code> method, which returns a value of type <code>Seq</code>, which is expected to implement the <code>getty.ser.Seq</code> interface.</p> getty.ser.Seq Zig code<pre><code>// (1)!\nfn Seq(\ncomptime Context: type,\n// (2)!\ncomptime O: type,\ncomptime E: type,\ncomptime methods: struct {\nserializeElement: ?fn (Context, anytype) E!void = null,\nend: ?fn (Context) E!O = null,\n},\n) type\n</code></pre> <ol> <li> <p>A <code>Seq</code> is responsible for serializing the elements of a Sequence and ending the serialization process for a Sequence.</p> </li> <li> <p><code>O</code> and <code>E</code> must match the <code>O</code> and <code>E</code> values of a corresponding <code>Serializer</code>.</p> </li> </ol> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\nContext,\nOk,\nError,\nnull,\nnull,\nnull,\nSeq,\nnull,\n.{\n.serializeBool = serializeBool,\n.serializeFloat = serializeNumber,\n.serializeInt = serializeNumber,\n.serializeNull = serializeNothing,\n.serializeString = serializeString,\n.serializeVoid = serializeNothing,\n.serializeEnum = serializeEnum,\n.serializeSome = serializeSome,\n.serializeSeq = serializeSeq,\n},\n);\nconst Context = @This();\nconst Ok = void;\nconst Error = getty.ser.Error;\nfn serializeBool(_: Context, value: bool) Error!Ok {\nstd.debug.print(\"{}\", .{value});\n}\nfn serializeNumber(_: Context, value: anytype) Error!Ok {\nstd.debug.print(\"{}\", .{value});\n}\nfn serializeString(_: Context, value: anytype) Error!Ok {\nstd.debug.print(\"\\\"{s}\\\"\", .{value});\n}\nfn serializeEnum(c: Context, value: anytype) Error!Ok {\ntry c.serializeString(@tagName(value));\n}\nfn serializeNothing(_: Context) Error!Ok {\nstd.debug.print(\"null\", .{});\n}\nfn serializeSome(c: Context, value: anytype) Error!Ok {\ntry getty.serialize(null, value, c.serializer());\n}\n// (2)!\nfn serializeSeq(_: Context, len: ?usize) Error!Seq {\n_ = len;\nstd.debug.print(\"[\", .{});\nreturn Seq{};\n}\n};\n// (1)!\nconst Seq = struct {\nfirst: bool = true,\npub usingnamespace getty.ser.Seq(\nContext,\nOk,\nError,\n.{\n.serializeElement = serializeElement,\n.end = end,\n},\n);\nconst Context = *@This();\nconst Ok = Serializer.Ok;\nconst Error = Serializer.Error;\nfn serializeElement(c: Context, value: anytype) Error!void {\n// Prefix element with a comma, if necessary.\nswitch (c.first) {\ntrue =&gt; c.first = false,\nfalse =&gt; std.debug.print(\",\", .{}),\n}\n// Serialize element.\ntry getty.serialize(null, value, (Serializer{}).serializer());\n}\nfn end(_: Context) Error!Ok {\nstd.debug.print(\"]\", .{});\n}\n};\npub fn main() !void {\nconst s = (Serializer{}).serializer();\nvar list = std.ArrayList(i32).init(std.heap.page_allocator);\ndefer list.deinit();\ntry list.append(1);\ntry list.append(2);\ntry list.append(3);\ntry getty.serialize(null, list, s);\nstd.debug.print(\"\\n\", .{});\n}\n</code></pre> <ol> <li> <p>This is our <code>getty.ser.Seq</code> implementation.</p> <p>It specifies how to serialize the elements of and how to end the serialization process for Sequences.</p> </li> <li> <p>Here, we do two things:</p> <ol> <li>Begin serialization by printing <code>[</code>.</li> <li>Return a <code>Seq</code> value for the caller to use to finish off serialization.</li> </ol> </li> </ol> Shell session<pre><code>$ zig build run\n[1,2,3]\n</code></pre> <p>It worked!</p> <p>And notice how we didn't have to write any code specific to the <code>std.ArrayList</code> type in <code>Serializer</code>. We simply specified how sequence serialization should start, how elements should be serialized, and how serialization should end. And Getty took care of the rest!</p> <p>Okay, that leaves us with <code>serializeMap</code> and <code>serializeStruct</code>, which return implementations of <code>getty.ser.Map</code> and <code>getty.ser.Structure</code>, respectively.</p> getty.ser.Map Zig code<pre><code>// (1)!\nfn Map(\ncomptime Context: type,\n// (2)!\ncomptime O: type,\ncomptime E: type,\ncomptime methods: struct {\nserializeKey: ?fn (Context, anytype) E!void = null,\nserializeValue: ?fn (Context, anytype) E!void = null,\nend: ?fn (Context) E!O = null,\n},\n) type\n</code></pre> <ol> <li> <p>A <code>getty.ser.Map</code> is responsible     for serializing the keys and values of a Map and ending the     serialization process for a Map.</p> </li> <li> <p><code>O</code> and <code>E</code> must match the <code>O</code> and <code>E</code> values of a corresponding <code>Serializer</code>.</p> </li> </ol> getty.ser.Structure Zig code<pre><code>// (1)!\nfn Structure(\ncomptime Context: type,\n// (2)!\ncomptime O: type,\ncomptime E: type,\ncomptime methods: struct {\nserializeField: ?fn (Context, comptime []const u8, anytype) E!void = null,\nend: ?fn (Context) E!O = null,\n},\n) type\n</code></pre> <ol> <li> <p>A <code>Structure</code> is responsible for serializing the fields of a Structure and ending the serialization process for a Structure.</p> </li> <li> <p><code>O</code> and <code>E</code> must match the <code>O</code> and <code>E</code> values of a corresponding <code>Serializer</code>.</p> </li> </ol> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\nconst Serializer = struct {\npub usingnamespace getty.Serializer(\nContext,\nOk,\nError,\nnull,\nnull,\nMap,\nSeq,\nMap,\n.{\n.serializeBool = serializeBool,\n.serializeFloat = serializeNumber,\n.serializeInt = serializeNumber,\n.serializeNull = serializeNothing,\n.serializeString = serializeString,\n.serializeVoid = serializeNothing,\n.serializeEnum = serializeEnum,\n.serializeSome = serializeSome,\n.serializeSeq = serializeSeq,\n.serializeMap = serializeMap,\n.serializeStruct = serializeStruct,\n},\n);\nconst Context = @This();\nconst Ok = void;\nconst Error = getty.ser.Error;\nfn serializeBool(_: Context, value: bool) Error!Ok {\nstd.debug.print(\"{}\", .{value});\n}\nfn serializeNumber(_: Context, value: anytype) Error!Ok {\nstd.debug.print(\"{}\", .{value});\n}\nfn serializeString(_: Context, value: anytype) Error!Ok {\nstd.debug.print(\"\\\"{s}\\\"\", .{value});\n}\nfn serializeEnum(s: Context, value: anytype) Error!Ok {\ntry s.serializeString(@tagName(value));\n}\nfn serializeNothing(_: Context) Error!Ok {\nstd.debug.print(\"null\", .{});\n}\nfn serializeSome(c: Context, value: anytype) Error!Ok {\ntry getty.serialize(null, value, c.serializer());\n}\nfn serializeSeq(_: Context, _: ?usize) Error!Seq {\nstd.debug.print(\"[\", .{});\nreturn Seq{};\n}\nfn serializeMap(_: Context, len: ?usize) Error!Map {\n_ = len;\nstd.debug.print(\"{{\", .{});\nreturn Map{};\n}\nfn serializeStruct(c: Context, comptime name: []const u8, len: usize) Error!Map {\n_ = name;\nreturn try c.serializeMap(len);\n}\n};\nconst Seq = struct {\nfirst: bool = true,\npub usingnamespace getty.ser.Seq(\nContext,\nOk,\nError,\n.{\n.serializeElement = serializeElement,\n.end = end,\n},\n);\nconst Context = *@This();\nconst Ok = Serializer.Ok;\nconst Error = Serializer.Error;\nfn serializeElement(c: Context, value: anytype) Error!void {\nswitch (c.first) {\ntrue =&gt; c.first = false,\nfalse =&gt; std.debug.print(\",\", .{}),\n}\ntry getty.serialize(null, value, (Serializer{}).serializer());\n}\nfn end(_: Context) Error!Ok {\nstd.debug.print(\"]\", .{});\n}\n};\nconst Map = struct {\nfirst: bool = true,\npub usingnamespace getty.ser.Map(\nContext,\nOk,\nError,\n.{\n.serializeKey = serializeKey,\n.serializeValue = serializeValue,\n.end = end,\n},\n);\npub usingnamespace getty.ser.Structure(\nContext,\nOk,\nError,\n.{\n.serializeField = serializeField,\n.end = end,\n},\n);\nconst Context = *@This();\nconst Ok = Serializer.Ok;\nconst Error = Serializer.Error;\nfn serializeKey(c: Context, value: anytype) Error!void {\nswitch (c.first) {\ntrue =&gt; c.first = false,\nfalse =&gt; std.debug.print(\",\", .{}),\n}\ntry getty.serialize(null, value, (Serializer{}).serializer());\n}\nfn serializeValue(_: Context, value: anytype) Error!void {\nstd.debug.print(\":\", .{});\ntry getty.serialize(null, value, (Serializer{}).serializer());\n}\nfn serializeField(c: Context, comptime key: []const u8, value: anytype) Error!void {\ntry c.serializeKey(key);\ntry c.serializeValue(value);\n}\nfn end(_: Context) Error!Ok {\nstd.debug.print(\"}}\", .{});\n}\n};\npub fn main() !void {\nconst s = (Serializer{}).serializer();\nvar map = std.StringHashMap(i32).init(std.heap.page_allocator);\ndefer map.deinit();\ntry map.put(\"x\", 1);\ntry map.put(\"y\", 2);\ntry getty.serialize(null, map, s);\nstd.debug.print(\"\\n\", .{});\n}\n</code></pre> Shell session<pre><code>$ zig build run\n{\"x\":1,\"y\":2}\n</code></pre> <p>Hooray!</p> <p>Our JSON serializer is now complete!</p>"},{"location":"user-guide/tutorial/setup/","title":"Setup","text":"<p>To get started, we need to make a new Zig project.</p> <ol> <li> <p>Create a Zig application called <code>getty-learn</code>:</p> <p>Shell session<pre><code>mkdir getty-learn\ncd getty-learn\nzig init-exe\n</code></pre> </p> </li> <li> <p>Declare Getty as a dependency by writing the following in <code>build.zig.zon</code>:</p> <p><code>build.zig.zon</code><pre><code>.{\n.name = \"getty-learn\",\n.version = \"0.1.0\",\n.dependencies = .{\n.getty = .{\n.url = \"https://github.com/getty-zig/getty/archive/main.tar.gz\",\n},\n},\n}\n</code></pre> </p> </li> <li> <p>Expose Getty as a module by adding the following lines to <code>build.zig</code>:</p> <p><code>build.zig</code><pre><code>const std = @import(\"std\");\npub fn build(b: *std.Build) void {\nconst target = b.standardTargetOptions(.{});\nconst optimize = b.standardOptimizeOption(.{});\nconst opts = .{ .target = target, .optimize = optimize };\nconst getty_mod = b.dependency(\"getty\", opts).module(\"getty\");\nconst exe = b.addExecutable(.{\n.name = \"getty-learn\",\n.root_source_file = .{ .path = \"src/main.zig\" },\n.target = target,\n.optimize = optimize,\n});\nexe.addModule(\"getty\", getty_mod);\nexe.install();\n// (snip)\n}\n</code></pre> </p> </li> <li> <p>Obtain Getty's package hash by running <code>zig build</code>:</p> <p>Shell session<pre><code>$ zig build\ngetty-learn/build.zig.zon:6:20: error: url field is missing corresponding hash field\n        .url = \"https://github.com/getty-zig/getty/archive/main.tar.gz\",\n               ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nnote: expected .hash = \"&lt;HASH&gt;\",\n</code></pre> </p> </li> <li> <p>Update <code>build.zig.zon</code> with the obtained hash value:</p> <p><code>build.zig.zon</code><pre><code>.{\n.name = \"getty-learn\",\n.version = \"0.0.0\",\n.dependencies = .{\n.getty = .{\n.url = \"https://github.com/getty-zig/getty/archive/main.tar.gz\",\n.hash = \"&lt;HASH&gt;\",\n},\n},\n}\n</code></pre> </p> </li> <li> <p>To verify everything, replace the contents of <code>src/main.zig</code> with the following code and then run the application:</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\npub fn main() !void {\nstd.debug.print(\"Hello, {}!\\n\", .{getty});\n}\n</code></pre> Shell session<pre><code>$ zig build run\nHello, getty!\n</code></pre> </li> </ol>"}]}