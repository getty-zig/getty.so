{"config":{"lang":["en"],"separator":"[\\s\\-]+"},"docs":[{"title":"Getty","text":"<p>Getty is a framework for building robust, optimal, and reusable (de)serializers in Zig.</p>","location":""},{"title":"Goals","text":"<ul> <li>Minimize the amount of code required for (de)serializer implementations.</li> <li>Enable granular customization of the (de)serialization process.</li> <li>Avoid as much performance overhead as possible.</li> </ul>","location":"#goals"},{"title":"Features","text":"<ul> <li>Compile-time (de)serialization.</li> <li>Out-of-the-box support for a wide variety of standard library types.</li> <li>Local customization of (de)serialization logic for both existing and remote types.</li> <li>Data model abstractions that serve as simple and generic baselines for (de)serializers.</li> </ul>","location":"#features"},{"title":"Quick Start","text":"<p>The following example defines a JSON serializer that supports Booleans and Sequences.</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\nconst allocator = std.heap.page_allocator;\n\nconst Serializer = struct {\n    pub usingnamespace getty.Serializer(\n        Serializer,\n        Ok,\n        Error,\n        null,\n        null,\n        null,\n        Seq,\n        null,\n        .{\n            .serializeBool = serializeBool,\n            .serializeSeq = serializeSeq,\n        },\n    );\n\n    const Ok = void;\n    const Error = error{};\n\n    fn serializeBool(_: Serializer, value: bool) Error!Ok {\n        std.debug.print(\"{}\", .{value});\n    }\n\n    fn serializeSeq(_: Serializer, _: ?usize) Error!Seq {\n        std.debug.print(\"[\", .{});\n        return Seq{};\n    }\n\n    const Seq = struct {\n        first: bool = true,\n\n        pub usingnamespace getty.ser.Seq(\n            *Seq,\n            Ok,\n            Error,\n            .{\n                .serializeElement = serializeElement,\n                .end = end,\n            },\n        );\n\n        fn serializeElement(self: *Seq, value: anytype) Error!void {\n            switch (self.first) {\n                true =&gt; self.first = false,\n                false =&gt; std.debug.print(\", \", .{}),\n            }\n\n            try getty.serialize(value, (Serializer{}).serializer());\n        }\n\n        fn end(_: *Seq) Error!Ok {\n            std.debug.print(\"]\\n\", .{});\n        }\n    };\n};\n\npub fn main() anyerror!void {\n    const s = (Serializer{}).serializer();\n\n    // Primitives\n    try getty.serialize(.{ true, false }, s);\n    try getty.serialize([_]bool{ true, false }, s);\n    try getty.serialize(&amp;&amp;&amp;[_]bool{ true, false }, s);\n    try getty.serialize(@Vector(2, bool){ true, false }, s);\n\n    // std.ArrayList\n    var list = std.ArrayList(bool).init(allocator);\n    defer list.deinit();\n    try list.appendSlice(&amp;.{ true, false });\n    try getty.serialize(list, s);\n\n    // std.BoundedArray\n    var arr = try std.BoundedArray(bool, 2).fromSlice(&amp;.{ true, false });\n    try getty.serialize(arr, s);\n}\n</code></pre> Shell session<pre><code>$ zig build run\n[true, false]\n[true, false]\n[true, false]\n[true, false]\n[true, false]\n[true, false]\n</code></pre>","location":"#quick-start"},{"title":"Blog","text":"","location":"blog/"},{"title":"Concepts","text":"","location":"concepts/"},{"title":"Blocks and Tuples","text":"<p>Blocks are the fundamental building blocks (pun intended) of Getty's (de)serialization process.</p> <p>They define how types should be serialized or deserialized into. For example, all of the ways a <code>bool</code> value can be serialized by Getty are specified in the <code>getty.ser.blocks.Bool</code> block, and all of the ways that you can deserialize into a <code>[5]i32</code> are defined in <code>getty.de.blocks.Array</code>.</p> <p>Internally, Getty uses blocks to form its core (de)serialization behavior. However, they are also the main mechanism for customization in Getty. Both users and (de)serializers can take advantage of blocks in order to customize the way Getty (de)serializes values, as we'll see later on.</p>","location":"concepts/blocks-and-tuples/"},{"title":"Blocks","text":"<p>A block is nothing more than a <code>struct</code> namespace that specifies two things:</p> <ol> <li>The type(s) that should be (de)serialized by the block.</li> <li>How to serialize or deserialize into values of those types.</li> </ol> <p>There are a few different kinds of blocks you can make in Getty, so let's go over them now.</p>","location":"concepts/blocks-and-tuples/#blocks"},{"title":"Serialization Blocks","text":"<p>To manually define the serialization process for a type, you can use a serialization block.</p> Zig code<pre><code>const sb = struct {\n    // (1)!\n    pub fn is(comptime T: type) bool {\n        return T == bool;\n    }\n\n    // (2)!\n    pub fn serialize(value: anytype, serializer: anytype) @TypeOf(serializer).Error!@TypeOf(serializer).Ok {\n        // Convert bool value to a Getty Integer.\n        const v: i32 = if (value) 1 else 0;\n\n        // Pass the Getty Integer value to the serializer.\n        return try serializer.serializeInt(v);\n    }\n};\n</code></pre> <ol> <li> <p><code>is</code> specifies which types can be serialized by the <code>sb</code> block.           In this case, the <code>sb</code> block applies only to <code>bool</code> values.</p> </li> <li> <p><code>serialize</code> specifies how to serialize values relevant to the <code>sb</code> block into Getty's data model.           In this case, we're telling Getty to serialize <code>bool</code> values as Integers.</p> </li> </ol>","location":"concepts/blocks-and-tuples/#serialization-blocks"},{"title":"Deserialization Blocks","text":"<p>To manually define the deserialization process for a type, you can use a deserialization block.</p> Zig code<pre><code>const db = struct {\n    // (1)!\n    pub fn is(comptime T: type) bool {\n        return T == bool;\n    }\n\n    // (2)!\n    pub fn deserialize(\n        allocator: ?std.mem.Allocator,\n        comptime _: type, // (3)!\n        deserializer: anytype,\n        visitor: anytype,\n    ) @TypeOf(deserializer).Error!@TypeOf(visitor).Value {\n        return try deserializer.deserializeInt(allocator, visitor);\n    }\n\n    // (4)!\n    pub fn Visitor(comptime Value: type) type {\n        return struct {\n            pub usingnamespace getty.de.Visitor(\n                @This(),\n                Value,\n                .{ .visitInt = visitInt },\n            );\n\n            pub fn visitInt(\n                _: @This(),\n                allocator: ?std.mem.Allocator,\n                comptime Deserializer: type,\n                input: anytype,\n            ) Deserializer.Error!Value {\n                return input != 0;\n            }\n        };\n    }\n};\n</code></pre> <ol> <li> <p><code>is</code> specifies which types can be deserialized into by the <code>db</code> block.           In this case, the <code>db</code> block applies only to <code>bool</code> values.</p> </li> <li> <p><code>deserialize</code> specifies the hint that Getty should provide a deserializer     about the type being deserialized into.           In this case, we call <code>deserializeInt</code>, which means that Getty will tell     the deserializer that the Zig type being deserialized into can probably be     made from a Getty Integer.</p> </li> <li> <p>This parameter (often named <code>T</code>) is the current type being deserialized into.           Usually, you don't need it unless you're doing pointer deserialization.</p> </li> <li> <p><code>Visitor</code> is a generic type that implements <code>getty.de.Visitor</code>.           Visitors are responsible for specifying how to deserialize values from     Getty's data model into Zig. In this case, our visitor can deserialize     Integers into <code>bool</code> values, which it does by simply returning     whether or not the integer is 0.</p> </li> </ol>","location":"concepts/blocks-and-tuples/#deserialization-blocks"},{"title":"Attribute Blocks","text":"<p>SBs and DBs are typically used for complex modifications to Getty's (de)serialization processes. For simpler customizations, you can usually get away with the more convenient attribute blocks.</p>  <p>Compatibility</p> <p>Attribute blocks may only be defined by <code>struct</code>, <code>enum</code>, and <code>union</code> types.</p>  <p>With ABs, Getty's default (de)serialization processes are used. For example, <code>struct</code> values would be serialized using the default <code>getty.ser.blocks.Struct</code> block and deserialized with the default <code>getty.de.blocks.Struct</code> block. However, based on the attributes that you specify, slight changes to these default processes will take effect.</p>  <p>Support</p> <p>For a complete list of the attributes supported by Getty, see here.</p>  <p>Regardless of whether you're serializing or deserializing, ABs are always defined like so:</p> Zig code<pre><code>const Point = struct {\n    x: i32,\n    y: i32 = 123,\n};\n\nconst ab = struct {\n    pub fn is(comptime T: type) bool {\n        return T == Point;\n    }\n\n    // (1)!\n    pub const attributes = .{ // (2)!\n        .x = .{ .rename = \"X\" }, // (3)!\n        .y = .{ .skip = true },\n    };\n};\n</code></pre> <ol> <li> <p><code>attributes</code> specifies various (de)serialization properties for values    relevant to the <code>ab</code> block.         If <code>ab</code> is used for serialization, then <code>attributes</code> specifies that the <code>x</code>    field of <code>Point</code> should be serialized as <code>\"X\"</code>, and that the <code>y</code> field of    <code>Point</code> should be skipped.         If <code>ab</code> is used for deserialization, then <code>attributes</code> specifies that the    value for the <code>x</code> field of <code>Point</code> has been serialized as <code>\"X\"</code>, and that    the <code>y</code> field of <code>Point</code> should not be deserialized.     </p> </li> <li> <p><code>attributes</code> is an anonymous struct literal.           Each field name in <code>attributes</code> must match either a field or variant in     your <code>struct</code>, <code>enum</code>, or <code>union</code>, or the word     <code>Container</code>. The former are known as field/variant attributes, while     the latter are known as container attributes.</p> </li> <li> <p>Each field in <code>attributes</code> is also an anonymous struct literal. The    fields in these inner <code>struct</code> values depend on the kind of attribute    you're specifying (i.e., field/variant or container).</p> </li> </ol>","location":"concepts/blocks-and-tuples/#attribute-blocks"},{"title":"Type-Defined Blocks","text":"<p>The blocks we've discussed so far are known as out-of-band blocks. They're defined separately from the type(s) that they operate on. Out-of-band blocks have their place, such as when you want to customize a type that you didn't define (e.g., the types in <code>std</code>). However, there's a more convenient way to do things for <code>struct</code>, <code>enum</code>, and <code>union</code> types that you did define yourself.</p> <p>If you define a block within a <code>struct</code>, <code>enum</code>, or <code>union</code>, Getty will automatically process it without you having to pass it to a (de)serializer. All you have to do is make sure the block is public and named <code>@\"getty.sb\"</code> (for serialization) or <code>@\"getty.db\"</code> (for deserialization).</p> <p>Type-defined blocks are defined exactly the same as attribute, serialization, and deserialization blocks are. The only difference is that you don't need an <code>is</code> function in a type-defined block.</p> Zig code<pre><code>const Point = struct {\n    x: i32,\n    y: i32,\n\n    pub const @\"getty.sb\" = struct {\n        pub const attributes = .{\n            .x = .{ .rename = \"X\" },\n            .y = .{ .skip = true },\n        };\n    };\n};\n</code></pre>","location":"concepts/blocks-and-tuples/#type-defined-blocks"},{"title":"Usage","text":"<p>Once you've defined a block, you can pass them along to Getty via the <code>getty.Serializer</code> and <code>getty.Deserializer</code> interfaces. They take optional (de)serialization blocks as arguments.</p> <p>For example, the following defines a serializer that can serialize Booleans and Integers into JSON. It's generic over an SB, which it passes to Getty, making it even easier for us to customize Getty's behavior.</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\nfn Serializer(comptime user_sb: ?type) type {\n    return struct {\n        pub usingnamespace getty.Serializer(\n            @This(),\n            Ok,\n            Error,\n            user_sb orelse null,\n            null,\n            null,\n            null,\n            null,\n            .{\n                .serializeBool = serializeBool,\n                .serializeInt = serializeInt,\n            },\n        );\n\n        const Ok = void;\n        const Error = error{};\n\n        fn serializeBool(_: @This(), value: bool) Error!Ok {\n            std.debug.print(\"{}\\n\", .{value});\n        }\n\n        fn serializeInt(_: @This(), value: anytype) Error!Ok {\n            std.debug.print(\"{}\\n\", .{value});\n        }\n    };\n}\n\nconst sb = struct {\n    pub fn is(comptime T: type) bool {\n        return T == bool;\n    }\n\n    pub fn serialize(value: anytype, serializer: anytype) !@TypeOf(serializer).Ok {\n        const v: i32 = if (value) 1 else 0;\n        return try serializer.serializeInt(v);\n    }\n};\n\npub fn main() anyerror!void {\n    // Normal\n    {\n        var s = Serializer(null){};\n        const serializer = s.serializer();\n\n        try getty.serialize(true, serializer);\n        try getty.serialize(false, serializer);\n    }\n\n    // Custom\n    {\n        var s = Serializer(sb){};\n        const serializer = s.serializer();\n\n        try getty.serialize(true, serializer);\n        try getty.serialize(false, serializer);\n    }\n}\n</code></pre> Shell session<pre><code>$ zig build run\ntrue\nfalse\n1\n0\n</code></pre>","location":"concepts/blocks-and-tuples/#usage"},{"title":"Tuples","text":"<p>In order to pass multiple (de)serialization blocks to Getty, you can use (de)serialization tuples.</p> <p>A (de)serialization tuple is, well, a tuple of (de)serialization blocks. They can be used wherever a (de)serialization block can be used and allow you to do some pretty cool things. For example, suppose you had the following type:</p> Zig code<pre><code>const Point = struct {\n    x: i32,\n    y: i32,\n};\n</code></pre> <p>If all you wanted to do was serialize <code>Point</code> values as Sequences, you'd just write an SB and pass it along to Getty. However, what if you also wanted to serialize <code>i32</code> values as Booleans? One option is to stuff all of your custom serialization logic into a single block. But that gets messy really quick and inevitably becomes a pain to maintain.</p> <p>A much better solution is to break up your serialization logic into separate blocks. One for <code>Point</code> values and one for <code>i32</code> values. Then, you just group them together as a serialization tuple!</p> Zig code<pre><code>const point_sb = struct { ... };\nconst i32_sb = struct { ... };\n\nconst point_st = .{ point_sb, i32_sb };\n</code></pre>","location":"concepts/blocks-and-tuples/#tuples"},{"title":"Data Models","text":"<p>A data model represents a set of types supported by Getty. The types within a data model are purely conceptual; they aren't actually Zig types. For example, there is no <code>i32</code> or <code>u64</code> in either of Getty's data models. Instead, they are both considered to the same type: Integer.</p>","location":"concepts/data-models/"},{"title":"Models","text":"<p>Getty maintains two data models: one for serialization and another for deserialization.</p>  SerializationDeserialization    Boolean  <p>Represented by a <code>bool</code> value.</p>  Enum  <p>Represented by any <code>enum</code> value.</p>  Float  <p>Represented by any floating-point value (<code>comptime_float</code>, <code>f16</code>, <code>f32</code>, <code>f64</code>, <code>f80</code>, <code>f128</code>).</p>  Integer  <p>Represented by any integer value (<code>comptime_int</code>, <code>u0</code> \u2013 <code>u65535</code>, <code>i0</code> \u2013 <code>i65535</code>).</p>  Map  <p>Represented by a <code>getty.ser.Map</code> interface value.</p>  Null  <p>Represented by a <code>null</code> value.</p>  Seq  <p>Represented by a <code>getty.ser.Seq</code> interface value.</p>  Some  <p>Represented by the payload of an optional value.</p>  String  <p>Represented by any string value as determined by <code>std.meta.trait.isZigString</code>.</p>  Structure  <p>Represented by a <code>getty.ser.Structure</code> interface value.</p>  Void  <p>Represented by a <code>void</code> value.</p>      Boolean  <p>Represented by a <code>bool</code> value.</p>  Enum  <p>Represented by any <code>enum</code> value.</p>  Float  <p>Represented by any floating-point value (<code>comptime_float</code>, <code>f16</code>, <code>f32</code>, <code>f64</code>, <code>f80</code>, <code>f128</code>).</p>  Integer  <p>Represented by any integer value (<code>comptime_int</code>, <code>u0</code> \u2013 <code>u65535</code>, <code>i0</code> \u2013 <code>i65535</code>).</p>  Map  <p>Represented by a <code>getty.de.MapAccess</code> interface value.</p>  Null  <p>Represented by a <code>null</code> value.</p>  Seq  <p>Represented by a <code>getty.de.SeqAccess</code> interface value.</p>  Some  <p>Represented by the payload of an optional value.</p>  String  <p>Represented by any string value as determined by <code>std.meta.trait.isZigString</code>.</p>  Union  <p>Represented by a <code>getty.de.UnionAccess</code> interface value and a <code>getty.de.VariantAccess</code> interface value.</p>  Void  <p>Represented by a <code>void</code> value.</p>","location":"concepts/data-models/#models"},{"title":"Motivation","text":"<p>Getty's data models establish a generic baseline from which (de)serializers can operate.</p>  <p> </p>   Interactions <p>Notice how the (de)serializers never interact directly with Zig.</p> <ul> <li>Serializers receive values from Getty's data model and serialize them   into a data format.</li> <li>Deserializers receive values from a data format and deserialize them   into Getty's data model.</li> </ul>  <p>This design often simplifies the job of a (de)serializer significantly. For example, suppose you wanted to serialize <code>[]i32</code>, <code>[100]i32</code>, <code>std.ArrayList(i32)</code>, and <code>std.TailQueue(i32)</code> values. Since Zig considers all of these types to be different, you'd have to write unique serialization logic for all of them (plus integers)!</p> <p>In Getty, you don't have to do nearly as much work. Getty considers all of the aforementioned types to be the same: they are all Sequences. This means that you only have to specify the serialization process for two types: Integers and Sequences. And by doing so, you'll automatically be able to serialize values of any of the aforementioned types, plus any other value whose type is supported by Getty and is considered a Sequence, such as <code>std.SinglyLinkedList</code> and <code>std.BoundedArray</code>.</p>","location":"concepts/data-models/#motivation"},{"title":"Interfaces","text":"<p>When building a (de)serializer in Getty, you will eventually have to implement an interface.</p> <p>Unfortunately, interfaces in Zig are a userspace thing so everyone has their own way of doing things. So, let's quickly go over how Getty implements interfaces and how you can use them.</p>","location":"concepts/interfaces/"},{"title":"Definition","text":"<p>A Getty interface is a function, and its constraints are specified as a parameter list. For instance, the following interface requires 3 associated types and 1 method from its implementations.</p> Zig code<pre><code>// (1)!\nfn BoolSerializer(\n    // (2)!\n    comptime Context: type,\n    comptime O: type,\n    comptime E: type,\n\n    // (3)!\n    comptime methods: struct {\n        serializeBool: ?fn (Context, bool) E!O = null,\n    },\n) type\n</code></pre> <ol> <li> <p>This function is an interface similar to the ones defined in Getty.</p> </li> <li> <p>These parameters are associated types that implementations of <code>BoolSerializer</code> must provide.</p> </li> <li> <p>This parameter contains the methods that implementations of <code>BoolSerializer</code> must or can provide.</p> <p>If a method is not provided by an implementation, it is up to the interface to decide what happens. Generally, a compile error is raised or an error is returned.</p> </li> </ol> <p>The return value of a Getty interface is a <code>struct</code> namespace that contains two declarations: an interface type and an interface function. A value of the interface type is an interface value.</p> Zig code<pre><code>fn BoolSerializer(\n    comptime Context: type,\n    comptime O: type,\n    comptime E: type,\n    comptime methods: struct {\n        serializeBool: ?fn (Context, bool) E!O = null,\n    },\n) type {\n    return struct {\n        // (2)!\n        pub const Interface = struct {\n            context: Context,\n\n            pub const Ok = O;\n            pub const Error = E;\n\n            pub fn serializeBool(self: @This(), value: bool) Error!Ok {\n                if (methods.serializeBool) |f| {\n                    return try f(self.context, value);\n                }\n\n                @compileError(\"serializeBool is unimplemented\");\n            }\n        };\n\n        // (1)!\n        pub fn boolSerializer(self: Context) Interface {\n            return .{ .context = self };\n        }\n    };\n}\n</code></pre> <ol> <li> <p>This function is an interface function. Its job is to return an interface value.</p> </li> <li> <p>This declaration is an interface type. They generally have:</p> <ul> <li>A single field to store an instance of an implementation.</li> <li>A few declarations that may be useful to implementations.</li> <li>Wrapper methods that define the interface's behavior.</li> </ul> </li> </ol>    <p>Naming Conventions</p> <ul> <li> <p>Interface types are always named after the interface's import path. For   example, the interface type for the   <code>getty.de.SeqAccess</code>   interface is named <code>@\"getty.de.SeqAccess\"</code>.</p> </li> <li> <p>Interface functions are always named after the interface (in   <code>camelCase</code> format). For example, the interface type for the   <code>getty.de.SeqAccess</code>   interface is named <code>seqAccess</code>.</p> </li> </ul>","location":"concepts/interfaces/#definition"},{"title":"Implementation","text":"<p>To implement a Getty interface, call the interface and apply <code>usingnamespace</code> to its return value. This will import an interface type and interface function into your implementation.</p> Zig code<pre><code>const std = @import(\"std\");\n\nconst UselessSerializer = struct {\n    usingnamespace BoolSerializer(\n        @This(),\n        void,\n        error{},\n        .{},\n    );\n};\n\nconst OppositeSerializer = struct {\n    usingnamespace BoolSerializer(\n        Context,\n        Ok,\n        Error,\n        .{ .serializeBool = serializeBool },\n    );\n\n    const Context = @This();\n    const Ok = void;\n    const Error = error{};\n\n    fn serializeBool(_: Context, value: bool) Error!Ok {\n        std.debug.print(\"{}\\n\", .{!value});\n    }\n};\n</code></pre>","location":"concepts/interfaces/#implementation"},{"title":"Usage","text":"<p>To use a value of, say <code>OppositeSerializer</code>, as an implementation of <code>BoolSerializer</code>:</p> Zig code<pre><code>pub fn main() anyerror!void {\n    const os = OppositeSerializer{}; // (1)!\n    const bs = os.boolSerializer();  // (2)!\n\n    // (3)!\n    try bs.serializeBool(true);\n    try bs.serializeBool(false);\n}\n</code></pre> <ol> <li>Create a value of the implementing type, <code>OppositeSerializer</code>.</li> <li>Create an interface value from your implementation using the interface function.</li> <li>Use the interface value for all of your interface-y needs!</li> </ol> Shell session<pre><code>$ zig build run\nfalse\ntrue\n</code></pre>","location":"concepts/interfaces/#usage"},{"title":"Values","text":"","location":"concepts/values/"},{"title":"Serialization","text":"<p>How a Zig value is represented within a data format is determined entirely by whichever Getty serializer you use. Therefore, it's important that you check how a serialization library is handling things before you start using it. As an example, here's how the Getty JSON library does things:</p> Shell session<pre><code>const a = {};                        // serialized as null\nconst b = \"foobar\";                  // serialized as \"foobar\"\nconst c = .foobar;                   // serialized as \"foobar\"\nconst d = .{ 1, 2, 3 };              // serialized as [1,2,3]\nconst e = .{ .x = 1, .y = 2 };       // serialized as {\"x\":1,\"y\":2}\nconst F = union(enum) { foo: i32 };\nconst f = U{ .foo = 1 };             // serialized as {\"foo\":1}\n</code></pre>","location":"concepts/values/#serialization"},{"title":"Deserialization","text":"<p>Similarly, it is up to a Getty deserializer to determine how values within a data format should be parsed and deserialized. For instance, the Getty JSON library has no issues converting the JSON object <code>{\"foo\":1}</code> into a tagged union. However, other deserializers may expect something different from their input data when deserializing into a union value.</p>","location":"concepts/values/#deserialization"},{"title":"Contributing","text":"<p>Contributions to Getty are very welcome! \ud83d\ude04</p> <p>This page contains some information and a few guidelines to help get you started. If you have any questions about contributing or Getty, feel free to reach out on the Getty Discord.</p>","location":"contributing/"},{"title":"Zig","text":"<ul> <li>Getty currently tracks the <code>master</code> release of Zig, so make sure your version is updated.</li> </ul>","location":"contributing/#zig"},{"title":"Workflow","text":"<p>Getty uses the Git Flow model for its development. Essentially, what that means is:</p> <ul> <li> <p>The <code>main</code> branch is strictly for releases. Do not work on or branch off of it.</p> </li> <li> <p>The <code>develop</code> branch is an integration branch for features and fixes. Do not work on it.</p> </li> <li> <p>Features are developed on <code>feature/&lt;name&gt;</code> branches, which branch off of <code>develop</code>.</p> </li> <li> <p>Fixes are developed on <code>fix/&lt;name&gt;</code> branches, which branch off of <code>develop</code>.</p> </li> </ul>","location":"contributing/#workflow"},{"title":"Issues","text":"<ul> <li> <p>GitHub Issues are used exclusively for tracking bugs and feature requests for Getty.</p> </li> <li> <p>When filing an issue, please provide a brief explanation on how to reproduce your issue.</p> </li> <li> <p>When filing a feature request, please check if the latest version of Getty already implements the feature beforehand and whether there's already an issue filed for your feature.</p> </li> </ul>","location":"contributing/#issues"},{"title":"Pull Requests","text":"<ul> <li> <p>Please follow our Style Guide whenever contributing code.</p> </li> <li> <p>Before submitting a PR, please test your changes and ensure that the test suite passes locally.</p> </li> <li> <p>When submitting a PR, please have it be relative to a recent Git tip.</p> </li> <li> <p>If you push a new version of a PR, please add a comment about the new   version. Notifications aren't sent for commits, so it's easy to miss updates   without an explicit comment.</p> </li> </ul>","location":"contributing/#pull-requests"},{"title":"Style Guide","text":"<p>This document describes the coding style that all new code for Getty should try to conform to.</p>","location":"contributing/style-guide/"},{"title":"Formatting","text":"<ul> <li> <p>All code should be formatted by <code>zig fmt</code>. If your code isn't properly formatted, the CI will fail.</p> </li> <li> <p>When writing a comment, use <code>///</code> for public API descriptions and <code>//</code> for everything else.</p> </li> <li> <p>Try to limit lines to 100 characters. It's okay to go over though, so long as things are readable.</p> </li> </ul>","location":"contributing/style-guide/#formatting"},{"title":"Naming","text":"<ul> <li>Follow the naming conventions listed here.</li> </ul>","location":"contributing/style-guide/#naming"},{"title":"Getting Started","text":"<p>If you've ever written a Zig (de)serializer before, you probably wrote a function that took a value, switched on its type, and (de)serialized based on the resulting type information. You might have even called it <code>std.json</code>, as that's exactly how the module works! Unfortunately, this approach is quite brittle, inflexible, and usually ends up being a lot of unnecessary work.</p> <p>The goal of Getty is to help you avoid all of that and reduce the amount of code you need to write a (de)serializer that is customizable, performant, and able to support a wide variety of data types!</p>","location":"getting-started/"},{"title":"Architecture","text":"<p>At a high-level, Getty consists of two flows: one for serialization and another for deserialization.</p>  SerializationDeserialization   <ol> <li>A Zig value is passed to Getty.</li> <li>Based on the value's type, a serialization block is selected and executed by Getty.</li> <li>The block serializes the passed-in value into Getty's data model.</li> <li>The resulting value is passed to a Serializer, which serializes it into an output data format.</li> </ol>   <ol> <li>A Zig type is passed to Getty.</li> <li>Based on the type, a deserialization block is selected and executed by Getty.</li> <li>The block prompts a Deserializer to deserialize its input data into Getty's data model.</li> <li>The resulting value is passed to a Visitor, which converts it into a Zig value of the initial type.</li> </ol>      <p> </p>","location":"getting-started/#architecture"},{"title":"Installation","text":"<p>To install Getty for your project, you can use any of the methods listed on this page.</p>","location":"getting-started/installation/"},{"title":"Manual","text":"<p>Prerequisites</p> <p>These steps assume that you have the <code>master</code> version of Zig installed.</p>  <ol> <li> <p>Add Getty to your project.</p> Shell session<pre><code>git clone https://github.com/getty-zig/getty lib/getty\n</code></pre> </li> <li> <p>Make the following change in <code>build.zig</code>.</p> <code>build.zig</code><pre><code>const std = @import(\"std\");\n\npub fn build(b: *std.build.Builder) void {\n    // ...\n\n    const exe = b.addExecutable(\"getty-learn\", \"src/main.zig\");\n    exe.setTarget(target);\n    exe.setBuildMode(mode);\n    exe.addPackagePath(\"getty\", \"lib/getty/src/getty.zig\");\n    exe.install();\n}\n</code></pre> </li> </ol>","location":"getting-started/installation/#manual"},{"title":"Gyro","text":"<p>Prerequisites</p> <p>These steps assume that you have the <code>master</code> version of Zig and the Gyro package manager installed.</p>  <ol> <li> <p>Add Getty to your project.</p> Shell session<pre><code>gyro add -s github getty-zig/getty\ngyro fetch\n</code></pre> </li> <li> <p>Make the following changes in <code>build.zig</code>.</p> <code>build.zig</code><pre><code>const std = @import(\"std\");\nconst pkgs = @import(\"deps.zig\").pkgs;\n\npub fn build(b: *std.build.Builder) void {\n    // ...\n\n    const exe = b.addExecutable(\"getty-learn\", \"src/main.zig\");\n    exe.setTarget(target);\n    exe.setBuildMode(mode);\n    pkgs.addAllTo(exe);\n    exe.install();\n}\n</code></pre> </li> </ol>","location":"getting-started/installation/#gyro"},{"title":"Zigmod","text":"<p>Prerequisites</p> <p>These steps assume that you have the <code>master</code> version of Zig and the Zigmod package manager installed.</p>  <ol> <li> <p>Make the following changes in <code>zigmod.yml</code>.</p> <code>zigmod.yml</code><pre><code># ...\n\nroot_dependencies:\n  - src: git https://gitub.com/getty-zig/getty\n</code></pre> </li> <li> <p>Add Getty to your project.</p> Shell session<pre><code>zigmod fetch\n</code></pre> </li> <li> <p>Make the following changes in <code>build.zig</code>.</p> <code>build.zig</code><pre><code>const std = @import(\"std\");\nconst deps = @import(\"deps.zig\");\n\npub fn build(b: *std.build.Builder) void {\n    // ...\n\n    const exe = b.addExecutable(\"getty-learn\", \"src/main.zig\");\n    exe.setTarget(target);\n    exe.setBuildMode(mode);\n    deps.addAllTo(exe);\n    exe.install();\n}\n</code></pre> </li> </ol>","location":"getting-started/installation/#zigmod"},{"title":"Guide","text":"<p>This is the official guide for the Getty framework, and is designed to serve as both:</p> <ul> <li>An introduction to writing serializers and deserializers with Getty.</li> <li>A reference for more experienced Getty developers.</li> </ul>","location":"getting-started/guide/"},{"title":"Customization","text":"<p>So far, Getty has taken care of all of the little (de)serialization details for us behind the scenes. But sometimes, you need more control. That's where Getty's customization features come in.</p> <p>Getty allows both users and (de)serializers to customize the (de)serialization process for types that you've defined yourself, as well as for types that you didn't define such as those in the standard library. Moreover, the customization enabled by Getty can be used in a local manner. That is, you can serialize a <code>bool</code> value as a String in one function and as an Integer in another, all without having to convert the value to a new or intermediate type.</p> <p>Customization in Getty revolves around Blocks and Tuples, which can be passed to Getty via the <code>getty.Serializer</code> or <code>getty.Deserializer</code> interfaces.</p>","location":"getting-started/guide/customization/"},{"title":"Out-of-Band Customization","text":"<p>Here, we define a serialization block that serializes <code>bool</code> values as Integers.</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\n// (1)!\nconst Serializer = struct {\n    pub usingnamespace getty.Serializer(\n        @This(),\n        Ok,\n        Error,\n        block, // (2)!\n        null,\n        null,\n        null,\n        null,\n        .{ .serializeInt = serializeInt },\n    );\n\n    const Ok = void;\n    const Error = error{};\n\n    fn serializeInt(_: @This(), value: anytype) Error!Ok {\n        std.debug.print(\"{}\\n\", .{value});\n    }\n};\n\nconst block = struct {\n    // (3)!\n    pub fn is(comptime T: type) bool {\n        return T == bool;\n    }\n\n    // (4)!\n    pub fn serialize(value: anytype, serializer: anytype) !@TypeOf(serializer).Ok {\n        const v: i32 = if (value) 1 else 0;\n        return try serializer.serializeInt(v);\n    }\n};\n\npub fn main() anyerror!void {\n    const s = (Serializer{}).serializer();\n\n    try getty.serialize(true, s);\n    try getty.serialize(false, s);\n}\n</code></pre> <ol> <li> <p>This serializer only knows how to serialize Integers.</p> </li> <li> <p>With <code>block</code> being passed to Getty, <code>bool</code> values will now be     serialized into Getty's data model as Integers, which, of course, is a     type that <code>Serializer</code> knows how to serialize.</p> </li> <li> <p><code>is</code> specifies which types <code>block</code> applies to.</p> </li> <li> <p><code>serialize</code> specifies how to serialize values relevant to <code>block</code>.</p> <p>In this case, we serialize the incoming <code>bool</code> value as an Integer before passing it on to the serializer.</p> </li> </ol> Shell session<pre><code>$ zig build run\n1\n0\n</code></pre> <p>We can also make <code>Serializer</code> generic over a BT to make customization even easier for users.</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\nfn Serializer(comptime user_sbt: anytype) type {\n    return struct {\n        pub usingnamespace getty.Serializer(\n            @This(),\n            Ok,\n            Error,\n            user_sbt,\n            null,\n            null,\n            null,\n            null,\n            .{\n                .serializeInt = serializeInt,\n                .serializeString = serializeString,\n            },\n        );\n\n        const Ok = void;\n        const Error = error{};\n\n        fn serializeInt(_: @This(), value: anytype) Error!Ok {\n            std.debug.print(\"{}\\n\", .{value});\n        }\n\n        fn serializeString(_: @This(), value: anytype) Error!Ok {\n            std.debug.print(\"\\\"{s}\\\"\\n\", .{value});\n        }\n    };\n}\n\nconst int_block = struct {\n    pub fn is(comptime T: type) bool {\n        return T == bool;\n    }\n\n    pub fn serialize(value: anytype, serializer: anytype) !@TypeOf(serializer).Ok {\n        const v: i32 = if (value) 1 else 0;\n        return try serializer.serializeInt(v);\n    }\n};\n\nconst string_block = struct {\n    pub fn is(comptime T: type) bool {\n        return T == bool;\n    }\n\n    pub fn serialize(value: anytype, serializer: anytype) !@TypeOf(serializer).Ok {\n        const v = if (value) \"true\" else \"false\";\n        return try serializer.serializeString(v);\n    }\n};\n\npub fn main() anyerror!void {\n    // Integer\n    {\n        const s = (Serializer(int_block){}).serializer();\n\n        try getty.serialize(true, s);\n        try getty.serialize(false, s);\n    }\n\n    // String\n    {\n        const s = (Serializer(string_block){}).serializer();\n\n        try getty.serialize(true, s);\n        try getty.serialize(false, s);\n    }\n}\n</code></pre> Shell session<pre><code>$ zig build run\n1\n0\n\"true\"\n\"false\"\n</code></pre>","location":"getting-started/guide/customization/#out-of-band-customization"},{"title":"In-Band Customization","text":"<p>Out-of-band customization has its uses, such as when you want to customize a type that you didn't define. However, there's a more convenient way to do things for <code>struct</code>, <code>enum</code>, and <code>union</code> types that you did define yourself.</p> <p>If you define a BT within a <code>struct</code>, <code>enum</code>, or <code>union</code>, Getty will automatically process it without you having to pass it in directly through a (de)serializer. Just make sure the BT is public and named either <code>@\"getty.sbt\"</code> or <code>@\"getty.dbt\"</code> (<code>sbt</code> for serialization, <code>dbt</code> for deserialization).</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\nconst Point = struct {\n    x: i32,\n    y: i32,\n\n    pub const @\"getty.sb\" = struct {\n        pub const attributes = .{\n            .x = .{ .rename = \"X\" },\n            .y = .{ .skip = true },\n        };\n    };\n};\n\nconst Serializer = struct {\n    pub usingnamespace getty.Serializer(\n        @This(),\n        Ok,\n        Error,\n        null,\n        null,\n        null,\n        null,\n        Struct,\n        .{\n            .serializeInt = serializeInt,\n            .serializeString = serializeString,\n            .serializeStruct = serializeStruct,\n        },\n    );\n\n    const Ok = void;\n    const Error = error{};\n\n    fn serializeInt(_: @This(), value: anytype) Error!Ok {\n        std.debug.print(\"{}\", .{value});\n    }\n\n    fn serializeString(_: @This(), value: anytype) Error!Ok {\n        std.debug.print(\"\\\"{s}\\\"\", .{value});\n    }\n\n    fn serializeStruct(_: @This(), comptime _: []const u8, _: usize) Error!Struct {\n        std.debug.print(\"{{\", .{});\n\n        return Struct{};\n    }\n};\n\nconst Struct = struct {\n    first: bool = true,\n\n    pub usingnamespace getty.ser.Structure(\n        *@This(),\n        Ok,\n        Error,\n        .{\n            .serializeField = serializeField,\n            .end = end,\n        },\n    );\n\n    const Ok = Serializer.Ok;\n    const Error = Serializer.Error;\n\n    fn serializeField(self: *@This(), comptime key: []const u8, value: anytype) Error!void {\n        // Serialize key.\n        switch (self.first) {\n            true =&gt; self.first = false,\n            false =&gt; std.debug.print(\", \", .{}),\n        }\n        try getty.serialize(key, (Serializer{}).serializer());\n\n        // Serialize value.\n        std.debug.print(\": \", .{});\n        try getty.serialize(value, (Serializer{}).serializer());\n    }\n\n    fn end(_: *@This()) Error!Ok {\n        std.debug.print(\"}}\\n\", .{});\n    }\n};\n\npub fn main() anyerror!void {\n    const v = Point{ .x = 1, .y = 2 };\n    const s = (Serializer{}).serializer();\n\n    try getty.serialize(v, s);\n}\n</code></pre> Shell session<pre><code>$ zig build run\n{\"X\": 1}\n</code></pre>","location":"getting-started/guide/customization/#in-band-customization"},{"title":"Deserializers","text":"<p>Let's write a simple (albeit slightly naive) JSON deserializer.</p>  <p>Prerequisites</p> <p>This page assumes you understand how Getty interfaces work. If not, take a few minutes to learn about them here.</p>","location":"getting-started/guide/deserializers/"},{"title":"Prologue","text":"<p>To begin, we'll go over how deserialization works in Getty.</p>  <p> </p>  <ol> <li>A Zig type is passed to Getty.</li> <li>Based on the type, a deserialization block is    selected and executed by Getty.</li> <li> <p>The DB prompts a Deserializer    to deserialize its input data into Getty's data    model.</p> <ul> <li>This is done by calling one of the deserializer's methods (e.g., <code>deserializeBool</code>).</li> </ul> </li> <li> <p>The resulting value is passed to a    Visitor, which converts it into a    Zig value of the initial type.</p> <ul> <li>This is done by calling one of the visitor's methods (e.g., <code>visitBool</code>).</li> </ul> </li> </ol>  Example <p>Here's how deserializing a <code>std.ArrayList(i32)</code> works:</p> <ol> <li><code>std.ArrayList(i32)</code> is passed to Getty.</li> <li>Getty selects and executes the    <code>getty.de.blocks.ArrayList</code>    deserialization block.</li> <li>The DB prompts a Deserializer to deserialize its input data into a Sequence.</li> <li>The resulting Sequence is passed to a Visitor, which converts it into a <code>std.ArrayList(i32)</code>.</li> </ol>   <p>TL;DR</p> <ul> <li>Deserializers deserialize from a data format into Getty's data model.</li> <li>Visitors deserialize from Getty's data model into Zig.</li> </ul>","location":"getting-started/guide/deserializers/#prologue"},{"title":"Scalar Deserialization","text":"<p>Every Getty deserializer must implement the <code>getty.Deserializer</code> interface, shown below.</p> Zig code<pre><code>// (1)!\nfn Deserializer(\n    comptime Context: type, // (2)!\n    comptime E: type, // (3)!\n\n    // (4)!\n    comptime user_dbt: anytype,\n    comptime deserializer_dbt: anytype,\n\n    // (5)!\n    comptime methods: struct {\n        // (6)!\n        deserializeAny: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\n        deserializeBool: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\n        deserializeEnum: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\n        deserializeFloat: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\n        deserializeIgnored: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\n        deserializeInt: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\n        deserializeMap: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\n        deserializeOptional: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\n        deserializeSeq: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\n        deserializeString: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\n        deserializeStruct: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\n        deserializeUnion: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\n        deserializeVoid: ?fn (Context, ?std.mem.Allocator, v: anytype) E!@TypeOf(v).Value = null,\n    },\n) type\n</code></pre> <ol> <li> <p>A <code>getty.Deserializer</code> deserializes     values from a data format into Getty's data model.</p> </li> <li> <p><code>Context</code> is the namespace that owns the method implementations passed to     the <code>methods</code> parameter.</p> <p>Usually, this is the type implementing <code>getty.Deserializer</code> or a pointer to it if mutability is required.</p> </li> <li> <p><code>E</code> is the error set returned by     <code>getty.Deserializer</code>'s methods upon     failure.</p> <p>The value of <code>E</code> must contain <code>getty.de.Error</code>, a base error set defined by Getty.</p> </li> <li> <p><code>user_dbt</code> and <code>deserializer_dbt</code> are optional user- and deserializer-defined     derialization blocks or tuples, respectively.</p> <p>They allow users and deserializers to customize Getty's deserialization behavior. If user- or deserializer-defined customization isn't supported, <code>null</code> can be passed in for these parameters.</p> </li> <li> <p><code>methods</code> contains all of the methods that implementations of     <code>getty.Deserializer</code> must     provide or can override.</p> </li> <li> <p>These methods are responsible for deserializing into a specific type in     Getty's data model from a data format.</p> <p>The <code>v</code> parameter in these methods is a <code>getty.de.Visitor</code> interface value.</p> <p>The <code>deserializeAny</code> and <code>deserializeIgnored</code> methods are pretty niche, so we'll just ignore them for this tutorial.</p> </li> </ol> <p>Quite the parameter list!</p> <p>Luckily, most of the parameters have default values we can use. So, let's start with the following:</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\nconst Deserializer = struct {\n    tokens: std.json.TokenStream, // (1)!\n\n    const Self = @This();\n\n    pub usingnamespace getty.Deserializer(\n        *Self,\n        Error,\n        null,\n        null,\n        .{},\n    );\n\n    const Error = getty.de.Error ||\n        std.json.TokenStream.Error ||\n        std.fmt.ParseIntError ||\n        std.fmt.ParseFloatError;\n\n    const De = Self.@\"getty.Deserializer\"; // (2)!\n\n    pub fn init(json: []const u8) Self {\n        return .{ .tokens = std.json.TokenStream.init(json) };\n    }\n};\n</code></pre> <ol> <li> <p>A JSON parser provided by the standard library.</p> </li> <li> <p>A convenient alias for our <code>getty.Deserializer</code> interface type.</p> </li> </ol> <p>Bit of a useless deserializer, but let's try deserializing a value with it anyways. We can do so by calling <code>getty.deserialize</code>, which takes an optional allocator, a type to deserialize into, and a <code>getty.Deserializer</code> interface value.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\nconst Deserializer = struct {\n    tokens: std.json.TokenStream,\n\n    const Self = @This();\n\n    pub usingnamespace getty.Deserializer(\n        *Self,\n        Error,\n        null,\n        null,\n        .{},\n    );\n\n    const Error = getty.de.Error ||\n        std.json.TokenStream.Error ||\n        std.fmt.ParseIntError ||\n        std.fmt.ParseFloatError;\n\n    const De = Self.@\"getty.Deserializer\";\n\n    pub fn init(json: []const u8) Self {\n        return .{ .tokens = std.json.TokenStream.init(json) };\n    }\n};\n\npub fn main() anyerror!void {\n    const s = \"true\";\n\n    var d = Deserializer.init(s);\n    const deserializer = d.deserializer();\n\n    const v = try getty.deserialize(null, bool, deserializer);\n\n    std.debug.print(\"{} ({})\\n\", .{ v, @TypeOf(v) });\n}\n</code></pre> Shell session<pre><code>$ zig build run\n[...] error:  deserializeBool is not implemented by type: *main.Deserializer\n</code></pre> <p>Oh no, a compile error!</p> <p>Looks like Getty can't deserialize into the <code>bool</code> type for us unless the <code>deserializeBool</code> method is implemented. So, let's implement it real quick.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\nconst Allocator = std.mem.Allocator;\n\nconst Deserializer = struct {\n    tokens: std.json.TokenStream,\n\n    const Self = @This();\n\n    pub usingnamespace getty.Deserializer(\n        *Self,\n        Error,\n        null,\n        null,\n        .{\n            .deserializeBool = deserializeBool,\n        },\n    );\n\n    const Error = getty.de.Error ||\n        std.json.TokenStream.Error ||\n        std.fmt.ParseIntError ||\n        std.fmt.ParseFloatError;\n\n    const De = Self.@\"getty.Deserializer\";\n\n    pub fn init(json: []const u8) Self {\n        return .{ .tokens = std.json.TokenStream.init(json) };\n    }\n\n    // (1)!\n    fn deserializeBool(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n        if (try self.tokens.next()) |token| {\n            if (token == .True or token == .False) {\n                return try v.visitBool(allocator, De, token == .True);\n            }\n        }\n\n        return error.InvalidType;\n    }\n};\n\npub fn main() anyerror!void {\n    const s = \"true\";\n\n    var d = Deserializer.init(s);\n    const deserializer = d.deserializer();\n\n    const v = try getty.deserialize(null, bool, deserializer);\n\n    std.debug.print(\"{} ({})\\n\", .{ v, @TypeOf(v) });\n}\n</code></pre> <ol> <li> <p>All we're doing in this function is:</p> <ol> <li>Parsing a token from the JSON data.</li> <li>Checking to see if the token is a JSON Boolean.</li> <li>Deserializing the token into a Boolean (<code>token == .True</code>).</li> <li>Passing the Boolean to the visitor, <code>v</code>.</li> </ol> </li> </ol> Shell session<pre><code>$ zig build run\ntrue (bool)\n</code></pre> <p>Success!</p>        <p>Now let's do the same thing for <code>deserializeEnum</code>, <code>deserializeFloat</code>, <code>deserializeInt</code>, <code>deserializeOptional</code>, <code>deserializeString</code>, and <code>deserializeVoid</code>.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\nconst Allocator = std.mem.Allocator;\n\nconst Deserializer = struct {\n    tokens: std.json.TokenStream,\n\n    const Self = @This();\n\n    pub usingnamespace getty.Deserializer(\n        *Self,\n        Error,\n        null,\n        null,\n        .{\n            .deserializeBool = deserializeBool,\n            .deserializeEnum = deserializeEnum,\n            .deserializeFloat = deserializeFloat,\n            .deserializeInt = deserializeInt,\n            .deserializeString = deserializeString,\n            .deserializeVoid = deserializeVoid,\n            .deserializeOptional = deserializeOptional,\n        },\n    );\n\n    const Error = getty.de.Error ||\n        std.json.TokenStream.Error ||\n        std.fmt.ParseIntError ||\n        std.fmt.ParseFloatError;\n\n    const De = Self.@\"getty.Deserializer\";\n\n    pub fn init(json: []const u8) Self {\n        return .{ .tokens = std.json.TokenStream.init(json) };\n    }\n\n    fn deserializeBool(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n        if (try self.tokens.next()) |token| {\n            if (token == .True or token == .False) {\n                return try v.visitBool(allocator, De, token == .True);\n            }\n        }\n\n        return error.InvalidType;\n    }\n\n    // (1)!\n    fn deserializeEnum(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n        if (try self.tokens.next()) |token| {\n            if (token == .String) {\n                const str = token.String.slice(self.tokens.slice, self.tokens.i - 1);\n                return try v.visitString(allocator, De, str);\n            }\n        }\n\n        return error.InvalidType;\n    }\n\n    fn deserializeFloat(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n        if (try self.tokens.next()) |token| {\n            if (token == .Number) {\n                const str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\n                return try v.visitFloat(allocator, De, try std.fmt.parseFloat(f64, str));\n            }\n        }\n\n        return error.InvalidType;\n    }\n\n    fn deserializeInt(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n        if (try self.tokens.next()) |token| {\n            if (token == .Number) {\n                const str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\n\n                if (token.Number.is_integer) {\n                    return try switch (str[0]) {\n                        '-' =&gt; v.visitInt(allocator, De, try std.fmt.parseInt(i64, str, 10)),\n                        else =&gt; v.visitInt(allocator, De, try std.fmt.parseInt(u64, str, 10)),\n                    };\n                }\n            }\n        }\n\n        return error.InvalidType;\n    }\n\n    fn deserializeString(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n        if (try self.tokens.next()) |token| {\n            if (token == .String) {\n                const str = token.String.slice(self.tokens.slice, self.tokens.i - 1);\n                return try v.visitString(allocator, De, try allocator.?.dupe(u8, str));\n            }\n        }\n\n        return error.InvalidType;\n    }\n\n    fn deserializeVoid(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n        if (try self.tokens.next()) |token| {\n            if (token == .Null) {\n                return try v.visitVoid(allocator, De);\n            }\n        }\n\n        return error.InvalidType;\n    }\n\n    // (2)!\n    fn deserializeOptional(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n        const backup = self.tokens;\n\n        if (try self.tokens.next()) |token| {\n            if (token == .Null) {\n                return try v.visitNull(allocator, De);\n            }\n\n            self.tokens = backup;\n            return try v.visitSome(allocator, self.deserializer());\n        }\n\n        return error.InvalidType;\n    }\n};\n\npub fn main() anyerror!void {\n    const allocator = std.heap.page_allocator;\n    const types = .{ i32, f32, []u8, enum { foo }, ?u8, void };\n    const jsons = .{ \"10\", \"10.0\", \"\\\"ABC\\\"\", \"\\\"foo\\\"\", \"null\", \"null\" };\n\n    inline for (jsons) |s, i| {\n        const T = types[i];\n\n        var d = Deserializer.init(s);\n        const deserializer = d.deserializer();\n\n        const v = try getty.deserialize(allocator, T, deserializer);\n        defer getty.de.free(allocator, v);\n\n        std.debug.print(\"{any} ({})\\n\", .{ v, @TypeOf(v) });\n    }\n}\n</code></pre> <ol> <li> <p>Just like in <code>deserializeBool</code>, all we're doing here is parsing tokens,     turning them into Getty values, and passing those values to a visitor.</p> <p>By the way, you'll see <code>token.X.slice</code> come up pretty often in our deserializer. All it's doing is getting the string that corresponds to our token from the JSON data.</p> </li> <li> <p><code>deserializeOptional</code> is a bit different from the other methods. Instead of     passing a Getty value to a visitor, you pass a deserializer to <code>visitSome</code>.     The visitor will then restart the deserialization process using the     optional's payload.</p> <p>In other words, you can think of this method as a place to do some pre-processing before deserializing an actual payload value.</p> </li> </ol> Shell session<pre><code>$ zig build run\n10 (i32)\n1.0e+01 (f32)\n{ 65, 66, 67 } ([]u8)\nmain.main__enum_1315.foo (main.main__enum_1315)\nnull (?u8)\nvoid (void)\n</code></pre> <p>Not too shabby! \ud83e\udd29</p>  The <code>deserialize*</code> methods <p>When Getty calls <code>deserializeBool</code>, it is not telling <code>Deserializer</code> that it should parse and deserialize a JSON Boolean from its input data. Instead, Getty is simply providing a hint about the type that is being deserialized into. </p> <p>In other words, Getty is telling <code>Deserializer</code>, \"Hey, the type that the user is deserializing into can probably be constructed from a Getty Boolean, so you should probably deserialize your input data into one.\"</p> <p>What this means is that you don't have to limit yourself to parsing only JSON Booleans in <code>deserializeBool</code>. We could, for instance, have it support JSON numbers as well.</p> Zig code<pre><code>fn deserializeBool(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n    if (try self.tokens.next()) |token| {\n        // JSON Booleans -&gt; Getty Booleans\n        if (token == .True or token == .False) {\n            return try v.visitBool(allocator, De, token == .True);\n        }\n\n        // JSON Numbers -&gt; Getty Booleans\n        if (token == .Number) {\n            if (token.Number.is_integer) {\n                const str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\n                return try v.visitBool(allocator, De, try std.fmt.parseInt(i64, str, 10) != 0);\n            }\n        }\n    }\n\n    return error.InvalidType;\n}\n</code></pre>","location":"getting-started/guide/deserializers/#scalar-deserialization"},{"title":"Aggregate Deserialization","text":"<p>Alright, now let's take a look at deserialization for aggregate types.</p> <p>The difference between scalar and aggregate deserialization is that the aggregate types in Getty's data model do not directly map to any particular Zig type (or set of Zig types). That is, while Booleans are represented by <code>bool</code>s and Integers are represented by any Zig integer type, there's no native data type in Zig that is able to generically represent Sequences or Maps.</p> <p>This is where the aggregate deserialization interfaces come in. They represent the aggregate types in Getty's data model. There are four of them in total:</p>   <code>getty.de.SeqAccess</code>  <p>Represents a Sequence.</p>  <code>getty.de.MapAccess</code>  <p>Represents a Map.</p>  <code>getty.de.UnionAccess</code>, <code>getty.de.VariantAccess</code>  <p>Represents a Union.</p>    <p>Let's start by implementing <code>deserializeSeq</code>, which uses the <code>getty.de.SeqAccess</code> interface.</p>  getty.de.SeqAccess Zig code<pre><code>fn SeqAccess(\n    comptime Context: type,\n    comptime E: type,\n    comptime methods: struct {\n        nextElementSeed: ?fn (Context, ?std.mem.Allocator, seed: anytype) E!?@TypeOf(seed).Value = null,\n    },\n) type\n</code></pre>  <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\nconst Allocator = std.mem.Allocator;\n\nconst Deserializer = struct {\n    tokens: std.json.TokenStream,\n\n    const Self = @This();\n\n    pub usingnamespace getty.Deserializer(\n        *Self,\n        Error,\n        null,\n        null,\n        .{\n            .deserializeBool = deserializeBool,\n            .deserializeEnum = deserializeEnum,\n            .deserializeFloat = deserializeFloat,\n            .deserializeInt = deserializeInt,\n            .deserializeString = deserializeString,\n            .deserializeVoid = deserializeVoid,\n            .deserializeOptional = deserializeOptional,\n            .deserializeSeq = deserializeSeq,\n        },\n    );\n\n    const Error = getty.de.Error ||\n        std.json.TokenStream.Error ||\n        std.fmt.ParseIntError ||\n        std.fmt.ParseFloatError;\n\n    const De = Self.@\"getty.Deserializer\";\n\n    pub fn init(json: []const u8) Self {\n        return .{ .tokens = std.json.TokenStream.init(json) };\n    }\n\n    fn deserializeBool(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n        if (try self.tokens.next()) |token| {\n            if (token == .True or token == .False) {\n                return try v.visitBool(allocator, De, token == .True);\n            }\n        }\n\n        return error.InvalidType;\n    }\n\n    fn deserializeEnum(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n        if (try self.tokens.next()) |token| {\n            if (token == .String) {\n                const str = token.String.slice(self.tokens.slice, self.tokens.i - 1);\n                return try v.visitString(allocator, De, str);\n            }\n        }\n\n        return error.InvalidType;\n    }\n\n    fn deserializeFloat(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n        if (try self.tokens.next()) |token| {\n            if (token == .Number) {\n                const str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\n                return try v.visitFloat(allocator, De, try std.fmt.parseFloat(f64, str));\n            }\n        }\n\n        return error.InvalidType;\n    }\n\n    fn deserializeInt(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n        if (try self.tokens.next()) |token| {\n            if (token == .Number) {\n                const str = token.Number.slice(self.tokens.slice, self.tokens.i - 1);\n\n                if (token.Number.is_integer) {\n                    return try switch (str[0]) {\n                        '-' =&gt; v.visitInt(allocator, De, try std.fmt.parseInt(i64, str, 10)),\n                        else =&gt; v.visitInt(allocator, De, try std.fmt.parseInt(u64, str, 10)),\n                    };\n                }\n            }\n        }\n\n        return error.InvalidType;\n    }\n\n    fn deserializeString(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n        if (try self.tokens.next()) |token| {\n            if (token == .String) {\n                const str = token.String.slice(self.tokens.slice, self.tokens.i - 1);\n                return try v.visitString(allocator, De, try allocator.?.dupe(u8, str));\n            }\n        }\n\n        return error.InvalidType;\n    }\n\n    fn deserializeVoid(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n        if (try self.tokens.next()) |token| {\n            if (token == .Null) {\n                return try v.visitVoid(allocator, De);\n            }\n        }\n\n        return error.InvalidType;\n    }\n\n    fn deserializeOptional(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n        const backup = self.tokens;\n\n        if (try self.tokens.next()) |token| {\n            if (token == .Null) {\n                return try v.visitNull(allocator, De);\n            }\n\n            self.tokens = backup;\n            return try v.visitSome(allocator, self.deserializer());\n        }\n\n        return error.InvalidType;\n    }\n\n    fn deserializeSeq(self: *Self, allocator: ?Allocator, v: anytype) Error!@TypeOf(v).Value {\n        if (try self.tokens.next()) |token| {\n            if (token == .ArrayBegin) {\n                var sa = SeqAccess{ .de = self };\n                return try v.visitSeq(allocator, De, sa.seqAccess());\n            }\n        }\n\n        return error.InvalidType;\n    }\n};\n\nconst SeqAccess = struct {\n    de: *Deserializer,\n\n    pub usingnamespace getty.de.SeqAccess(\n        *@This(),\n        Deserializer.Error,\n        .{ .nextElementSeed = nextElementSeed },\n    );\n\n    // (1)!\n    fn nextElementSeed(self: *@This(), allocator: ?Allocator, seed: anytype) Deserializer.Error!?@TypeOf(seed).Value {\n        const element = seed.deserialize(allocator, self.de.deserializer()) catch |err| {\n            if (self.de.tokens.i - 1 &gt;= self.de.tokens.slice.len) {\n                return err;\n            }\n\n            return switch (self.de.tokens.slice[self.de.tokens.i - 1]) {\n                ']' =&gt; null,\n                else =&gt; err,\n            };\n        };\n\n        return element;\n    }\n};\n\npub fn main() anyerror!void {\n    const allocator = std.heap.page_allocator;\n\n    var d = Deserializer.init(\"[1,2,3]\");\n    const deserializer = d.deserializer();\n\n    const v = try getty.deserialize(allocator, std.ArrayList(i32), deserializer);\n    defer getty.de.free(allocator, v);\n\n    std.debug.print(\"{any} ({})\\n\", .{ v.items, @TypeOf(v) });\n}\n</code></pre> <ol> <li> <p>You can ignore all of the parsing-related code in this function.</p> <p>All we're doing is telling Getty to perform deserialization again (by calling <code>seed.deserialize</code>) so that we can deserialize an element from the deserializer's input data.</p> <p>If there are no elements left (i.e., if <code>]</code> was encountered) then <code>null</code> is returned. Otherwise, the deserialized element is.</p> </li> </ol> Shell session<pre><code>$ zig build run\n{ 1, 2, 3 } (array_list.ArrayListAligned(i32,null))\n</code></pre> <p>Hooray!</p>","location":"getting-started/guide/deserializers/#aggregate-deserialization"},{"title":"Introduction","text":"<p>The goal of Getty is to make writing (de)serializers in Zig easier for you.</p> <p>You can see some of that in the JSON serializer below, which supports scalar and string values. At around 50 lines of code, <code>Serializer</code> is a fully functional serializer capable of converting values of type <code>bool</code>, <code>i32</code>, <code>enum{ foo }</code>, <code>[]u8</code>, <code>*const [5]u8</code>, <code>?void</code>, and more into JSON!</p> Zig code<pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\nconst Serializer = struct {\n    pub usingnamespace getty.Serializer(\n        @This(),\n        Ok,\n        Error,\n        null,\n        null,\n        null,\n        null,\n        null,\n        .{\n            .serializeBool = serializeBool,\n            .serializeEnum = serializeEnum,\n            .serializeFloat = serializeNumber,\n            .serializeInt = serializeNumber,\n            .serializeNull = serializeNull,\n            .serializeSome = serializeSome,\n            .serializeString = serializeString,\n            .serializeVoid = serializeNull,\n        },\n    );\n\n    const Ok = void;\n    const Error = error{};\n\n    fn serializeBool(_: @This(), value: bool) Error!Ok {\n        std.debug.print(\"{}\\n\", .{value});\n    }\n\n    fn serializeEnum(s: @This(), value: anytype) Error!Ok {\n        try s.serializeString(@tagName(value));\n    }\n\n    fn serializeNull(_: @This()) Error!Ok {\n        std.debug.print(\"null\\n\", .{});\n    }\n\n    fn serializeNumber(_: @This(), value: anytype) Error!Ok {\n        std.debug.print(\"{}\\n\", .{value});\n    }\n\n    fn serializeSome(s: @This(), value: anytype) Error!Ok {\n        try getty.serialize(value, s.serializer());\n    }\n\n    fn serializeString(_: @This(), value: anytype) Error!Ok {\n        std.debug.print(\"\\\"{s}\\\"\\n\", .{value});\n    }\n};\n\npub fn main() !void {\n    const s = (Serializer{}).serializer();\n\n    try getty.serialize(\"Getty\", s);\n}\n</code></pre> Shell session<pre><code>$ zig build run\n\"Getty\"\n</code></pre> <p>In this guide, we'll slowly build up to the above <code>Serializer</code> implementation so that by the end of it all, you'll understand everything there is to know about serialization in Getty. We'll also be extending <code>Serializer</code> to support more complex types, such as <code>[5][5]i32</code>, <code>struct{ x: i32 }</code> and <code>std.ArrayList(i32)</code>. And to cap things off, we'll write a JSON deserializer and go over how custom (de)serialization works in Getty.</p> <p>Let's get started!</p>","location":"getting-started/guide/introduction/"},{"title":"Serializers","text":"<p>Let's write a JSON serializer that serializes values by printing their JSON equivalent to <code>STDERR</code>.</p>  <p>Prerequisites</p> <p>This page assumes you understand how Getty interfaces work. If not, take a few minutes to learn about them here.</p>","location":"getting-started/guide/serializers/"},{"title":"Scalar Serialization","text":"<p>Every Getty serializer must implement the <code>getty.Serializer</code> interface, shown below.</p> Zig code<pre><code>// (1)!\nfn Serializer(\n    comptime Context: type, // (2)!\n    comptime O: type, // (3)!\n    comptime E: type, // (4)!\n\n    // (5)!\n    comptime user_sbt: anytype,\n    comptime serializer_sbt: anytype,\n\n    // (6)!\n    comptime Map: ?type,\n    comptime Seq: ?type,\n    comptime Structure: ?type,\n\n    // (7)!\n    comptime methods: struct {\n        // (8)!\n        serializeBool: ?fn (Context, bool) E!O = null,\n        serializeEnum: ?fn (Context, anytype) E!O = null,\n        serializeFloat: ?fn (Context, anytype) E!O = null,\n        serializeInt: ?fn (Context, anytype) E!O = null,\n        serializeMap: ?fn (Context, ?usize) E!Map = null,\n        serializeNull: ?fn (Context) E!O = null,\n        serializeSeq: ?fn (Context, ?usize) E!Seq = null,\n        serializeSome: ?fn (Context, anytype) E!O = null,\n        serializeString: ?fn (Context, anytype) E!O = null,\n        serializeStruct: ?fn (Context, comptime []const u8, usize) E!Structure = null,\n        serializeVoid: ?fn (Context) E!O = null,\n    },\n) type\n</code></pre> <ol> <li> <p>A <code>getty.Serializer</code> serializes     values from Getty's data model.</p> </li> <li> <p><code>Context</code> is the namespace that owns the method implementations passed to     the <code>methods</code> parameter.</p> <p>Usually, this is the type implementing <code>getty.Serializer</code> or a pointer to it if mutability is required.</p> </li> <li> <p><code>O</code> is the successful return type for most of     <code>getty.Serializer</code>'s methods.</p> </li> <li> <p><code>E</code> is the error set returned by     <code>getty.Serializer</code>'s methods upon     failure.</p> </li> <li> <p><code>user_sbt</code> and <code>serializer_sbt</code> are optional user- and serializer-defined     serialization blocks or tuples, respectively.</p> <p>They allow users and serializers to customize Getty's serialization behavior. If user- or serializer-defined customization isn't supported, you can pass in <code>null</code> for these parameters.</p> </li> <li> <p><code>Map</code>, <code>Seq</code>, and <code>Structure</code> are types that implement Getty's aggregate     serialization interfaces.</p> <p>The aggregate serialization interfaces are <code>getty.ser.Map</code>, <code>getty.ser.Seq</code>, and <code>getty.ser.Structure</code>. I'm sure you can figure out which parameters should implement which interfaces.</p> <p>If you don't want to support serialization for aggregate types or if you simply haven't implemented it yet, you can pass in <code>null</code> for these parameters.</p> </li> <li> <p><code>methods</code> contains all of the methods that implementations of     <code>getty.Serializer</code> must provide     or can override.</p> </li> <li> <p>These methods are responsible for serializing a value in Getty's data     model into a data format.</p> </li> </ol> <p>Quite the parameter list!</p> <p>Luckily, most of the parameters have default values we can use. So, let's start with the following:</p> <code>src/main.zig</code><pre><code>const getty = @import(\"getty\");\n\nconst Serializer = struct {\n    pub usingnamespace getty.Serializer(\n        @This(),\n        Ok,\n        Error,\n        null,\n        null,\n        null,\n        null,\n        null,\n        .{},\n    );\n\n    const Ok = void;\n    const Error = error{};\n};\n</code></pre> <p>Bit of a useless serializer, but let's try serializing a value with it anyways. We can do so by calling <code>getty.serialize</code>, which takes a value to serialize and a <code>getty.Serializer</code> interface value.</p> <code>src/main.zig</code><pre><code>const getty = @import(\"getty\");\n\nconst Serializer = struct {\n    pub usingnamespace getty.Serializer(\n        @This(),\n        Ok,\n        Error,\n        null,\n        null,\n        null,\n        null,\n        null,\n        .{},\n    );\n\n    const Ok = void;\n    const Error = error{};\n};\n\npub fn main() anyerror!void {\n    const s = (Serializer{}).serializer();\n\n    try getty.serialize(true, s);\n}\n</code></pre> Shell session<pre><code>$ zig build run\n[...] error: serializeBool is not implemented by type: main.Serializer\n</code></pre> <p>Oh no, a compile error!</p> <p>Looks like Getty can't serialize <code>bool</code> values for us unless the <code>serializeBool</code> method is implemented. So, let's implement it real quick.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\nconst Serializer = struct {\n    pub usingnamespace getty.Serializer(\n        @This(),\n        Ok,\n        Error,\n        null,\n        null,\n        null,\n        null,\n        null,\n        .{\n            .serializeBool = serializeBool,\n        },\n    );\n\n    const Ok = void;\n    const Error = error{};\n\n    fn serializeBool(_: @This(), value: bool) Error!Ok {\n        std.debug.print(\"{}\", .{value});\n    }\n};\n\npub fn main() anyerror!void {\n    const s = (Serializer{}).serializer();\n\n    try getty.serialize(true, s);\n\n    std.debug.print(\"\\n\", .{});\n}\n</code></pre> Shell session<pre><code>$ zig build run\ntrue\n</code></pre> <p>Success!</p> <p>Now let's do the same thing for <code>serializeEnum</code>, <code>serializeFloat</code>, <code>serializeInt</code>, <code>serializeNull</code>, <code>serializeSome</code>, <code>serializeString</code>, and <code>serializeVoid</code>.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\nconst Serializer = struct {\n    pub usingnamespace getty.Serializer(\n        @This(),\n        Ok,\n        Error,\n        null,\n        null,\n        null,\n        null,\n        null,\n        .{\n            .serializeBool = serializeBool,\n            .serializeEnum = serializeEnum,\n            .serializeFloat = serializeNumber,\n            .serializeInt = serializeNumber,\n            .serializeNull = serializeNull,\n            .serializeSome = serializeSome,\n            .serializeString = serializeString,\n            .serializeVoid = serializeNull,\n        },\n    );\n\n    const Ok = void;\n    const Error = error{};\n\n    fn serializeBool(_: @This(), value: bool) Error!Ok {\n        std.debug.print(\"{}\", .{value});\n    }\n\n    fn serializeEnum(self: @This(), value: anytype) Error!Ok {\n        try self.serializeString(@tagName(value));\n    }\n\n    fn serializeNull(_: @This()) Error!Ok {\n        std.debug.print(\"null\", .{});\n    }\n\n    fn serializeNumber(_: @This(), value: anytype) Error!Ok {\n        std.debug.print(\"{}\", .{value});\n    }\n\n    fn serializeSome(self: @This(), value: anytype) Error!Ok {\n        try getty.serialize(value, self.serializer());\n    }\n\n    fn serializeString(_: @This(), value: anytype) Error!Ok {\n        std.debug.print(\"\\\"{s}\\\"\", .{value});\n    }\n};\n\npub fn main() anyerror!void {\n    const s = (Serializer{}).serializer();\n\n    inline for (.{ 10, 10.0, \"string\", .variant, {}, null }) |v| {\n        try getty.serialize(v, s);\n\n        std.debug.print(\"\\n\", .{});\n    }\n}\n</code></pre> Shell session<pre><code>$ zig build run\n10\n1.0e+01\n\"string\"\n\"variant\"\nnull\nnull\n</code></pre> <p>And there we have it! Our initial <code>Serializer</code> implementation, but now with a bit of context!</p>  Method Reuse <p>Since the signatures of the <code>serializeFloat</code> and <code>serializeInt</code> methods are the same, we were able to implement both of them using one function: <code>serializeNumber</code>. We were also able to do the same thing for <code>serializeNull</code> and <code>serializeVoid</code>.</p>   Private Methods <p>By keeping all of our method implementations private, we avoid polluting the public API of <code>Serializer</code> with interface-related code. Additionally, we ensure that users cannot mistakenly use a <code>Serializer</code> value instead of an interface value to perform serialization.</p>   Type Validation <p>Even though the type of the <code>value</code> parameter for many of our methods is <code>anytype</code>, we didn't perform any type validation. That's because Getty ensures that an appropriate type will be passed to each function. For example, strings will be passed to <code>serializeString</code> and integers and floating-points will be passed to <code>serializeNumber</code>.</p>","location":"getting-started/guide/serializers/#scalar-serialization"},{"title":"Aggregate Serialization","text":"<p>Alright, now let's take a look at serialization for aggregate types.</p> <p>If you'll recall, the <code>getty.Serializer</code> interface had the <code>Map</code>, <code>Seq</code>, and <code>Structure</code> parameters. So far, we've just been passing in <code>null</code> for them. However, we'll start using them now.</p> <p>The reason these parameters exist is because aggregate types have all kinds of different access and iteration patterns, but Getty can't possibly know about all of them. As such, serialization methods like <code>serializeMap</code> are only responsible for starting the serialization process, before returning a value of either <code>Map</code>, <code>Seq</code>, or <code>Structure</code>. The returned value is then used by the caller to finish off serialization.</p> <p>To give you an example of what I mean, let's implement the <code>serializeSeq</code> method, which returns a value of type <code>Seq</code>, which is expected to implement the <code>getty.ser.Seq</code> interface.</p>  getty.ser.Seq Zig code<pre><code>// (1)!\nfn Seq(\n    comptime Context: type,\n\n    // (2)!\n    comptime O: type,\n    comptime E: type,\n\n    comptime methods: struct {\n        serializeElement: ?fn (Context, anytype) E!void = null,\n        end: ?fn (Context) E!O = null,\n    },\n) type\n</code></pre> <ol> <li> <p>A <code>getty.ser.Seq</code> is responsible     for serializing the elements of a Sequence and ending the     serialization process for a Sequence.</p> </li> <li> <p>The value of these parameters must match the <code>O</code> and <code>E</code> values of a     corresponding     <code>getty.Serializer</code>     implementation.</p> </li> </ol>  <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\nconst Serializer = struct {\n    pub usingnamespace getty.Serializer(\n        @This(),\n        Ok,\n        Error,\n        null,\n        null,\n        null,\n        Seq,\n        null,\n        .{\n            .serializeBool = serializeBool,\n            .serializeEnum = serializeEnum,\n            .serializeFloat = serializeNumber,\n            .serializeInt = serializeNumber,\n            .serializeNull = serializeNull,\n            .serializeSeq = serializeSeq,\n            .serializeSome = serializeSome,\n            .serializeString = serializeString,\n            .serializeVoid = serializeNull,\n        },\n    );\n\n    const Ok = void;\n    const Error = error{};\n\n    fn serializeBool(_: @This(), value: bool) Error!Ok {\n        std.debug.print(\"{}\", .{value});\n    }\n\n    fn serializeEnum(s: @This(), value: anytype) Error!Ok {\n        try s.serializeString(@tagName(value));\n    }\n\n    fn serializeNull(_: @This()) Error!Ok {\n        std.debug.print(\"null\", .{});\n    }\n\n    fn serializeNumber(_: @This(), value: anytype) Error!Ok {\n        std.debug.print(\"{}\", .{value});\n    }\n\n    fn serializeSeq(_: @This(), _: ?usize) Error!Seq {\n        std.debug.print(\"[\", .{});\n\n        return Seq{};\n    }\n\n    fn serializeSome(s: @This(), value: anytype) Error!Ok {\n        try getty.serialize(value, s.serializer());\n    }\n\n    fn serializeString(_: @This(), value: anytype) Error!Ok {\n        std.debug.print(\"\\\"{s}\\\"\", .{value});\n    }\n};\n\nconst Seq = struct {\n    first: bool = true,\n\n    pub usingnamespace getty.ser.Seq(\n        *@This(),\n        Ok,\n        Error,\n        .{\n            .serializeElement = serializeElement,\n            .end = end,\n        },\n    );\n\n    const Ok = Serializer.Ok;\n    const Error = Serializer.Error;\n\n    fn serializeElement(s: *@This(), value: anytype) Error!void {\n        switch (s.first) {\n            true =&gt; s.first = false,\n            false =&gt; std.debug.print(\", \", .{}),\n        }\n\n        try getty.serialize(value, (Serializer{}).serializer());\n    }\n\n    fn end(_: *@This()) Error!Ok {\n        std.debug.print(\"]\", .{});\n    }\n};\n\npub fn main() anyerror!void {\n    const s = (Serializer{}).serializer();\n\n    var list = std.ArrayList(i32).init(std.heap.page_allocator);\n    defer list.deinit();\n    try list.append(1);\n    try list.append(2);\n    try list.append(3);\n\n    try getty.serialize(list, s);\n\n    std.debug.print(\"\\n\", .{});\n}\n</code></pre> Shell session<pre><code>$ zig build run\n[1, 2, 3]\n</code></pre> <p></p> <p>If you'll notice, we didn't have to write any iteration- or access-related code specific to the <code>std.ArrayList</code> type. All we had to do was specify how sequence serialization should start, how elements should be serialized, and how serialization should end. And Getty took care of the rest!</p> <p>Okay, that leaves us with <code>serializeMap</code> and <code>serializeStruct</code>, which return implementations of <code>getty.ser.Map</code> and <code>getty.ser.Structure</code>, respectively.</p>  getty.ser.Map Zig code<pre><code>// (1)!\nfn Map(\n    comptime Context: type,\n\n    // (2)!\n    comptime O: type,\n    comptime E: type,\n\n    comptime methods: struct {\n        serializeKey: ?fn (Context, anytype) E!void = null,\n        serializeValue: ?fn (Context, anytype) E!void = null,\n        end: ?fn (Context) E!O = null,\n    },\n) type\n</code></pre> <ol> <li> <p>A <code>getty.ser.Map</code> is responsible     for serializing the keys and values of a Map and ending the     serialization process for a Map.</p> </li> <li> <p>The value of these parameters must match the <code>O</code> and <code>E</code> values of a     corresponding     <code>getty.Serializer</code>     implementation.</p> </li> </ol>   getty.ser.Structure Zig code<pre><code>// (1)!\nfn Structure(\n    comptime Context: type,\n\n    // (2)!\n    comptime O: type,\n    comptime E: type,\n\n    comptime methods: struct {\n        serializeField: ?fn (Context, comptime []const u8, anytype) E!void = null,\n        end: ?fn (Context) E!O = null,\n    },\n) type\n</code></pre> <ol> <li> <p>A <code>getty.ser.Structure</code> is     responsible for serializing the fields of a Structure and ending the     serialization process for a Structure.</p> </li> <li> <p>The value of these parameters must match the <code>O</code> and <code>E</code> values of a     corresponding     <code>getty.Serializer</code>     implementation.</p> </li> </ol>  <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\nconst Serializer = struct {\n    pub usingnamespace getty.Serializer(\n        @This(),\n        Ok,\n        Error,\n        null,\n        null,\n        Map,\n        Seq,\n        Map,\n        .{\n            .serializeBool = serializeBool,\n            .serializeEnum = serializeEnum,\n            .serializeFloat = serializeNumber,\n            .serializeInt = serializeNumber,\n            .serializeMap = serializeMap,\n            .serializeNull = serializeNull,\n            .serializeSeq = serializeSeq,\n            .serializeSome = serializeSome,\n            .serializeString = serializeString,\n            .serializeStruct = serializeStruct,\n            .serializeVoid = serializeNull,\n        },\n    );\n\n    const Ok = void;\n    const Error = error{};\n\n    fn serializeBool(_: @This(), value: bool) Error!Ok {\n        std.debug.print(\"{}\", .{value});\n    }\n\n    fn serializeEnum(s: @This(), value: anytype) Error!Ok {\n        try s.serializeString(@tagName(value));\n    }\n\n    fn serializeMap(_: @This(), _: ?usize) Error!Map {\n        std.debug.print(\"{{\", .{});\n\n        return Map{};\n    }\n\n    fn serializeNull(_: @This()) Error!Ok {\n        std.debug.print(\"null\", .{});\n    }\n\n    fn serializeNumber(_: @This(), value: anytype) Error!Ok {\n        std.debug.print(\"{}\", .{value});\n    }\n\n    fn serializeSeq(_: @This(), _: ?usize) Error!Seq {\n        std.debug.print(\"[\", .{});\n\n        return Seq{};\n    }\n\n    fn serializeSome(self: @This(), value: anytype) Error!Ok {\n        try getty.serialize(value, self.serializer());\n    }\n\n    fn serializeString(_: @This(), value: anytype) Error!Ok {\n        std.debug.print(\"\\\"{s}\\\"\", .{value});\n    }\n\n    fn serializeStruct(self: @This(), comptime _: []const u8, len: usize) Error!Map {\n        return try self.serializeMap(len);\n    }\n};\n\nconst Seq = struct {\n    first: bool = true,\n\n    pub usingnamespace getty.ser.Seq(\n        *@This(),\n        Ok,\n        Error,\n        .{\n            .serializeElement = serializeElement,\n            .end = end,\n        },\n    );\n\n    const Ok = Serializer.Ok;\n    const Error = Serializer.Error;\n\n    fn serializeElement(self: *@This(), value: anytype) Error!void {\n        switch (self.first) {\n            true =&gt; self.first = false,\n            false =&gt; std.debug.print(\", \", .{}),\n        }\n\n        try getty.serialize(value, (Serializer{}).serializer());\n    }\n\n    fn end(_: *@This()) Error!Ok {\n        std.debug.print(\"]\", .{});\n    }\n};\n\nconst Map = struct {\n    first: bool = true,\n\n    pub usingnamespace getty.ser.Map(\n        *@This(),\n        Ok,\n        Error,\n        .{\n            .serializeKey = serializeKey,\n            .serializeValue = serializeValue,\n            .end = end,\n        },\n    );\n\n    pub usingnamespace getty.ser.Structure(\n        *@This(),\n        Ok,\n        Error,\n        .{\n            .serializeField = serializeField,\n            .end = end,\n        },\n    );\n\n    const Ok = Serializer.Ok;\n    const Error = Serializer.Error;\n\n    fn serializeKey(self: *@This(), value: anytype) Error!void {\n        switch (self.first) {\n            true =&gt; self.first = false,\n            false =&gt; std.debug.print(\", \", .{}),\n        }\n\n        try getty.serialize(value, (Serializer{}).serializer());\n    }\n\n    fn serializeValue(_: *@This(), value: anytype) Error!void {\n        std.debug.print(\": \", .{});\n\n        try getty.serialize(value, (Serializer{}).serializer());\n    }\n\n    fn serializeField(self: *@This(), comptime key: []const u8, value: anytype) Error!void {\n        try self.serializeKey(key);\n        try self.serializeValue(value);\n    }\n\n    fn end(_: *@This()) Error!Ok {\n        std.debug.print(\"}}\", .{});\n    }\n};\n\npub fn main() anyerror!void {\n    const s = (Serializer{}).serializer();\n\n    var map = std.StringHashMap(i32).init(std.heap.page_allocator);\n    defer map.deinit();\n    try map.put(\"x\", 1);\n    try map.put(\"y\", 2);\n\n    try getty.serialize(map, s);\n\n    std.debug.print(\"\\n\", .{});\n}\n</code></pre> Shell session<pre><code>$ zig build run\n{\"x\": 1, \"y\": 2}\n</code></pre> <p>And there we go! Our JSON serializer is now complete!</p>","location":"getting-started/guide/serializers/#aggregate-serialization"},{"title":"Setup","text":"<p>First things first, we need to set up a new project to work in.</p> <ol> <li> <p>Create a new Zig project called <code>getty-learn</code>:</p> Shell session<pre><code>mkdir getty-learn\ncd getty-learn\nzig init-exe\n</code></pre> </li> <li> <p>Install Getty into the <code>lib/getty</code> directory within <code>getty-learn</code>:</p> Shell session<pre><code>git clone https://github.com/getty-zig/getty lib/getty\n</code></pre> </li> <li> <p>Make <code>getty-learn</code> aware of Getty by calling <code>addPackagePath</code> in <code>build.zig</code>:</p> <code>build.zig</code><pre><code>const std = @import(\"std\");\n\npub fn build(b: *std.build.Builder) void {\n    // ...\n\n    const exe = b.addExecutable(\"getty-learn\", \"src/main.zig\");\n    exe.setTarget(target);\n    exe.setBuildMode(mode);\n    exe.addPackagePath(\"getty\", \"lib/getty/src/getty.zig\");\n    exe.install();\n}\n</code></pre> </li> <li> <p>Create and run the following program to check that everything is working.</p> <code>src/main.zig</code><pre><code>const std = @import(\"std\");\nconst getty = @import(\"getty\");\n\npub fn main() anyerror!void {\n    std.debug.print(\"{}\\n\", .{getty});\n}\n</code></pre> Shell session<pre><code>$ zig build run\ngetty\n</code></pre> </li> </ol>","location":"getting-started/guide/setup/"}]}